{
    "543": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the count of answers for the post owned by the user 'csgillespie', who has the maximum number of answers, so the SQL SELECT needs to count the answers from posts and filter by the owner's display name while also finding the max answer count.\n#columns: posts.AnswerCount, posts.OwnerDisplayName\n#values: 'csgillespie' refers to posts.OwnerDisplayName = 'csgillespie'\n#SELECT: SELECT count of answers refers to posts.AnswerCount\n#SQL-like: Show posts.AnswerCount where posts.OwnerDisplayName = 'csgillespie' and posts.AnswerCount = MAX(AnswerCount)\n#SQL: SELECT MAX(T.AnswerCount) FROM posts AS T WHERE T.OwnerDisplayName = 'csgillespie'\n```"
    ],
    "202": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of triple type bonds, so the SQL SELECT will count the occurrences of bond_type equal to '#'.\n#columns: bond.bond_type\n#values: triple type bonds refer to bond.bond_type = '#'\n#SELECT: How many triple type bonds refer to COUNT(bond.bond_type)\n#SQL-like: Show COUNT(bond.bond_type), WHERE bond.bond_type = '#'\n#SQL: SELECT COUNT(bond.bond_type) FROM bond WHERE bond.bond_type = '#'\n```"
    ],
    "357": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the type of promotion for the card 'Duress', so the SQL SELECT will gather the promoTypes from the cards table, filtering for the card with the name 'Duress'.\n#columns: cards.promoTypes, cards.name\n#values: 'card Duress' refers to cards.name = 'Duress'\n#SELECT: type of promotion refers to cards.promoTypes\n#SQL-like: Show cards.promoTypes, WHERE cards.name = 'Duress'\n#SQL: SELECT promoTypes FROM cards WHERE name = 'Duress'\n```"
    ],
    "264": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the labels for specific molecule ids, so the SQL SELECT will retrieve the label for each specified molecule id.\n#columns: molecule.label, molecule.molecule_id\n#values: 'TR000, TR001 and TR002' refer to 'molecule.molecule_id IN ('TR000', 'TR001', 'TR002')'\n#SELECT: SELECT label refer to molecule.label\n#SQL-like: Show molecule.label WHERE molecule.molecule_id IN ('TR000', 'TR001', 'TR002')\n#SQL: SELECT label FROM molecule WHERE molecule_id IN ('TR000', 'TR001', 'TR002')\n```"
    ],
    "886": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify \"which year has the most number of races\", so the SQL SELECT will focus on the year and the count of races, grouping by year and ordering by the count in descending order.\n#columns: races.year, races.round\n#values: None\n#SELECT: SELECT year refer to races.year\n#SQL-like: Show races.year, GROUP BY races.year, ORDER BY COUNT(races.round) DESC LIMIT 1\n#SQL: SELECT year FROM races GROUP BY year ORDER BY COUNT(round) DESC LIMIT 1\n```"
    ],
    "957": [
        "```\n#reason: The question requires counting how many drivers are Italian and haven't finished the race, which is indicated by the time being NULL.\n#columns: drivers.driverId, results.time\n#values: Italian drivers refer to drivers.nationality = 'Italian', haven't finished the race refers to results.time IS NULL\n#SELECT: How many Italian drivers refer to COUNT(drivers.driverId)\n#SQL-like: Show COUNT(drivers.driverId), WHERE drivers.nationality = 'Italian' AND results.time IS NULL\n#SQL: SELECT COUNT(T1.driverId) FROM drivers AS T1 LEFT JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'Italian' AND T2.time IS NULL\n```"
    ],
    "540": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the title of the post owned by the user \"csgillespie\" with the highest popularity, so the SQL SELECT will filter by the user's display name and order by the view count to get the maximum.\n#columns: posts.Title, posts.ViewCount, users.DisplayName\n#values: \"csgillespie\" refer to users.DisplayName = 'csgillespie'\n#SELECT: SELECT posts.Title refer to posts.Title\n#SQL-like: Show posts.Title, WHERE users.DisplayName = 'csgillespie', ORDER BY posts.ViewCount DESC LIMIT 1\n#SQL: SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'csgillespie' ORDER BY T1.ViewCount DESC LIMIT 1\n```"
    ],
    "162": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the region of the client with a specific ID, so the SQL SELECT will retrieve the region from the district table by joining it with the client table based on district_id.\n#columns: district.A3, client.client_id, client.district_id\n#values: client id 3541 refers to client.client_id = 3541\n#SELECT: region refer to district.A3\n#SQL-like: Show district.A3, WHERE client.client_id = 3541\n#SQL: SELECT T2.A3 FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.client_id = 3541\n```"
    ],
    "472": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to know how many sets in the block \"Ice Age\" have an Italian translation, so the SQL SELECT COUNT(*) and the filtering conditions are applied)\n#columns: sets.id, set_translations.translation\n#values: 'sets in the block \"Ice Age\"' refer to sets.block = 'Ice Age', 'Italian translation' refer to set_translations.language = 'Italian' AND set_translations.translation IS NOT NULL\n#SELECT: SELECT COUNT(*) refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE sets.block = 'Ice Age' AND set_translations.language = 'Italian' AND set_translations.translation IS NOT NULL\n#SQL: SELECT COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL\n```"
    ],
    "907": [
        "```\n#reason: The question requires listing all races in 2017 and their hosting country, so the SQL SELECT will include races information and join with circuits to get the country.\n#columns: races.name, circuits.country\n#values: 'in 2017' refers to races.year = 2017\n#SELECT: SELECT races.name, circuits.country\n#SQL-like: SHOW races.name, circuits.country WHERE races.year = 2017 ORDER BY races.date\n#SQL: SELECT T1.name, T2.country FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2017 ORDER BY T1.date\n```"
    ],
    "1402": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the most popular size of t-shirt ordered by club members, which refers to the MAX(COUNT(t_shirt_size)). \n#columns: member.t_shirt_size\n#values: the most popular size of t-shirt ordered refer to COUNT(member.t_shirt_size)\n#SELECT: SELECT the most popular size of t-shirt refer to member.t_shirt_size.\n#SQL-like: Show member.t_shirt_size, Group by member.t_shirt_size, Order by COUNT(member.t_shirt_size) DESC, LIMIT 1\n#SQL: SELECT member.t_shirt_size FROM member GROUP BY member.t_shirt_size ORDER BY COUNT(member.t_shirt_size) DESC LIMIT 1\n```"
    ],
    "280": [
        "```\n#reason: The question wants to enumerate the bond ID of triple bond type molecules and indicate if they are carcinogenic or not, so the SQL SELECT will retrieve bond.bond_id and molecule.label based on the filtering conditions for bond type and molecule label.\n#columns: bond.bond_id, molecule.label\n#values: triple bond refers to bond.bond_type = '#' and carcinogenic status refers to molecule.label in ('+', '-')\n#SELECT: SELECT bond.bond_id, molecule.label refer to bond.bond_id, molecule.label\n#SQL-like: Show bond.bond_id, molecule.label WHERE bond.bond_type = '#' AND molecule.label IN ('+', '-')\n#SQL: SELECT bond.bond_id, molecule.label FROM bond INNER JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE bond.bond_type = '#' AND molecule.label IN ('+', '-')\n```"
    ],
    "814": [
        "```\n#reason: The question requires displaying \"the skin colour\" of superheroes with a specific \"attribute value\". Skin colour refers to colour.colour where the skin_colour_id corresponds to colour.id, and the attribute value of 100 is filtered from hero_attribute.attribute_value.\n#columns: colour.colour, hero_attribute.attribute_value\n#values: attribute value 100 refers to hero_attribute.attribute_value = 100\n#SELECT: skin colour refers to colour.colour\n#SQL-like: Show colour.colour, WHERE hero_attribute.attribute_value = 100\n#SQL: SELECT T1.colour FROM hero_attribute AS T2 INNER JOIN colour AS T1 ON T2.hero_id = superhero.id WHERE T2.attribute_value = 100\n```"
    ],
    "982": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to know how many American drivers have a puncture status, so the SQL SELECT will count the drivers with the specified status and nationality)\n#columns: drivers.nationality, results.status\n#values: 'puncture status' refer to results.status = 'Puncture', 'American' refer to drivers.nationality = 'American'\n#SELECT: SELECT COUNT(*) refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE results.status = 'Puncture' AND drivers.nationality = 'American'\n#SQL: SELECT COUNT(*) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.statusId = (SELECT statusId FROM status WHERE status = 'Puncture') AND T1.nationality = 'American'\n```"
    ],
    "161": [
        "```\n#reason: The question wants to determine the type of credit card owned by a specific client, so the SQL SELECT will filter by client ID and retrieve the credit card type.\n#columns: card.type, client.client_id\n#values: client id 13539 refers to client.client_id = 13539\n#SELECT: type of credit card refer to card.type\n#SQL-like: Show card.type WHERE client.client_id = 13539\n#SQL: SELECT T1.type FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.client_id = 13539\n```"
    ],
    "935": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of drivers who finished the race, so the SQL SELECT will count the driver IDs where the finish time is not null for the 2008 Australian Grand Prix.\n#columns: results.driverId, results.time, races.raceId\n#values: 'in the 2008 Australian Grand Prix' refer to races.name = 'Australian Grand Prix' AND races.year = 2008, 'managed to finish the race' refer to results.time IS NOT NULL\n#SELECT: COUNT(results.driverId) refer to results.driverId\n#SQL-like: Show COUNT(results.driverId), WHERE results.time IS NOT NULL AND races.name = 'Australian Grand Prix' AND races.year = 2008\n#SQL: SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NOT NULL AND T2.name = 'Australian Grand Prix' AND T2.year = 2008\n```"
    ],
    "977": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the count of finishers who have been disqualified from race numbers 50 to 100. \"Disqualified\" refers to statusID = 2, and \"finishers\" refers to having a non-null time. The race numbers are filtered by raceId being greater than 50 and less than 100.\n#columns: results.raceId, results.statusId, results.time\n#values: raceId > 50 AND raceId < 100 refer to results.raceId > 50 AND results.raceId < 100, disqualified refers to results.statusId = 2, finisher refers to results.time IS NOT NULL\n#SELECT: COUNT(results.raceId) refer to COUNT(results.raceId)\n#SQL-like: Show COUNT(results.raceId) WHERE results.raceId > 50 AND results.raceId < 100 AND results.statusId = 2 AND results.time IS NOT NULL\n#SQL: SELECT COUNT(T1.raceId) FROM results AS T1 WHERE T1.raceId > 50 AND T1.raceId < 100 AND T1.statusId = 2 AND T1.time IS NOT NULL\n```"
    ],
    "911": [
        "```\n#reason: The question wants to identify which circuit has the highest latitude, so the SQL SELECT will fetch circuits based on the maximum latitude value.\n#columns: circuits.name, circuits.lat\n#values: Silverstone Circuit, Hockenheimring, Hungaroring refer to 'maximum latitude'\n#SELECT: SELECT circuits.name, circuits.lat refer to circuits with the maximum latitude\n#SQL-like: Show circuits.name, circuits.lat ORDER BY circuits.lat DESC LIMIT 1\n#SQL: SELECT circuits.name, circuits.lat FROM circuits WHERE circuits.lat = (SELECT MAX(lat) FROM circuits WHERE circuits.name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring'))\n```"
    ],
    "461": [
        "```\n#reason: The question wants to list the names of the top 3 cards with the highest converted mana cost and have a 2003 card frame style, so the SQL SELECT will focus on the 'name' of the cards filtered by 'frameVersion' and ordered by 'convertedManaCost'.\n#columns: cards.name, cards.convertedManaCost, cards.frameVersion\n#values: '2003 card frame style' refers to cards.frameVersion = '2003'\n#SELECT: SELECT cards.name refer to cards.name\n#SQL-like: Show cards.name, WHERE cards.frameVersion = '2003', ORDER BY cards.convertedManaCost DESC LIMIT 3\n#SQL: SELECT cards.name FROM cards WHERE cards.frameVersion = '2003' ORDER BY cards.convertedManaCost DESC LIMIT 3\n```"
    ],
    "784": [
        "```\n#reason: The question wants to display the \"full names of vampire heroes\". \"Vampire\" is a filtering condition referring to race.\n#columns: superhero.full_name, race.race\n#values: race = 'Vampire' refer to race.race = 'Vampire'\n#SELECT: full names refer to superhero.full_name\n#SQL-like: Show superhero.full_name, WHERE race.race = 'Vampire'\n#SQL: SELECT T1.full_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Vampire'\n```"
    ],
    "4": [
        "```\n#reason: The question wants to list the phone numbers of the direct charter-funded schools that were opened after 2000/1/1, so the SQL SELECT will filter by `Charter School (Y/N)` and the `OpenDate` condition.\n#columns: schools.Phone, frpm.`Charter Funding Type`, frpm.`Charter School (Y/N)`, frpm.`OpenDate`\n#values: 'direct charter-funded' refers to frpm.`Charter Funding Type` = 'Directly funded', 'opened after 2000/1/1' refers to frpm.`OpenDate` > '2000-01-01'\n#SELECT: SELECT phone numbers refer to schools.Phone\n#SQL-like: Show schools.Phone WHERE frpm.`Charter Funding Type` = 'Directly funded' AND frpm.`OpenDate` > '2000-01-01'\n#SQL: SELECT schools.Phone FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.`Charter Funding Type` = 'Directly funded' AND frpm.`OpenDate` > '2000-01-01'\n```"
    ],
    "743": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of superheroes who act in their own self-interest or make decisions based on their own moral code, and also count how many of these superheroes were published by Marvel Comics. The SQL SELECT will calculate the percentage and count based on the filtering conditions provided.\n#columns: superhero.id, publisher.publisher_name, superhero.alignment_id\n#values: published by Marvel Comics refers to publisher.publisher_name = 'Marvel Comics', superheroes who act in their own self-interest or make decisions based on their own moral code refers to alignment.alignment = 'Bad'\n#SELECT: percentage of superheroes who act in their own self-interest or make decisions based on their own moral code, and count how many of the said superheroes were published by Marvel Comics refer to CAST(SUM(CASE WHEN alignment.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(superhero.id), COUNT(CASE WHEN alignment.alignment = 'Bad' AND publisher.publisher_name = 'Marvel Comics' THEN superhero.id END)\n#SQL-like: Show CAST(SUM(CASE WHEN alignment.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(superhero.id), COUNT(CASE WHEN alignment.alignment = 'Bad' AND publisher.publisher_name = 'Marvel Comics' THEN superhero.id END)\n#SQL: SELECT CAST(SUM(CASE WHEN T1.alignment = 'Bad' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), COUNT(CASE WHEN T1.alignment = 'Bad' AND T4.publisher_name = 'Marvel Comics' THEN T1.id END) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN publisher AS T4 ON T1.publisher_id = T4.id\n```"
    ],
    "1022": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"preferred foot when attacking\" of the \"player with the lowest potential\", so the SQL SELECT will retrieve the preferred_foot where the potential is the minimum.\n#columns: Player_Attributes.potential, Player_Attributes.preferred_foot\n#values: lowest potential refers to MIN(potential)\n#SELECT: preferred foot when attacking refers to preferred_foot\n#SQL-like: Show Player_Attributes.preferred_foot, ORDER BY Player_Attributes.potential LIMIT 1\n#SQL: SELECT preferred_foot FROM Player_Attributes ORDER BY potential ASC LIMIT 1\n```"
    ],
    "74": [
        "```\n#reason: The question wants to find the \"lowest grade\" for schools identified as \"District Special Education Consortia School\", so the SQL SELECT will retrieve the lowest grade where the EdOpsCode indicates it is a District Special Education Consortia School.\n#columns: schools.LowGrade\n#values: 'District Special Education Consortia School' refers to schools.EdOpsCode = 'SPECON', 'National Center for Educational Statistics school district identification number of 0613360' refers to schools.NCESDist = '0613360'\n#SELECT: SELECT lowest grade refer to schools.LowGrade\n#SQL-like: Show schools.LowGrade WHERE schools.EdOpsCode = 'SPECON' AND schools.NCESDist = '0613360'\n#SQL: SELECT LowGrade FROM schools WHERE EdOpsCode = 'SPECON' AND NCESDist = '0613360'\n```"
    ],
    "1277": [
        "```\n#reason: Analyze how to generate SQL based on the question.(format: the question want to count patients with a normal anti-DNA level and data not recorded, so the SQL SELECT will count unique patients where the anti-DNA level is less than 8 and the description is null.)\n#columns: DISTINCT Patient.ID, Laboratory.DNA, Patient.Description\n#values: normal anti-DNA level refers to Laboratory.DNA < 8, data are not recorded refers to Patient.Description IS NULL\n#SELECT: How many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.DNA < 8 AND Patient.Description IS NULL\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.DNA < 8 AND P.Description IS NULL\n```"
    ],
    "39": [
        "```\n#reason: The question wants to find the average number of test takers from Fresno schools that opened in 1980, so the SQL SELECT will calculate the average of the number of test takers where the school opened in that year.\n#columns: satscores.NumTstTakr, schools.OpenDate\n#values: 'opened between 1/1/1980 and 12/31/1980' refer to 'schools.OpenDate BETWEEN '1980-01-01' AND '1980-12-31''\n#SELECT: SELECT AVG(satscores.NumTstTakr) refer to satscores.NumTstTakr\n#SQL-like: Show AVG(satscores.NumTstTakr), WHERE schools.OpenDate BETWEEN '1980-01-01' AND '1980-12-31'\n#SQL: SELECT AVG(satscores.NumTstTakr) FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.OpenDate BETWEEN '1980-01-01' AND '1980-12-31'\n```"
    ],
    "265": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list down the molecule id for non-carcinogenic molecules, so the SQL SELECT will focus on the molecule_id from the molecule table where the label indicates non-carcinogenic status.\n#columns: molecule.molecule_id\n#values: non-carcinogenic molecules refer to molecule.label = '-'\n#SELECT: SELECT molecule id refer to molecule.molecule_id\n#SQL-like: Show molecule.molecule_id, WHERE molecule.label = '-'\n#SQL: SELECT molecule_id FROM molecule WHERE label = '-'\n```"
    ],
    "1168": [
        "```\n#reason: The question wants to find the date of the oldest SJS patient's laboratory work and their age at the time of their initial hospital visit, so the SQL SELECT will retrieve the Laboratory.Date and the age calculated using the difference between the year of the patient's Birthday and the year of the First Date.\n#columns: Laboratory.Date, Patient.Birthday, Patient.`First Date`\n#values: 'oldest SJS patient' refers to the patient whose diagnosis is 'SJS' and has the earliest (oldest) Birthday value in the dataset.\n#SELECT: SELECT Laboratory.Date, (strftime('%Y', Patient.`First Date`) - strftime('%Y', Patient.Birthday)) AS age\n#SQL-like: Show Laboratory.Date, SUBTRACT(year(`First Date`), year(Birthday)) WHERE Patient.Diagnosis = 'SJS' ORDER BY Patient.Birthday ASC LIMIT 1\n#SQL: SELECT L.Date, (strftime('%Y', P.`First Date`) - strftime('%Y', P.Birthday)) AS age FROM Laboratory AS L INNER JOIN Patient AS P ON L.ID = P.ID WHERE P.Diagnosis = 'SJS' ORDER BY P.Birthday ASC LIMIT 1\n```"
    ],
    "1143": [
        "```\n#reason: The question wants to find the highest score of the home team in the Netherlands Eredivisie league, so the SQL SELECT will focus on the home_team_goal column and filter by the league name.\n#columns: Match.home_team_goal, Match.league_id, League.name\n#values: 'Eredivisie' refer to League.name = 'Eredivisie'\n#SELECT: highest score refer to MAX(Match.home_team_goal)\n#SQL-like: Show MAX(Match.home_team_goal) WHERE League.name = 'Eredivisie'\n#SQL: SELECT MAX(Match.home_team_goal) FROM Match INNER JOIN League ON Match.league_id = League.id WHERE League.name = 'Eredivisie'\n```"
    ],
    "1530": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the top five best selling products, which implies sorting by the total sales amount and limiting the results to five entries. The full name of the products is contained in the Description column.\n#columns: products.Description, SUM(transactions_1k.Amount) AS TotalSales\n#values: best selling products refer to ORDER BY TotalSales DESC\n#SELECT: SELECT Description refer to products.Description\n#SQL-like: Show products.Description, ORDER BY SUM(transactions_1k.Amount) DESC LIMIT 5\n#SQL: SELECT products.Description FROM products INNER JOIN transactions_1k ON products.ProductID = transactions_1k.ProductID GROUP BY products.Description ORDER BY SUM(transactions_1k.Amount) DESC LIMIT 5\n```"
    ],
    "1184": [
        "```\n#reason: The question wants to find \"what symptoms\" for a specific patient, so the SQL SELECT will retrieve symptoms from the Examination table, filtered by the patient's birthday and examination date.\n#columns: Examination.Symptoms, Patient.Birthday, Examination.`Examination Date`\n#values: birthday was 1959/3/1 refer to Patient.Birthday = '1959-03-01', examination on 1993/9/27 refer to Examination.`Examination Date` = '1993-09-27'\n#SELECT: Symptoms refer to Examination.Symptoms\n#SQL-like: Show Examination.Symptoms, WHERE Patient.Birthday = '1959-03-01' AND Examination.`Examination Date` = '1993-09-27'\n#SQL: SELECT E.Symptoms FROM Examination AS E INNER JOIN Patient AS P ON E.ID = P.ID WHERE P.Birthday = '1959-03-01' AND E.`Examination Date` = '1993-09-27'\n```"
    ],
    "1206": [
        "```\n#reason: The question wants to find the date of a laboratory examination for a specific patient where the GOT index is above the normal range, so the SQL SELECT will focus on the date of the laboratory examination and apply the relevant filters.\n#columns: Laboratory.Date\n#values: 'patient 48473' refer to Patient.ID = 48473 and 'GOT index is above the normal range' refer to Laboratory.GOT > 60\n#SELECT: SELECT Laboratory.Date refer to Laboratory.Date\n#SQL-like: Show Laboratory.Date, WHERE Patient.ID = 48473 AND Laboratory.GOT >= 60\n#SQL: SELECT T1.Date FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.ID = 48473 AND T1.GOT >= 60\n```"
    ],
    "600": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all posts related to a specific post ID and retrieve the popularity of those posts. Therefore, the SQL SELECT will include the related post IDs and their view counts.\n#columns: post.Id, post.ViewCount\n#values: post ID 61217 refers to postLinks.PostId = 61217\n#SELECT: SELECT all posts that are related to post ID 61217 and their popularity refer to post.ViewCount\n#SQL-like: Show post.Id, post.ViewCount WHERE postLinks.PostId = 61217\n#SQL: SELECT T1.Id, T1.ViewCount FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.RelatedPostId WHERE T2.PostId = 61217\n```"
    ],
    "276": [
        "```\n#reason: The question wants to display the atom IDs of the first and second atoms of triple bond type molecules, so the SQL SELECT will retrieve atom_id and atom_id2 from the connected table where the bond type is '#'.\n#columns: connected.atom_id, connected.atom_id2\n#values: triple bond refers to bond.bond_type = '#'\n#SELECT: atom IDs refer to connected.atom_id, connected.atom_id2\n#SQL-like: Show connected.atom_id, connected.atom_id2 WHERE bond.bond_type = '#'\n#SQL: SELECT T1.atom_id, T2.atom_id2 FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_type = '#'\n```"
    ],
    "864": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find out how many drivers finished the race on a specific date, so the SQL SELECT will count the number of records where the finishing time is present.\n#columns: results.time\n#values: race on 2015/11/29 refers to races.date = '2015-11-29'\n#SELECT: SELECT COUNT(*) refers to counting the number of drivers who finished the race, which is indicated by the presence of time in the results table.\n#SQL-like: Show COUNT(*) WHERE results.time IS NOT NULL AND results.raceId IN (SELECT raceId FROM races WHERE date = '2015-11-29')\n#SQL: SELECT COUNT(*) FROM results WHERE time IS NOT NULL AND raceId IN (SELECT raceId FROM races WHERE date = '2015-11-29')\n```"
    ],
    "622": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the name of the badge obtained by the user whose display name is \"Sharpie\", so the SQL SELECT will include badges.Name and filter by users.DisplayName = 'Sharpie'.\n#columns: badges.Name, users.DisplayName\n#values: 'Sharpie' refer to users.DisplayName = 'Sharpie'\n#SELECT: SELECT badges.Name refer to badges.Name\n#SQL-like: Show badges.Name, WHERE users.DisplayName = 'Sharpie'\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Sharpie'\n```"
    ],
    "380": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the edhrecRank for cards specifically filtered by the frame version 2015.\n#columns: cards.edhrecRank, cards.frameVersion\n#values: frame version 2015 refers to cards.frameVersion = '2015'\n#SELECT: SELECT edhrecRank refer to cards.edhrecRank\n#SQL-like: Show cards.edhrecRank, WHERE cards.frameVersion = '2015'\n#SQL: SELECT edhrecRank FROM cards WHERE frameVersion = '2015'\n```"
    ],
    "1231": [
        "```\n#reason: The question wants to count how many male patients born between 1936 and 1956 have creatinine phosphokinase levels beyond the normal range. Therefore, the SQL SELECT will count distinct Patient.ID where the conditions for birth year, sex, and CPK are met.\n#columns: Patient.ID, Patient.Birthday, Patient.SEX, Laboratory.CPK\n#values: born between 1936-1956 refers to strftime('%Y', Patient.Birthday) BETWEEN '1936' AND '1956', male patients refers to Patient.SEX = 'M', creatinine phosphokinase beyond the normal range refers to Laboratory.CPK >= 250\n#SELECT: COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE strftime('%Y', Patient.Birthday) BETWEEN '1936' AND '1956' AND Patient.SEX = 'M' AND Laboratory.CPK >= 250\n#SQL: SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', Patient.Birthday) BETWEEN '1936' AND '1956' AND Patient.SEX = 'M' AND Laboratory.CPK >= 250\n```"
    ],
    "695": [
        "```\n#reason: The question wants to count the number of users who were awarded the 'Citizen Patrol' badge, so the SQL SELECT COUNT(DISTINCT badges.UserId) and the filtering condition is badges.Name = 'Citizen Patrol'.\n#columns: badges.UserId, badges.Name\n#values: 'Citizen Patrol' refers to badges.Name = 'Citizen Patrol'\n#SELECT: SELECT COUNT(DISTINCT badges.UserId) refer to badges.UserId\n#SQL-like: Show COUNT(DISTINCT badges.UserId), WHERE badges.Name = 'Citizen Patrol'\n#SQL: SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol'\n```"
    ],
    "708": [
        "```\n#reason: The question wants to list the creation date and age of users who commented with a website link, so the SQL SELECT will fetch the users' creation date and age based on the condition that the comment text contains 'http://'.\n#columns: comments.CreationDate, users.Age\n#values: commented with website refers to comments.Text LIKE '%http://%'\n#SELECT: SELECT comments.CreationDate, users.Age\n#SQL-like: Show comments.CreationDate, users.Age, WHERE comments.Text LIKE '%http://%'\n#SQL: SELECT comments.CreationDate, users.Age FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Text LIKE '%http://%'\n```"
    ],
    "1200": [
        "```\n#reason: The question wants to calculate the proportion of patients who had signs of thrombocytopenia and were diagnosed with SLE. Therefore, the SQL SELECT will count the patients with the diagnosis of SLE and divide it by the total count of patients with symptoms of thrombocytopenia, then multiply by 100 to get the percentage.\n#columns: Examination.Symptoms, Patient.Diagnosis\n#values: 'thrombocytopenia' refers to Examination.Symptoms LIKE '%thrombocytopenia%', 'SLE' refers to Patient.Diagnosis LIKE '%SLE%'\n#SELECT: proportion of patients with SLE diagnosed among those with thrombocytopenia refers to (SUM(Patient.Diagnosis LIKE '%SLE%') / SUM(Examination.Symptoms LIKE '%thrombocytopenia%')) * 100\n#SQL-like: Show (SUM(Patient.Diagnosis LIKE '%SLE%') / SUM(Examination.Symptoms LIKE '%thrombocytopenia%')) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN P.Diagnosis LIKE '%SLE%' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN E.Symptoms LIKE '%thrombocytopenia%' THEN 1 ELSE 0 END) FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID\n```"
    ],
    "196": [
        "```\n#reason: The question wants to count the number of non-carcinogenic molecules containing chlorine atoms, so the SQL SELECT will count the distinct molecule ids from the atom table where the molecule is non-carcinogenic and contains chlorine atoms.\n#columns: DISTINCT atom.molecule_id\n#values: non-carcinogenic molecules refer to molecule.label = '-' and chlorine atoms refer to atom.element = 'cl'\n#SELECT: SELECT COUNT(DISTINCT atom.molecule_id) refer to DISTINCT atom.molecule_id\n#SQL-like: Show COUNT(DISTINCT atom.molecule_id), WHERE molecule.label = '-' AND atom.element = 'cl'\n#SQL: SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' AND T1.element = 'cl'\n```"
    ],
    "1532": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the country that had a gas station which sold the most expensive product with ID No.2 for one unit, so the SQL SELECT will include the country, gas station, and product details conditional on the price of the product being maximized.\n#columns: gasstations.Country, transactions_1k.GasStationID, products.ProductID, transactions_1k.Price\n#values: most expensive product id No.2 for one unit refer to transactions_1k.Price = (SELECT MAX(Price) FROM transactions_1k WHERE ProductID = 2)\n#SELECT: SELECT country refer to gasstations.Country, gas station reference to transactions_1k.GasStationID, product id No.2 reference to transactions_1k.ProductID\n#SQL-like: Show gasstations.Country, transactions_1k.GasStationID, transactions_1k.ProductID, WHERE transactions_1k.Price = (SELECT MAX(Price) FROM transactions_1k WHERE ProductID = 2)\n#SQL: SELECT T1.Country, T2.GasStationID, T2.ProductID FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Price = (SELECT MAX(Price) FROM transactions_1k WHERE ProductID = 2)\n```"
    ],
    "352": [
        "```\n#reason: The question wants to calculate the \"percentage of the cards available in Chinese Simplified\". The calculation involves dividing the count of card IDs where the language is 'Chinese Simplified' by the total count of card IDs and multiplying by 100 to get the percentage.\n#columns: foreign_data.language, cards.id\n#values: 'Chinese Simplified' refer to foreign_data.language = 'Chinese Simplified'\n#SELECT: SELECT CAST(SUM(CASE WHEN T1.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id) refer to foreign_data.language, cards.id.\n#SQL-like: Show CAST(SUM(CASE WHEN foreign_data.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(cards.id)\n#SQL: SELECT CAST(SUM(CASE WHEN T1.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id) FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid\n```"
    ],
    "1354": [
        "```\n#reason: The question wants to determine the major name for the Vice President of the club, so the SQL SELECT will involve joining the member and major tables to get the relevant major information for the member in the position of Vice President.\n#columns: member.link_to_major, major.major_name\n#values: 'Vice President' refer to member.position = 'Vice President'\n#SELECT: SELECT major_name refer to major.major_name\n#SQL-like: Show major.major_name, WHERE member.position = 'Vice President'\n#SQL: SELECT T2.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.position = 'Vice President'\n```"
    ],
    "132": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the average loan amount by male borrowers, so the SQL SELECT will calculate the average of the loan amount while filtering for male clients.\n#columns: loan.amount, client.gender\n#values: male refers to client.gender = 'M'\n#SELECT: average loan amount refers to AVG(loan.amount)\n#SQL-like: Show AVG(loan.amount), WHERE client.gender = 'M'\n#SQL: SELECT AVG(loan.amount) FROM loan AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T3.gender = 'M'\n```"
    ],
    "343": [
        "```\n#reason: The question requires naming all cards with a specific frame style and a ranking condition. \"2015 frame style\" is a filtering condition, and \"ranking below 100\" is another filtering condition.\n#columns: cards.name, cards.edhrecRank, cards.frameVersion\n#values: 'with 2015 frame style' refers to cards.frameVersion = '2015', 'ranking below 100' refers to cards.edhrecRank < 100\n#SELECT: SELECT cards.name refer to cards.name\n#SQL-like: Show cards.name WHERE cards.frameVersion = '2015' AND cards.edhrecRank < 100\n#SQL: SELECT name FROM cards WHERE frameVersion = '2015' AND edhrecRank < 100\n```"
    ],
    "306": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify molecules with triple bonds and list all the elements they contain, so the SQL SELECT will retrieve the molecule IDs and the corresponding elements.\n#columns: bond.molecule_id, atom.element\n#values: triple bond refers to bond.bond_type = '#'\n#SELECT: SELECT DISTINCT bond.molecule_id, atom.element refer to bond.molecule_id, atom.element\n#SQL-like: Show DISTINCT bond.molecule_id, atom.element, WHERE bond.bond_type = '#'\n#SQL: SELECT DISTINCT bond.molecule_id, atom.element FROM bond INNER JOIN atom ON bond.molecule_id = atom.molecule_id WHERE bond.bond_type = '#'\n```"
    ],
    "500": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the Japanese name of the set which the card \"Fellwar Stone\" is in, so the SQL SELECT will retrieve `set_translations.translation` based on the filtering condition involving `cards.name = 'Fellwar Stone'` and `foreign_data.language = 'Japanese'`.\n#columns: set_translations.translation, cards.name, foreign_data.language\n#values: 'card \"Fellwar Stone\"' refer to 'cards.name = 'Fellwar Stone'', 'Japanese name' refer to 'foreign_data.language = 'Japanese''\n#SELECT: SELECT set_translations.translation refer to foreign_data.language, cards.name\n#SQL-like: Show set_translations.translation WHERE cards.name = 'Fellwar Stone' AND foreign_data.language = 'Japanese'\n#SQL: SELECT T1.translation FROM set_translations AS T1 INNER JOIN cards AS T2 ON T1.setCode = T2.setCode INNER JOIN foreign_data AS T3 ON T2.uuid = T3.uuid WHERE T2.name = 'Fellwar Stone' AND T3.language = 'Japanese'\n```"
    ],
    "450": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of cards designed by Aaron Miller that are incredibly powerful, so the SQL SELECT will count the cards where the artist is 'Aaron Miller' and both cardKingdomFoilId and cardKingdomId are not null.\n#columns: cards.id\n#values: 'designed by Aaron Miller' refer to cards.artist = 'Aaron Miller', 'are incredibly powerful' refer to cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SELECT: COUNT(*) refer to cards.id\n#SQL-like: Show COUNT(*) WHERE cards.artist = 'Aaron Miller' AND cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SQL: SELECT COUNT(*) FROM cards WHERE cards.artist = 'Aaron Miller' AND cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n```"
    ],
    "706": [
        "```\n#reason: The question wants to retrieve the texts of comments on posts that have a title containing 'linear regression', so the SQL SELECT will focus on the comments related to those posts.\n#columns: comments.Text\n#values: Title contains 'linear regression' refer to posts.Title LIKE '%linear regression%'\n#SELECT: SELECT comments.Text\n#SQL-like: Show comments.Text WHERE posts.Title LIKE '%linear regression%'\n#SQL: SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%linear regression%'\n```"
    ],
    "938": [
        "```\n#reason: The question wants to identify the champion of the 2008 Australian Grand Prix and provide a URL for more information, so the SQL SELECT will retrieve the driver's name and the URL.\n#columns: results.time, drivers.url\n#values: '2008 Australian Grand Prix' refers to races.name = 'Australian Grand Prix' AND races.year = 2008\n#SELECT: champion's finished time refers to results.time, where can I know more refers to drivers.url\n#SQL-like: Show results.time, drivers.url WHERE races.name = 'Australian Grand Prix' AND races.year = 2008\n#SQL: SELECT T1.time, T2.url FROM results AS T1 INNER JOIN races AS T3 ON T1.raceId = T3.raceId INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T3.name = 'Australian Grand Prix' AND T3.year = 2008 AND T1.position = 1\n```"
    ],
    "899": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list circuits that hosted 4 F1 races from the year 1990 to 2000, so the SQL SELECT will count the races grouped by circuit and filter by the specified year range.\n#columns: circuits.circuitId, circuits.name\n#values: from year 1990 to 2000 refers to \"strftime('%Y', races.date) BETWEEN '1990' AND '2000'\"\n#SELECT: SELECT circuits.circuitId, circuits.name\n#SQL-like: Show circuits.circuitId, circuits.name WHERE strftime('%Y', races.date) BETWEEN '1990' AND '2000' GROUP BY circuits.circuitId HAVING COUNT(races.raceId) = 4\n#SQL: SELECT T1.circuitId, T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE strftime('%Y', T2.date) BETWEEN '1990' AND '2000' GROUP BY T1.circuitId HAVING COUNT(T2.raceId) = 4\n```"
    ],
    "879": [
        "```\n#reason: The question wants to find the nationality of the driver who set the fastest lap speed, so the SQL SELECT will retrieve the nationality based on the maximum fastest lap speed.\n#columns: drivers.nationality, results.fastestLapSpeed\n#values: fastest lap speed refers to results.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)\n#SELECT: nationality refers to drivers.nationality\n#SQL-like: Show drivers.nationality WHERE results.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)\n#SQL: SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)\n```"
    ],
    "152": [
        "```\n#reason: The question wants to calculate the average number of crimes committed in regions where the number exceeds 4000 and where accounts were opened starting from 1997. This requires filtering for regions with a specific crime count and account criteria, thus the SQL SELECT will include an average calculation for the crime counts along with the specified conditions.\n#columns: district.A3, district.A15, account.date\n#values: number exceeds 4000 refers to district.A15 > 4000; accounts opened starting from the year 1997 refers to account.date >= '1997-01-01'\n#SELECT: SELECT AVG(district.A15) refer to average number of crimes committed.\n#SQL-like: Show AVG(district.A15) WHERE district.A15 > 4000 AND account.date >= '1997-01-01'\n#SQL: SELECT AVG(T1.A15) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE T1.A15 > 4000 AND T2.date >= '1997-01-01'\n```"
    ],
    "1179": [
        "```\n#reason: The question wants to find out the anti-Cardiolipin antibody concentration status for the patient diagnosed with SLE on a specific date, so the SQL SELECT will retrieve the required concentration status based on the diagnosis date and examination date.\n#columns: Examination.aCL IgM\n#values: diagnosed with SLE refers to Patient.Diagnosis = 'SLE', 1994/2/19 refers to Patient.Description = '1994-02-19', 1993/11/12 refers to Examination.`Examination Date` = '1993-11-12'\n#SELECT: SELECT Examination.aCL IgM\n#SQL-like: Show Examination.aCL IgM WHERE Patient.Diagnosis = 'SLE' AND Patient.Description = '1994-02-19' AND Examination.`Examination Date` = '1993-11-12'\n#SQL: SELECT T1.`aCL IgM` FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SLE' AND T2.Description = '1994-02-19' AND T1.`Examination Date` = '1993-11-12'\n```"
    ],
    "441": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"set code\" of the set with a specific release date, so the SQL SELECT will focus on the sets.code column filtered by the release date.\n#columns: sets.code\n#values: release date of 07/13/2007 refers to sets.releaseDate = '2007-07-13'\n#SELECT: SELECT set code refer to sets.code\n#SQL-like: Show sets.code WHERE sets.releaseDate = '2007-07-13'\n#SQL: SELECT sets.code FROM sets WHERE sets.releaseDate = '2007-07-13'\n```"
    ],
    "1127": [
        "```\n#reason: The question wants to locate players with vision scores of 90 and above, so the SQL SELECT will retrieve player names and associated countries meeting the vision score condition.\n#columns: Player.player_name, Country.name\n#values: vision scores of 90 and above refer to Player_Attributes.vision > 89\n#SELECT: player names refer to Player.player_name, country names refer to Country.name\n#SQL-like: Show Player.player_name, Country.name WHERE Player_Attributes.vision > 89\n#SQL: SELECT T1.player_name, T2.name FROM Player AS T1 INNER JOIN Player_Attributes AS T3 ON T1.player_api_id = T3.player_api_id INNER JOIN Team AS T4 ON T1.player_api_id = T4.team_api_id INNER JOIN League AS T5 ON T4.team_api_id = T5.country_id INNER JOIN Country AS T2 ON T5.country_id = T2.id WHERE T3.vision > 89\n```"
    ],
    "792": [
        "```\n#reason: The question wants to display \"Abomination's superpower\", so the SQL SELECT will retrieve the superpower associated with the superhero named 'Abomination'.\n#columns: superpower.power_name, superhero.superhero_name\n#values: 'Abomination' refer to superhero.superhero_name = 'Abomination'\n#SELECT: Abomination's superpower refer to superpower.power_name\n#SQL-like: Show superpower.power_name, WHERE superhero.superhero_name = 'Abomination'\n#SQL: SELECT T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = 'Abomination'\n```"
    ],
    "1432": [
        "```\n#reason: The question wants to calculate the percentage of members with a t-shirt size of medium who received an amount of 50 in the Student Club. The SQL SELECT statement will filter members based on their t-shirt size and calculate the percentage based on the specified amount.\n#columns: member.t_shirt_size, income.amount, member.member_id\n#values: t-shirt size of medium refers to member.t_shirt_size = 'Medium'\n#SELECT: percentage of members with t-shirt size of medium who received an amount of 50 refer to DIVIDE(COUNT(amount = 50), COUNT(member_id)) * 100\n#SQL-like: Show DIVIDE(COUNT(amount = 50), COUNT(member_id)) * 100, WHERE member.t_shirt_size = 'Medium'\n#SQL: SELECT CAST(SUM(CASE WHEN T2.amount = 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T1.t_shirt_size = 'Medium'\n```"
    ],
    "1376": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the event with the highest spend-to-budget ratio among all closed events, so the SQL SELECT will calculate the ratio of spent to amount and find the maximum value for closed events.\n#columns: event.event_name, budget.spent, budget.amount\n#values: closed events refer to event.status = 'Closed'\n#SELECT: SELECT event.event_name, budget.spent, budget.amount\n#SQL-like: Show event.event_name, budget.spent, budget.amount WHERE event.status = 'Closed' ORDER BY (budget.spent * 1.0 / budget.amount) DESC LIMIT 1\n#SQL: SELECT event.event_name, budget.spent, budget.amount FROM event INNER JOIN budget ON event.event_id = budget.link_to_event WHERE event.status = 'Closed' ORDER BY (budget.spent * 1.0 / budget.amount) DESC LIMIT 1\n```"
    ],
    "447": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the 'code of sets' that have an 'expansion commander type', so the SQL SELECT will include the 'setCode' from the 'sets' table where the 'type' equals 'expansion' and the 'block' equals 'Commander'.\n#columns: sets.setCode\n#values: 'expansion commander type' refers to sets.type = 'expansion' AND sets.block = 'Commander'\n#SELECT: code of sets refers to sets.setCode\n#SQL-like: Show sets.setCode WHERE sets.type = 'expansion' AND sets.block = 'Commander'\n#SQL: SELECT setCode FROM sets WHERE type = 'expansion' AND block = 'Commander'\n```"
    ],
    "1147": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find a player with the greatest overall strength, so the SQL SELECT will output the player’s name with the maximum overall rating.\n#columns: Player.player_name, Player_Attributes.overall_rating\n#values: overall strength is the greatest refers to MAX(overall_rating)\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE overall strength = MAX(overall_rating)\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\n```"
    ],
    "337": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"element\" and \"bond type\" included in a specific molecule identified by its molecule ID. The SQL SELECT will retrieve these columns from the atom and bond tables filtered by the molecule ID.\n#columns: atom.element, bond.bond_type\n#values: TR002 refers to molecule.molecule_id = 'TR002'\n#SELECT: SELECT atom.element, bond.bond_type refer to atom.element, bond.bond_type\n#SQL-like: Show atom.element, bond.bond_type WHERE molecule_id = 'TR002'\n#SQL: SELECT T1.element, T2.bond_type FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR002'\n```"
    ],
    "453": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the unconverted mana cost of the card \"Ancestor's Chosen\", so the SQL SELECT will retrieve the convertedManaCost from the cards table where the name matches the specified card.\n#columns: cards.convertedManaCost\n#values: name = 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen'\n#SELECT: SELECT convertedManaCost refer to cards.convertedManaCost\n#SQL-like: Show convertedManaCost WHERE cards.name = 'Ancestor''s Chosen'\n#SQL: SELECT convertedManaCost FROM cards WHERE name = 'Ancestor''s Chosen'\n```"
    ],
    "493": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the parent code of the set \"Commander 2014 Oversized\", so the SQL SELECT statement will focus on the table that contains the set information and filter it based on the set name.\n#columns: sets.parentCode, sets.name\n#values: 'Commander 2014 Oversized' refer to sets.name = 'Commander 2014 Oversized'\n#SELECT: SELECT parentCode refer to sets.parentCode\n#SQL-like: Show sets.parentCode WHERE sets.name = 'Commander 2014 Oversized'\n#SQL: SELECT sets.parentCode FROM sets WHERE sets.name = 'Commander 2014 Oversized'\n```"
    ],
    "1392": [
        "```\n#reason: The question wants to identify the top source of funds received in September 2019 based on their amount, so the SQL SELECT will focus on the source of funds and their corresponding amounts within the specified date range.\n#columns: income.source, income.amount\n#values: September 2019 refers to `date_received BETWEEN '2019-09-01' AND '2019-09-30'`\n#SELECT: top source refer to `income.source`\n#SQL-like: Show income.source, WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30', ORDER BY income.amount DESC LIMIT 1\n#SQL: SELECT source FROM income WHERE date_received BETWEEN '2019-09-01' AND '2019-09-30' ORDER BY amount DESC LIMIT 1\n```"
    ],
    "1172": [
        "```\n#reason: The question wants to determine the number of male patients with elevated total bilirubin count, so the SQL SELECT will count the patients where SEX is 'M' and total bilirubin is above the normal range.\n#columns: Patient.SEX, Laboratory.`T-BIL`\n#values: male refers to SEX = 'M', elevated total bilirubin count refers to `T-BIL` >= 2.0\n#SELECT: How many male patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Patient.SEX = 'M' AND Laboratory.`T-BIL` >= 2.0\n#SQL: SELECT COUNT(P1.ID) FROM Patient AS P1 INNER JOIN Laboratory AS L1 ON P1.ID = L1.ID WHERE P1.SEX = 'M' AND L1.`T-BIL` >= 2.0\n```"
    ],
    "742": [
        "```\n#reason: The question wants to count the number of superheroes belonging to the vampire race, so the SQL SELECT will count the superhero.id where the race is 'Vampire'.\n#columns: superhero.id, race.race\n#values: 'Vampire' refers to race.race = 'Vampire'\n#SELECT: How many vampire superheroes refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE race.race = 'Vampire'\n#SQL: SELECT COUNT(superhero.id) FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE race.race = 'Vampire'\n```"
    ],
    "898": [
        "```\n#reason: The question wants to identify the \"youngest Japanese driver\" and calculate his age. The \"youngest\" refers to the maximum date of birth (dob), and \"Japanese\" refers to the nationality being 'Japanese'. The age is calculated as the difference between the current year and the year of birth.\n#columns: drivers.dob, drivers.forename, drivers.surname\n#values: nationality = 'Japanese' refers to drivers.nationality = 'Japanese'\n#SELECT: SELECT (YEAR(CURRENT_TIMESTAMP) - YEAR(drivers.dob)) AS age, drivers.forename, drivers.surname\n#SQL-like: Show age, drivers.forename, drivers.surname WHERE drivers.nationality = 'Japanese' ORDER BY drivers.dob DESC LIMIT 1\n#SQL: SELECT (CAST(strftime('%Y', 'now') AS INTEGER) - CAST(strftime('%Y', drivers.dob) AS INTEGER)) AS age, drivers.forename, drivers.surname FROM drivers WHERE drivers.nationality = 'Japanese' ORDER BY drivers.dob DESC LIMIT 1\n```"
    ],
    "683": [
        "```\n#reason: The question wants to calculate the percentage of posts owned by users with a reputation over 1000 in the year 2011. The SQL SELECT counts the posts where the reputation condition is met and divides by the total count of posts, multiplying by 100 to get a percentage.\n#columns: posts.Id, users.Reputation, posts.CreaionDate\n#values: 'owned by users with a reputation of over 1000' refer to users.Reputation > 1000, 'in 2011' refer to strftime('%Y', posts.CreaionDate) = '2011'\n#SELECT: SELECT CAST(COUNT(posts.Id) WHERE strftime('%Y', posts.CreaionDate) = '2011' AND users.Reputation > 1000 AS REAL) * 100 / COUNT(posts.Id)\n#SQL-like: Show CAST(COUNT(posts.Id) WHERE strftime('%Y', posts.CreaionDate) = '2011' AND users.Reputation > 1000 AS REAL) * 100 / COUNT(posts.Id)\n#SQL: SELECT CAST(COUNT(CASE WHEN strftime('%Y', posts.CreaionDate) = '2011' AND users.Reputation > 1000 THEN posts.Id ELSE NULL END) AS REAL) * 100 / COUNT(posts.Id) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id\n```"
    ],
    "797": [
        "```\n#reason: The question wants to identify superheroes with specific eye and hair colors, so the SQL SELECT will include the superhero's name and filter based on the eye and hair colors.\n#columns: superhero.superhero_name, colour.colour\n#values: 'blue eyes' refer to colour.colour = 'Blue' and colour.id = superhero.eye_colour_id, 'brown hair' refer to colour.colour = 'Brown' and colour.id = superhero.hair_colour_id\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE colour.colour = 'Blue' AND colour.colour = 'Brown'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Brown'\n```"
    ],
    "1131": [
        "```\n#reason: The question wants to calculate the \"average heights\" of players from \"Italy\", so the SQL SELECT will use AVG(height) and filter players based on the country name 'Italy'.\n#columns: Player.height, Country.name\n#values: 'Italy' refers to Country.name = 'Italy'\n#SELECT: SELECT AVG(Player.height) refer to Player.height\n#SQL-like: Show AVG(Player.height), WHERE Country.name = 'Italy'\n#SQL: SELECT AVG(T1.height) FROM Player AS T1 INNER JOIN Team AS T2 ON T1.player_api_id = T2.team_api_id INNER JOIN League AS T3 ON T2.team_fifa_api_id = T3.country_id INNER JOIN Country AS T4 ON T3.country_id = T4.id WHERE T4.name = 'Italy'\n```"
    ],
    "1140": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"sprint speed\", \"agility\", and \"acceleration scores\" for \"Alexis Blin\". \"Alexis Blin\" is the filtering condition.\n#columns: Player_Attributes.sprint_speed, Player_Attributes.agility, Player_Attributes.acceleration\n#values: 'Alexis Blin' refers to Player.player_name = 'Alexis Blin'\n#SELECT: sprint speed, agility, acceleration refer to Player_Attributes.sprint_speed, Player_Attributes.agility, Player_Attributes.acceleration\n#SQL-like: Show Player_Attributes.sprint_speed, Player_Attributes.agility, Player_Attributes.acceleration, WHERE Player.player_name = 'Alexis Blin'\n#SQL: SELECT T1.sprint_speed, T2.agility, T2.acceleration FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Alexis Blin'\n```"
    ],
    "481": [
        "```\n#reason: The question wants to list all the foreign languages in which the card \"Ancestor's Chosen\" has a flavor text, so the SQL SELECT will filter by the card name and check for non-null flavor text.\n#columns: foreign_data.language\n#values: 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen', flavor text is not null refer to foreign_data.flavorText IS NOT NULL\n#SELECT: SELECT foreign_data.language refer to foreign_data.language\n#SQL-like: Show foreign_data.language WHERE cards.name = 'Ancestor''s Chosen' AND foreign_data.flavorText IS NOT NULL\n#SQL: SELECT foreign_data.language FROM foreign_data INNER JOIN cards ON foreign_data.uuid = cards.uuid WHERE cards.name = 'Ancestor''s Chosen' AND foreign_data.flavorText IS NOT NULL\n```"
    ],
    "366": [
        "```\n#reason: The question wants to retrieve the rule of playing the card \"Benalish Knight\", so the SQL SELECT will fetch the text associated with that card's original text.\n#columns: cards.originalText\n#values: 'Benalish Knight' refers to cards.name = 'Benalish Knight'\n#SELECT: SELECT originalText refer to cards.originalText\n#SQL-like: Show cards.originalText, WHERE cards.name = 'Benalish Knight'\n#SQL: SELECT T1.originalText FROM cards AS T1 WHERE T1.name = 'Benalish Knight'\n```"
    ],
    "1105": [
        "```\n#reason: The question wants to find \"Francesco Migliore's attacking work rate\" based on the player's name and the specific date, so the SQL SELECT will retrieve the attacking work rate for the player on that date.\n#columns: Player.player_name, Player_Attributes.attacking_work_rate, Player_Attributes.date\n#values: 'Francesco Migliore' refer to Player.player_name = 'Francesco Migliore', '2015-05-01' refer to Player_Attributes.date LIKE '2015-05-01%'\n#SELECT: SELECT Player_Attributes.attacking_work_rate refer to Player_Attributes.attacking_work_rate\n#SQL-like: Show Player_Attributes.attacking_work_rate, WHERE Player.player_name = 'Francesco Migliore' AND Player_Attributes.date LIKE '2015-05-01%'\n#SQL: SELECT T2.attacking_work_rate FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Francesco Migliore' AND T2.date LIKE '2015-05-01%'\n```"
    ],
    "77": [
        "```\n#reason: The question wants to find \"which schools served a grade span of Kindergarten to 9th grade in the county of Los Angeles\" and \"what is its Percent (%) Eligible FRPM (Ages 5-17)\". So the SQL SELECT will include school names and the percentage calculated from the FRPM count and enrollment for ages 5-17.\n#columns: schools.School, frpm.`Percent (%) Eligible FRPM (Ages 5-17)`\n#values: 'Kindergarten to 9th grade' refers to schools.GSserved = 'K-9', 'Los Angeles' refers to frpm.`County Name` = 'Los Angeles'\n#SELECT: SELECT schools.School, (CAST(frpm.`FRPM Count (Ages 5-17)` AS REAL) / CAST(frpm.`Enrollment (Ages 5-17)` AS REAL) * 100) AS `Percent (%) Eligible FRPM (Ages 5-17)`\n#SQL-like: Show schools.School, (FRPM Count (Ages 5-17) / Enrollment (Ages 5-17) * 100), WHERE schools.GSserved = 'K-9' AND frpm.`County Name` = 'Los Angeles'\n#SQL: SELECT schools.School, (CAST(frpm.`FRPM Count (Ages 5-17)` AS REAL) / CAST(frpm.`Enrollment (Ages 5-17)` AS REAL) * 100) AS `Percent (%) Eligible FRPM (Ages 5-17)` FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.GSserved = 'K-9' AND frpm.`County Name` = 'Los Angeles'\n```"
    ],
    "1501": [
        "```\n#reason: The question wants to list the countries of gas stations with transactions that took place in June 2013, so the SQL SELECT will retrieve gasstation.Country based on the filtering conditions from transactions in June 2013.\n#columns: gasstations.Country, transactions_1k.GasStationID, yearmonth.Date\n#values: June 2013 refers to SUBSTR(yearmonth.Date, 1, 4) = '2013' AND SUBSTR(yearmonth.Date, 5, 2) = '06'\n#SELECT: SELECT DISTINCT gasstations.Country refer to gasstations.Country\n#SQL-like: Show DISTINCT gasstations.Country, WHERE transactions_1k.Date LIKE '2013-06%'\n#SQL: SELECT DISTINCT T1.Country FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID INNER JOIN yearmonth AS T3 ON T2.Date LIKE T3.Date WHERE SUBSTR(T3.Date, 1, 4) = '2013' AND SUBSTR(T3.Date, 5, 2) = '06'\n```"
    ],
    "1081": [
        "```\n#reason: The question wants to identify \"Which country\" the \"Belgium Jupiler League\" is associated with. The filtering condition is that the league name is \"Belgium Jupiler League\".\n#columns: League.country_id, Country.name\n#values: Belgium Jupiler League refer to League.name = 'Belgium Jupiler League'\n#SELECT: SELECT Country.name refer to Country.name\n#SQL-like: Show Country.name, WHERE League.name = 'Belgium Jupiler League'\n#SQL: SELECT T2.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T1.name = 'Belgium Jupiler League'\n```"
    ],
    "1055": [
        "```\n#reason: The question wants to identify the birthday of the football player with the highest overall rating, so the SQL SELECT retrieves the birthday of the player where the overall rating is maximized.\n#columns: Player.birthday, Player_Attributes.overall_rating\n#values: highest overall rating refers to MAX(overall_rating)\n#SELECT: SELECT Player.birthday, Player_Attributes.overall_rating\n#SQL-like: Show Player.birthday WHERE overall_rating is maximized\n#SQL: SELECT T1.birthday FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id ORDER BY T2.overall_rating DESC LIMIT 1\n```"
    ],
    "709": [
        "```\n#reason: The question wants to find the count of posts that have a view count lower than 5 and have comments with a score of 0, so the SQL SELECT will count the posts and filter based on the conditions provided.\n#columns: posts.Id, posts.ViewCount, comments.Score\n#values: view count lower than 5 refers to posts.ViewCount < 5, comments with 0 score refers to comments.Score = 0\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id), WHERE posts.ViewCount < 5 AND comments.Score = 0\n#SQL: SELECT COUNT(posts.Id) FROM posts INNER JOIN comments ON posts.Id = comments.PostId WHERE posts.ViewCount < 5 AND comments.Score = 0\n```"
    ],
    "1018": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the average time in milliseconds spent at a pit stop by Lewis Hamilton, so the SQL SELECT will compute AVG(milliseconds) with a filter for Lewis Hamilton.\n#columns: pitStops.milliseconds, drivers.driverId\n#values: 'Lewis Hamilton' refer to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SELECT: SELECT AVG(pitStops.milliseconds) refer to pitStops.milliseconds\n#SQL-like: Show AVG(pitStops.milliseconds), WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SQL: SELECT AVG(T1.milliseconds) FROM pitStops AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton'\n```"
    ],
    "1085": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify which of the specified players performs the best in crossing actions, so the SQL SELECT will determine the maximum crossing score among those players.\n#columns: Player.player_name, Player_Attributes.crossing\n#values: 'Alexis', 'Ariel Borysiuk', 'Arouna Kone' refer to Player.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone')\n#SELECT: SELECT Player.player_name, Player_Attributes.crossing\n#SQL-like: Show Player.player_name, Player_Attributes.crossing WHERE Player.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY Player_Attributes.crossing DESC LIMIT 1\n#SQL: SELECT P.player_name, PA.crossing FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.player_name IN ('Alexis', 'Ariel Borysiuk', 'Arouna Kone') ORDER BY PA.crossing DESC LIMIT 1\n```"
    ],
    "345": [
        "```\n#reason: The question wants to display the legalities status for artifact type cards that do not have multiple faces on the same card, so the SQL SELECT will include the legalities status from the legalities table, filtering by type 'Artifact', side NULL, and format 'vintage'.\n#columns: cards.type, legalities.status\n#values: 'artifact type of cards' refer to cards.type = 'Artifact', 'card does not have multiple faces on the same card' refer to cards.side IS NULL, 'vintage play format' refer to legalities.format = 'vintage'\n#SELECT: SELECT legalities.status refer to legalities.status\n#SQL-like: Show legalities.status WHERE cards.type = 'Artifact' AND cards.side IS NULL AND legalities.format = 'vintage'\n#SQL: SELECT T2.status FROM legalities AS T2 INNER JOIN cards AS T1 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T1.side IS NULL AND T2.format = 'vintage'\n```"
    ],
    "1056": [
        "```\n#reason: The question wants to display the \"name of the football league\" in the country of \"Netherlands\", so the SQL SELECT will focus on League.name and filter by the country.\n#columns: League.name, Country.name\n#values: 'Netherlands' refer to Country.name = 'Netherlands'\n#SELECT: SELECT League.name refer to League.name\n#SQL-like: Show League.name, WHERE Country.name = 'Netherlands'\n#SQL: SELECT League.name FROM League INNER JOIN Country ON League.country_id = Country.id WHERE Country.name = 'Netherlands'\n```"
    ],
    "1258": [
        "```\n#reason: The question wants to know how many patients have a normal Rhuematoid Factor and a positive measure of degree of coagulation, so the SQL SELECT will count the distinct patient IDs where the corresponding conditions are met.\n#columns: Patient.ID, Laboratory.RA, Examination.KCT\n#values: normal Rhuematoid Factor refers to Laboratory.RA IN ('-', '+-') and positive measure of degree of coagulation refers to Examination.KCT = '+'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.RA IN ('-', '+-') AND Examination.KCT = '+'\n#SQL: SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Laboratory.RA IN ('-', '+-') AND Examination.KCT = '+'\n```"
    ],
    "1453": [
        "```\n#reason: The question requires displaying \"the name of events\" with a condition that the parking cost is less than the average. The average parking cost is calculated by dividing the total parking cost by the count of events, and the filter for this query is based on the category being 'Parking'.\n#columns: event.event_name, budget.amount, budget.link_to_event\n#values: less than average parking cost refers to budget.amount < (SELECT AVG(budget.amount) FROM budget WHERE budget.category = 'Parking')\n#SELECT: SELECT event.event_name refer to event.event_name\n#SQL-like: Show event.event_name WHERE budget.amount < (SELECT AVG(budget.amount) FROM budget WHERE budget.category = 'Parking')\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.amount < (SELECT AVG(T3.amount) FROM budget AS T3 WHERE T3.category = 'Parking')\n```"
    ],
    "1039": [
        "```\n#reason: The question wants to find the average number of long shots done by Ahmed Samir Farag, so the SQL SELECT will calculate the average using the sum of long shots divided by the count of player FIFA API IDs.\n#columns: Player_Attributes.long_shots, Player_Attributes.player_fifa_api_id\n#values: 'Ahmed Samir Farag' refers to Player.player_name = 'Ahmed Samir Farag'\n#SELECT: average number of long shot refer to DIVIDE(SUM(long_shots), COUNT(player_fifa_api_id))\n#SQL-like: Show DIVIDE(SUM(long_shots), COUNT(player_fifa_api_id)), WHERE Player.player_name = 'Ahmed Samir Farag'\n#SQL: SELECT CAST(SUM(T1.long_shots) AS REAL) / COUNT(T1.player_fifa_api_id) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id WHERE T2.player_name = 'Ahmed Samir Farag'\n```"
    ],
    "1489": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find out the total consumption by KAM customers in May 2013. This can be achieved by summing the consumption in the yearmonth table where the CustomerID is associated with KAM customers and the date is 201305.\n#columns: yearmonth.Consumption, yearmonth.CustomerID\n#values: KAM customers refer to customers.Segment = 'KAM', May 2013 refer to yearmonth.Date = '201305'\n#SELECT: How much did the KAM customers consume in total refers to SUM(yearmonth.Consumption)\n#SQL-like: Show SUM(yearmonth.Consumption), WHERE yearmonth.CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'KAM') AND yearmonth.Date = '201305'\n#SQL: SELECT SUM(yearmonth.Consumption) FROM yearmonth WHERE CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'KAM') AND Date = '201305'\n```"
    ],
    "438": [
        "```\n#reason: The question wants to display the language of a specific set identified by its id. Here, \"the language\" refers to the set_translations.language, and \"set id '174'\" is the filtering condition that corresponds to sets.id = 174.\n#columns: set_translations.language, sets.id\n#values: set id \"174\" refers to sets.id = 174\n#SELECT: SELECT language refer to set_translations.language\n#SQL-like: Show set_translations.language WHERE sets.id = 174\n#SQL: SELECT T1.language FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.id = 174\n```"
    ],
    "269": [
        "```\n#reason: The question wants to count the number of bond IDs that have the element iodine, so the SQL SELECT will count the bond IDs where the element is 'i'.\n#columns: bond.bond_id, atom.element\n#values: iodine refers to atom.element = 'i'\n#SELECT: How many bond id refer to COUNT(bond.bond_id)\n#SQL-like: Show COUNT(bond.bond_id), WHERE atom.element = 'i'\n#SQL: SELECT COUNT(bond.bond_id) FROM bond INNER JOIN atom ON bond.molecule_id = atom.molecule_id WHERE atom.element = 'i'\n```"
    ],
    "334": [
        "```\n#reason: The question wants to identify the element associated with a specific atom ID, while ensuring the molecule is non-carcinogenic. This requires filtering based on the atom ID and the label indicating non-carcinogenic molecules.\n#columns: atom.element, atom.atom_id, molecule.label\n#values: atom ID is 'TR004_7' refers to atom.atom_id = 'TR004_7', and non-carcinogenic refers to molecule.label = '-'\n#SELECT: SELECT the element refer to atom.element\n#SQL-like: Show atom.element WHERE atom.atom_id = 'TR004_7' AND molecule.label = '-'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR004_7' AND T2.label = '-'\n```"
    ],
    "1268": [
        "```\n#reason: The question wants to list the IDs of the three youngest patients with an abnormal anti-SM result, so the SQL SELECT will retrieve Patient.ID and filter for abnormal cases of Laboratory.SM, sorting by the patient's birthday in descending order with a limit of 3.\n#columns: Patient.ID, Patient.Birthday, Laboratory.SM\n#values: abnormal anti-SM refers to Laboratory.SM NOT IN ('negative', '0')\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID WHERE Laboratory.SM NOT IN ('negative', '0') ORDER BY Patient.Birthday DESC LIMIT 3\n#SQL: SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SM NOT IN ('negative', '0') ORDER BY T1.Birthday DESC LIMIT 3\n```"
    ],
    "335": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the total number of molecules with double bonded oxygen, so the SQL SELECT will count distinct molecule_ids where the element is 'o' and the bond_type is '='.\n#columns: molecule.molecule_id\n#values: 'oxygen' refers to 'atom.element = 'o'', 'double bond' refers to 'bond.bond_type = '=''\n#SELECT: total number of molecules refers to COUNT(DISTINCT molecule.molecule_id)\n#SQL-like: Show COUNT(DISTINCT molecule.molecule_id), WHERE atom.element = 'o' AND bond.bond_type = '='\n#SQL: SELECT COUNT(DISTINCT molecule.molecule_id) FROM atom INNER JOIN bond ON atom.molecule_id = bond.molecule_id WHERE atom.element = 'o' AND bond.bond_type = '='\n```"
    ],
    "195": [
        "```\n#reason: The question requires determining the \"most common bond type,\" which is interpreted as the bond type with the highest count. This requires calculating the count of each bond type and selecting the maximum count.\n#columns: bond.bond_type\n#values: None (no specific filtering conditions are given)\n#SELECT: most common bond type refers to bond.bond_type\n#SQL-like: Show MAX(COUNT(bond.bond_type)), GROUP BY bond.bond_type, ORDER BY COUNT(bond.bond_type) DESC LIMIT 1\n#SQL: SELECT bond_type FROM bond GROUP BY bond_type ORDER BY COUNT(bond_type) DESC LIMIT 1\n```"
    ],
    "89": [
        "```\n#reason: The question wants to count the number of accounts that choose 'issuance after transaction' and are located in the 'East Bohemia' region, so the SQL SELECT will count the accounts based on the specified conditions.\n#columns: account.account_id, district.A3\n#values: 'East Bohemia' refers to district.A3 = 'east Bohemia', 'issuance after transaction' refers to account.frequency = 'POPLATEK PO OBRATU'\n#SELECT: SELECT COUNT(account.account_id)\n#SQL-like: Show COUNT(account.account_id) WHERE account.frequency = 'POPLATEK PO OBRATU' AND district.A3 = 'east Bohemia'\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.frequency = 'POPLATEK PO OBRATU' AND T2.A3 = 'east Bohemia'\n```"
    ],
    "1236": [
        "```\n#reason: The question wants to identify female patients aged 50 and above with abnormal red blood cell counts and their admission status, so the SQL SELECT will include the admission status and filter based on gender, age, and red blood cell count.\n#columns: Patient.SEX, Patient.Birthday, Patient.Admission, Laboratory.RBC\n#values: female patient refers to Patient.SEX = 'F', age 50 and above refers to SUBTRACT(year(current_timestamp), year(Patient.Birthday)) >= 50, abnormal red blood cell count refers to Laboratory.RBC <= 3.5 OR Laboratory.RBC >= 6.0\n#SELECT: SELECT Patient.Admission refer to Patient.Admission\n#SQL-like: Show Patient.Admission WHERE Patient.SEX = 'F' AND SUBTRACT(year(current_timestamp), year(Patient.Birthday)) >= 50 AND (Laboratory.RBC <= 3.5 OR Laboratory.RBC >= 6.0)\n#SQL: SELECT T1.Admission FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND (strftime('%Y', 'now') - strftime('%Y', T1.Birthday)) >= 50 AND (T2.RBC <= 3.5 OR T2.RBC >= 6.0)\n```"
    ],
    "69": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the National Center for Educational Statistics school district identification number for all schools that have a School Ownership Code indicating they are part of the State Special Schools, so the SQL SELECT will focus on the NCESDist column from the schools table where the SOC column equals 31.\n#columns: schools.NCESDist\n#values: SOC = 31 refer to schools.SOC = '31'\n#SELECT: SELECT National Center for Educational Statistics school district identification number refer to schools.NCESDist\n#SQL-like: Show schools.NCESDist WHERE schools.SOC = '31'\n#SQL: SELECT NCESDist FROM schools WHERE SOC = '31'\n```"
    ],
    "1076": [
        "```\n#reason: The question asks for the difference in the average ball control score between two players, Abdou Diallo and Aaron Appindangoye. This will involve calculating the average ball control scores for both players and then subtracting the two. The SQL will use conditional aggregation to filter the ball control scores based on player names.\n#columns: Player_Attributes.ball_control, Player.player_name\n#values: 'Abdou Diallo' refers to Player.player_name = 'Abdou Diallo', 'Aaron Appindangoye' refers to Player.player_name = 'Aaron Appindangoye'\n#SELECT: difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'), AVG(ball_control WHERE player_name = 'Aaron Appindangoye'))\n#SQL-like: Show SUBTRACT(AVG(Player_Attributes.ball_control WHERE Player.player_name = 'Abdou Diallo'), AVG(Player_Attributes.ball_control WHERE Player.player_name = 'Aaron Appindangoye'))\n#SQL: SELECT (CAST(SUM(CASE WHEN T2.player_name = 'Abdou Diallo' THEN T1.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN T2.player_name = 'Abdou Diallo' THEN T2.id ELSE NULL END)) - (CAST(SUM(CASE WHEN T2.player_name = 'Aaron Appindangoye' THEN T1.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN T2.player_name = 'Aaron Appindangoye' THEN T2.id ELSE NULL END)) AS difference FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id\n```"
    ],
    "339": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the atom ID of the carcinogenic molecule that contains oxygen, so the SQL SELECT will use the relevant columns from the atom and molecule tables and apply the necessary filters.\n#columns: atom.atom_id, molecule.label, atom.element\n#values: carcinogenic refer to molecule.label = '+', contains oxygen refer to atom.element = 'o'\n#SELECT: SELECT atom.atom_id refer to atom.atom_id\n#SQL-like: Show atom.atom_id, WHERE molecule.label = '+' AND atom.element = 'o'\n#SQL: SELECT T1.atom_id FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND T1.element = 'o'\n```"
    ],
    "773": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the superhero who has the same eyes, hair, and skin colour, indicating the publisher of the superhero. This is defined by the conditions hair_colour_id = skin_colour_id AND hair_colour_id = eye_colour_id. \n#columns: superhero.superhero_name, publisher.publisher_name\n#values: the same eyes, hair and skin colour refer to superhero.hair_colour_id = superhero.skin_colour_id AND superhero.hair_colour_id = superhero.eye_colour_id\n#SELECT: superhero name refers to superhero.superhero_name, publisher refers to publisher.publisher_name\n#SQL-like: Show superhero.superhero_name, publisher.publisher_name WHERE superhero.hair_colour_id = superhero.skin_colour_id AND superhero.hair_colour_id = superhero.eye_colour_id\n#SQL: SELECT superhero.superhero_name, publisher.publisher_name FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.hair_colour_id = superhero.skin_colour_id AND superhero.hair_colour_id = superhero.eye_colour_id\n```"
    ],
    "421": [
        "```\n#reason: The question wants to display the top three unknown power cards that have promotional types for arena league in alphabetical order, so the SQL SELECT will fetch the names of the cards filtered by power and promoTypes, and limit the results to top three in alphabetical order.\n#columns: cards.name\n#values: unknown power cards refer to cards.power IS NULL OR cards.power = '*', promotional types for arena league refers to cards.promoTypes = 'arenaleague'\n#SELECT: SELECT cards.name\n#SQL-like: Show cards.name WHERE cards.power IS NULL OR cards.power = '*' AND cards.promoTypes = 'arenaleague' ORDER BY cards.name LIMIT 3\n#SQL: SELECT cards.name FROM cards WHERE cards.power IS NULL OR cards.power = '*' AND cards.promoTypes = 'arenaleague' ORDER BY cards.name LIMIT 3\n```"
    ],
    "386": [
        "```\n#reason: The question wants to count the number of cards with a future frame version and display their legality status, so the SQL SELECT COUNT(cards.id) and legalities.status will be used.\n#columns: cards.id, legalities.status\n#values: future frame version refers to cards.frameVersion = 'future', legality status refers to legalities.status = 'Legal'\n#SELECT: SELECT COUNT(cards.id), legalities.status refer to cards.id, legalities.status\n#SQL-like: Show COUNT(cards.id), legalities.status, WHERE cards.frameVersion = 'future' AND legalities.status = 'Legal'\n#SQL: SELECT COUNT(T1.id), T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future' AND T2.status = 'Legal'\n```"
    ],
    "1351": [
        "```\n#reason: The question wants to display \"Brent Thomason's major\". The filtering condition is \"Brent Thomason\" which refers to the first and last name. \n#columns: major.major_name, member.first_name, member.last_name\n#values: 'Brent Thomason' refers to member.first_name = 'Brent' AND member.last_name = 'Thomason'\n#SELECT: Brent Thomason's major refers to major.major_name\n#SQL-like: Show major.major_name, WHERE member.first_name = 'Brent' AND member.last_name = 'Thomason'\n#SQL: SELECT T3.major_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T1.first_name = 'Brent' AND T1.last_name = 'Thomason'\n```"
    ],
    "1322": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the number of meetings attended by more than 10 members. Therefore, the SQL SELECT will count the number of events of type 'Meeting' that have a count of members greater than 10.\n#columns: attendance.link_to_event, attendance.link_to_member, event.event_id, event.type\n#values: attended by more than 10 members refers to COUNT(attendance.link_to_member) > 10, type = 'Meeting' refers to event.type = 'Meeting'\n#SELECT: SELECT COUNT(event.event_id) refer to event.event_id\n#SQL-like: Show COUNT(event.event_id), WHERE event.type = 'Meeting', GROUP BY event.event_id HAVING COUNT(attendance.link_to_member) > 10\n#SQL: SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE T1.type = 'Meeting' GROUP BY T1.event_id HAVING COUNT(T2.link_to_member) > 10\n```"
    ],
    "1069": [
        "```\n#reason: The question wants to find the player with the shortest height, so the SQL SELECT will retrieve the player name and the minimum height.\n#columns: Player.player_name, Player.height\n#values: None (no specific filtering conditions are provided)\n#SELECT: SELECT Player.player_name, Player.height\n#SQL-like: Show Player.player_name, ORDER BY Player.height ASC LIMIT 1\n#SQL: SELECT player_name FROM Player ORDER BY height ASC LIMIT 1\n```"
    ],
    "516": [
        "```\n#reason: The question wants to count the number of cards illustrated by Volkan Baǵa where the foreign language is French, so the SQL SELECT COUNT(cards.id) and GROUP BY cards.id to ensure unique counts.\n#columns: cards.id, foreign_data.language\n#values: 'Volkan Baǵa' refers to cards.artist = 'Volkan Baǵa', 'French' refers to foreign_data.language = 'French'\n#SELECT: SELECT COUNT(cards.id) refer to cards.id\n#SQL-like: Show COUNT(cards.id), WHERE cards.artist = 'Volkan Baǵa' AND foreign_data.language = 'French'\n#SQL: SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Volkan Baǵa' AND T2.language = 'French'\n```"
    ],
    "548": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the location of the owner of a specific post by its title, so the SQL SELECT will pull the location from the users table based on the OwnerUserId found in the posts table.\n#columns: users.Location, posts.OwnerUserId, posts.Title\n#values: 'Eliciting priors from experts' refers to posts.Title = 'Eliciting priors from experts'\n#SELECT: SELECT users.Location refer to users.Location\n#SQL-like: Show users.Location WHERE posts.Title = 'Eliciting priors from experts'\n#SQL: SELECT users.Location FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE posts.Title = 'Eliciting priors from experts'\n```"
    ],
    "1510": [
        "```\n#reason: The question wants to calculate the average total price of transactions that took place in gas stations located in the Czech Republic, so the SQL SELECT will compute the average of the total price calculated from the transactions.\n#columns: transactions_1k.Price\n#values: 'gas stations in the Czech Republic' refer to gasstations.Country = 'CZE'\n#SELECT: SELECT AVG(transactions_1k.Price) refer to transactions_1k.Price\n#SQL-like: Show AVG(transactions_1k.Price), WHERE gasstations.Country = 'CZE'\n#SQL: SELECT AVG(T1.Price) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE'\n```"
    ],
    "888": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the country, circuit name, and location of the first European Grand Prix, so the SQL SELECT will retrieve these details based on the minimum year of the race.\n#columns: circuits.country, circuits.name, circuits.location, races.year\n#values: the first refers to MIN(year) in races\n#SELECT: SELECT circuits.country, circuits.name, circuits.location\n#SQL-like: Show circuits.country, circuits.name, circuits.location WHERE races.year = (SELECT MIN(year) FROM races WHERE races.name = 'European Grand Prix')\n#SQL: SELECT T1.country, T2.name, T2.location FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = (SELECT MIN(year) FROM races WHERE name = 'European Grand Prix')\n```"
    ],
    "1404": [
        "```\n#reason: The question wants to identify the type of expenses and their total value approved for the 'October Meeting' event, so the SQL SELECT will sum the cost of expenses grouped by expense description where the event name matches 'October Meeting'.\n#columns: expense.expense_description, expense.cost\n#values: 'October Meeting' refer to event.event_name = 'October Meeting'\n#SELECT: SELECT expense.expense_description, SUM(expense.cost) refer to expense.expense_description, SUM(expense.cost)\n#SQL-like: Show expense.expense_description, SUM(expense.cost), WHERE event.event_name = 'October Meeting'\n#SQL: SELECT expense.expense_description, SUM(expense.cost) FROM expense INNER JOIN budget ON expense.link_to_budget = budget.budget_id INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.event_name = 'October Meeting' GROUP BY expense.expense_description\n```"
    ],
    "902": [
        "```\n#reason: The question wants to identify the race associated with the driver Alex Yoong when his position on the track was less than 20, so the SQL SELECT will include the race name and check the driver's full name and their position.\n#columns: races.name, drivers.forename, drivers.surname, results.position\n#values: 'Alex Yoong' refer to 'drivers.forename || \" \" || drivers.surname', 'track number less than 20' refer to results.position < 20\n#SELECT: SELECT races.name refer to races.name\n#SQL-like: Show races.name, WHERE drivers.forename || \" \" || drivers.surname = 'Alex Yoong' AND results.position < 20\n#SQL: SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename || \" \" || T3.surname = 'Alex Yoong' AND T2.position < 20\n```"
    ],
    "1416": [
        "```\n#reason: The question wants to display the count of members with a Medium size of tee shirt, so the SQL SELECT will count the members filtered by their major and t-shirt size.\n#columns: member.member_id, member.t_shirt_size, major.major_name\n#values: 'members of Business' refer to major.major_name = 'Business', 't_shirt_size = Medium' refer to member.t_shirt_size = 'Medium'\n#SELECT: COUNT(member.member_id) refer to member.member_id\n#SQL-like: Show COUNT(member.member_id) WHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium'\n#SQL: SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'\n```"
    ],
    "1218": [
        "```\n#reason: The question wants to compute the percentage of female patients whose uric acid (UA) is beyond the normal range. Normal range for females is defined as UA > 6.5 and for males as UA > 8.0. Hence, I need to count female patients whose UA is greater than 6.5, and compute this as a percentage of all female patients. The SQL SELECT will count this and calculate the percentage using CAST for accurate division.\n#columns: Patient.SEX, Laboratory.UA\n#values: female patients with UA beyond normal range refer to Laboratory.UA > 6.5 AND Patient.SEX = 'F'; all female patients refer to Patient.SEX = 'F'\n#SELECT: SELECT (COUNT(Laboratory.UA) * 100.0 / (SELECT COUNT(*) FROM Patient WHERE Patient.SEX = 'F')) AS percentage_female_patients_with_high_UA refer to (COUNT(Laboratory.UA) / (SELECT COUNT(*) FROM Patient WHERE Patient.SEX = 'F')) * 100\n#SQL-like: Show (COUNT(Laboratory.UA) * 100.0 / (SELECT COUNT(*) FROM Patient WHERE Patient.SEX = 'F')), WHERE Laboratory.UA > 6.5 AND Patient.SEX = 'F'\n#SQL: SELECT (COUNT(Laboratory.UA) * 100.0 / (SELECT COUNT(*) FROM Patient WHERE Patient.SEX = 'F')) AS percentage_female_patients_with_high_UA FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Laboratory.UA > 6.5 AND Patient.SEX = 'F'\n```"
    ],
    "614": [
        "```\n#reason: The question wants to calculate the percentage of users who obtained the \"Teacher\" badge, so the SQL SELECT will count the users with the \"Teacher\" badge and divide it by the total count of users, then multiply by 100.\n#columns: badges.Name, badges.UserId, users.Id\n#values: 'Teacher' refer to badges.Name = 'Teacher'\n#SELECT: SELECT CAST(COUNT(T1.UserId) AS REAL) * 100 / COUNT(T2.Id) refer to badges.UserId and users.Id\n#SQL-like: Show percentage (CAST(COUNT(UserId where badges.Name = 'Teacher') AS REAL) * 100 / COUNT(UserId))\n#SQL: SELECT CAST(COUNT(T1.UserId) AS REAL) * 100 / COUNT(T2.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Teacher'\n```"
    ],
    "458": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of artists who have designed cards with a black border color and are available in both \"arena\" and \"mtgo\" printing types, so the SQL SELECT will count distinct artists where the border color is black and availability includes both types.\n#columns: DISTINCT cards.artist\n#values: black border color refers to cards.borderColor = 'black', available in both \"arena\" and \"mtgo\" refers to cards.availability LIKE '%arena,mtgo%'\n#SELECT: SELECT COUNT(DISTINCT cards.artist)\n#SQL-like: Show COUNT(DISTINCT cards.artist), WHERE cards.borderColor = 'black' AND cards.availability LIKE '%arena,mtgo%'\n#SQL: SELECT COUNT(DISTINCT cards.artist) FROM cards WHERE cards.borderColor = 'black' AND cards.availability LIKE '%arena,mtgo%'\n```"
    ],
    "1214": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the ID, sex, and date of birth of patients whose total protein (TP) is below the lower range of the normal index, so the SQL SELECT will include these columns and filter based on the TP value.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday\n#values: total protein (TP) below the lower range of the normal index refers to Laboratory.TP < 6.0\n#SELECT: SELECT Patient.ID, Patient.SEX, Patient.Birthday refer to Patient.ID, Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Birthday WHERE Laboratory.TP < 6.0\n#SQL: SELECT P.ID, P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.TP < 6.0\n```"
    ],
    "1304": [
        "```\n#reason: The question wants to find out how many patients have a normal blood glucose level and do not have thrombosis, so the SQL SELECT will count the patients meeting these conditions.\n#columns: Laboratory.GLU, Examination.Thrombosis\n#values: normal blood glucose refers to Laboratory.GLU < 180 and don't have thrombosis refers to Examination.Thrombosis = 0\n#SELECT: How many patients refer to COUNT(*)\n#SQL-like: Show COUNT(*) WHERE Laboratory.GLU < 180 AND Examination.Thrombosis = 0\n#SQL: SELECT COUNT(*) FROM Laboratory INNER JOIN Examination ON Laboratory.ID = Examination.ID WHERE Laboratory.GLU < 180 AND Examination.Thrombosis = 0\n```"
    ],
    "25": [
        "```\n#reason: The question wants to find schools in Riverside with an average math score greater than 400 and their funding type, so the SQL SELECT will calculate the average of average math scores and filter by the county and funding type.\n#columns: satscores.AvgScrMath, schools.FundingType\n#values: 'in Riverside' refer to schools.County = 'Riverside', 'average math score greater than 400' refer to (SUM(satscores.AvgScrMath) / COUNT(schools.School)) > 400\n#SELECT: SELECT SUM(satscores.AvgScrMath) / COUNT(schools.School) AS average_math_score, schools.FundingType\n#SQL-like: Show SUM(satscores.AvgScrMath) / COUNT(schools.School), schools.FundingType WHERE schools.County = 'Riverside' GROUP BY schools.FundingType HAVING average_math_score > 400\n#SQL: SELECT SUM(satscores.AvgScrMath) / COUNT(schools.School) AS average_math_score, schools.FundingType FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE schools.County = 'Riverside' GROUP BY schools.FundingType HAVING average_math_score > 400\n```"
    ],
    "1282": [
        "```\n#reason: The question wants to display the top three patients' birthdays with the highest glutamic pyruvic transaminase in the normal range, so the SQL SELECT will focus on the birthdays of patients whose GPT values are less than 60 and will order them by GPT in descending order.\n#columns: Patient.Birthday, Laboratory.GPT\n#values: highest glutamic pylvic transaminase in the normal range refers to Laboratory.GPT < 60\n#SELECT: SELECT the top three patients' birthdays refer to Patient.Birthday\n#SQL-like: Show Patient.Birthday, WHERE Laboratory.GPT < 60, ORDER BY Laboratory.GPT DESC LIMIT 3\n#SQL: SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT < 60 ORDER BY T2.GPT DESC LIMIT 3\n```"
    ],
    "103": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"client id\" of the client who issued his/her card on \"1994/3/3\", so the SQL SELECT will retrieve the client_id where the card's issued date matches that date.\n#columns: client.client_id, card.issued\n#values: 'issued on 1994/3/3' refers to card.issued = '1994-03-03'\n#SELECT: 'client id' refers to client.client_id\n#SQL-like: Show client.client_id, WHERE card.issued = '1994-03-03'\n#SQL: SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.issued = '1994-03-03'\n```"
    ],
    "1358": [
        "```\n#reason: The question wants to display the full name of the member who first paid their dues, so the SQL SELECT will focus on the earliest received date where the source is 'Dues' to find the member's name.\n#columns: member.first_name, member.last_name, income.date_received\n#values: 'first paid dues' refers to MIN(income.date_received) where income.source = 'Dues'\n#SELECT: SELECT member.first_name, member.last_name refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, WHERE income.source = 'Dues' ORDER BY income.date_received ASC LIMIT 1\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.source = 'Dues' ORDER BY T2.date_received ASC LIMIT 1\n```"
    ],
    "790": [
        "```\n#reason: The question wants to calculate the difference between the weights of two superheroes, so the SQL SELECT will subtract the weight of 'Emil Blonsky' from the weight of 'Charles Chandler'.\n#columns: superhero.weight_kg, superhero.full_name\n#values: 'Emil Blonsky' refer to superhero.full_name = 'Emil Blonsky', 'Charles Chandler' refer to superhero.full_name = 'Charles Chandler'\n#SELECT: difference = SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler')) refer to superhero.weight_kg\n#SQL-like: Show SUBTRACT(SUM(weight_kg WHERE full_name = 'Emil Blonsky'), SUM(weight_kg WHERE full_name = 'Charles Chandler'))\n#SQL: SELECT SUM(CASE WHEN T.full_name = 'Emil Blonsky' THEN T.weight_kg ELSE 0 END) - SUM(CASE WHEN T.full_name = 'Charles Chandler' THEN T.weight_kg ELSE 0 END) FROM superhero AS T\n```"
    ],
    "514": [
        "```\n#reason: The question wants to identify the top 10 cards with the highest unconverted mana cost in the duel format, so the SQL SELECT will retrieve the cards filtered by the duel format and ordered by their mana cost in descending order with a limit of 10.\n#columns: cards.name, cards.manaCost\n#values: 'duels' refer to cards.promoTypes = 'duels'\n#SELECT: SELECT name, manaCost refer to cards.name, cards.manaCost\n#SQL-like: Show cards.name, cards.manaCost, WHERE cards.promoTypes = 'duels' ORDER BY cards.manaCost DESC LIMIT 10\n#SQL: SELECT name, manaCost FROM cards WHERE promoTypes = 'duels' ORDER BY manaCost DESC LIMIT 10\n```"
    ],
    "884": [
        "```\n#reason: The question wants to list the names of all races that occurred in the earliest recorded year and month, so the SQL SELECT will filter the races based on the minimum date to get the corresponding year and month.\n#columns: races.name\n#values: earliest recorded year and month refer to year = (SELECT MIN(strftime('%Y', date)) FROM races) AND month = (SELECT MIN(strftime('%m', date)) FROM races)\n#SELECT: SELECT name refer to races.name\n#SQL-like: Show races.name WHERE year = (SELECT MIN(strftime('%Y', date)) FROM races) AND month = (SELECT MIN(strftime('%m', date)) FROM races)\n#SQL: SELECT name FROM races WHERE strftime('%Y', date) = (SELECT MIN(strftime('%Y', date)) FROM races) AND strftime('%m', date) = (SELECT MIN(strftime('%m', date)) FROM races)\n```"
    ],
    "1193": [
        "```\n#reason: The question wants to count the number of female patients who are not solely categorized under the 'P' ANA Pattern and were born between 1980 and 1989, so the SQL SELECT statement will count the Patient.ID based on those filters.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday, Examination.`ANA Pattern`\n#values: excluding all P only ANA Pattern refers to Examination.`ANA Pattern` != 'P', women refers to Patient.SEX = 'F', born between 1980 and 1989 refers to Patient.Birthday BETWEEN '1980-01-01' AND '1989-12-31'\n#SELECT: COUNT(Patient.ID) refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Examination.`ANA Pattern` != 'P' AND Patient.SEX = 'F' AND Patient.Birthday BETWEEN '1980-01-01' AND '1989-12-31'\n#SQL: SELECT COUNT(Patient.ID) FROM Patient INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Examination.`ANA Pattern` != 'P' AND Patient.SEX = 'F' AND Patient.Birthday BETWEEN '1980-01-01' AND '1989-12-31'\n```"
    ],
    "1334": [
        "```\n#reason: The question wants to display the \"full name of the Student_Club members\" who \"grew up in Illinois state\". The definition of \"full name\" is the combination of first_name and last_name, and \"Illinois state\" is the filtering condition.\n#columns: member.first_name, member.last_name, zip_code.state\n#values: Illinois state refers to zip_code.state = 'Illinois'\n#SELECT: SELECT member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name WHERE zip_code.state = 'Illinois'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Illinois'\n```"
    ],
    "477": [
        "```\n#reason: The question wants to identify which artists have designed a card in the set Coldsnap, so the SQL SELECT will filter by the set name and the artist names provided.\n#columns: cards.artist\n#values: 'set Coldsnap' refer to cards.name = 'Coldsnap', 'Jeremy Jarvis, Aaron Miller or Chippy' refer to cards.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')\n#SELECT: SELECT cards.artist\n#SQL-like: Show cards.artist WHERE cards.name = 'Coldsnap' AND cards.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')\n#SQL: SELECT cards.artist FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')\n```"
    ],
    "1203": [
        "```\n#reason: The question asks for the number of female patients with white blood cell counts below 3.5, so the SQL SELECT will count the patients filtered by gender and white blood cell count.\n#columns: Patient.SEX, Laboratory.WBC\n#values: female refers to SEX = 'F', white blood cells that were below 3.5 refers to WBC < 3.5\n#SELECT: How many patients who were female refers to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Patient.SEX = 'F' AND Laboratory.WBC < 3.5\n#SQL: SELECT COUNT(Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.SEX = 'F' AND Laboratory.WBC < 3.5\n```"
    ],
    "17": [
        "```\n#reason: The question wants to rank schools by their average score in Writing where the score is greater than 499, so the SQL SELECT will include the average score in Writing and the charter numbers for schools meeting the condition.\n#columns: satscores.AvgScrWrite, schools.CharterNum\n#values: average score in Writing greater than 499 refers to satscores.AvgScrWrite > 499, valid charter number means schools.CharterNum is not null\n#SELECT: SELECT satscores.AvgScrWrite, schools.CharterNum\n#SQL-like: Show DISTINCT satscores.AvgScrWrite, schools.CharterNum WHERE satscores.AvgScrWrite > 499 AND schools.CharterNum IS NOT NULL\n#SQL: SELECT satscores.AvgScrWrite, schools.CharterNum FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.AvgScrWrite > 499 AND schools.CharterNum IS NOT NULL ORDER BY satscores.AvgScrWrite DESC\n```"
    ],
    "1381": [
        "```\n#reason: The question wants to list the names of students who have attended more than 7 events, so the SQL SELECT will combine the first and last names of members and filter based on the count of events attended.\n#columns: member.first_name, member.last_name, attendance.link_to_event\n#values: attended more than 7 events refers to COUNT(attendance.link_to_event) > 7\n#SELECT: SELECT member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, WHERE COUNT(attendance.link_to_event) > 7 GROUP BY member.member_id\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id HAVING COUNT(T2.link_to_event) > 7\n```"
    ],
    "990": [
        "```\n#reason: The question wants to find the constructor reference name of the champion in the 2009 Singapore Grand Prix, so the SQL SELECT will retrieve the constructorRef and url of the constructor with the maximum finishing time in the specified race.\n#columns: constructors.constructorRef, constructors.url\n#values: '2009 Singapore Grand Prix' refers to races.name = 'Singapore Grand Prix' AND races.year = 2009\n#SELECT: constructor reference name refers to constructors.constructorRef, website refers to constructors.url\n#SQL-like: Show constructors.constructorRef, constructors.url WHERE races.name = 'Singapore Grand Prix' AND races.year = 2009 ORDER BY results.time LIMIT 1\n#SQL: SELECT T1.constructorRef, T1.url FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.name = 'Singapore Grand Prix' AND T3.year = 2009 ORDER BY T2.time LIMIT 1\n```"
    ],
    "23": [
        "```\n#reason: The question wants to list the names of schools and their full street addresses where the difference in enrollments between K-12 and ages 5-17 is more than 30. The SQL SELECT will include the school name and full street address, and the filtering condition will calculate the difference in enrollments.\n#columns: schools.School, schools.MailStreet\n#values: more than 30 difference in enrollments refers to (frpm.`Enrollment (K-12)` - frpm.`Enrollment (Ages 5-17)`) > 30\n#SELECT: SELECT schools.School, schools.MailStreet refer to schools.School, schools.MailStreet\n#SQL-like: Show schools.School, schools.MailStreet WHERE (frpm.`Enrollment (K-12)` - frpm.`Enrollment (Ages 5-17)`) > 30\n#SQL: SELECT schools.School, schools.MailStreet FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE (frpm.`Enrollment (K-12)` - frpm.`Enrollment (Ages 5-17)`) > 30\n```"
    ],
    "432": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the Russian set of cards that contains the most cards overall, so the SQL SELECT will focus on the set with the maximum base set size filtered by the Russian language.\n#columns: sets.id, sets.baseSetSize\n#values: Russian refers to set_translations.language = 'Russian'\n#SELECT: SELECT id refer to sets.id\n#SQL-like: Show id, where baseSetSize is MAX, and set_translations.language = 'Russian', ORDER BY baseSetSize DESC LIMIT 1\n#SQL: SELECT sets.id FROM sets INNER JOIN set_translations ON sets.code = set_translations.setCode WHERE set_translations.language = 'Russian' ORDER BY sets.baseSetSize DESC LIMIT 1\n```"
    ],
    "519": [
        "```\n#reason: The question wants to display the language of the \"Battlebond\" set, so the SQL SELECT will retrieve the language from the set_translations table where the set name is 'Battlebond'.\n#columns: set_translations.language, sets.name\n#values: 'Battlebond' refer to sets.name = 'Battlebond'\n#SELECT: SELECT set_translations.language refer to set_translations.language\n#SQL-like: Show set_translations.language, WHERE sets.name = 'Battlebond'\n#SQL: SELECT T1.language FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Battlebond'\n```"
    ],
    "1335": [
        "```\n#reason: The question wants to know how much the Student_Club members spent on advertisement for the September Meeting, so the SQL SELECT will count the total amount spent in the advertisement category for that event.\n#columns: budget.spent, budget.category, event.event_name\n#values: 'spend on advertisement' refer to budget.category = 'Advertisement', 'in September Meeting' refer to event.event_name = 'September Meeting'\n#SELECT: SELECT SUM(budget.spent) refer to SUM(budget.spent)\n#SQL-like: Show SUM(budget.spent), WHERE budget.category = 'Advertisement' AND event.event_name = 'September Meeting'\n#SQL: SELECT SUM(budget.spent) FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE budget.category = 'Advertisement' AND event.event_name = 'September Meeting'\n```"
    ],
    "336": [
        "```\n#reason: The question wants to count the number of non-carcinogenic molecules that contain triple bonds, so the SQL SELECT statement includes a count of molecule IDs filtered by bond type and carcinogenic label.\n#columns: bond.bond_id, molecule.label, molecule.molecule_id\n#values: triple bond refers to bond.bond_type = '#', non-carcinogenic refers to molecule.label = '-'\n#SELECT: SELECT COUNT(DISTINCT molecule.molecule_id) refer to COUNT(DISTINCT molecule.molecule_id)\n#SQL-like: Show COUNT(DISTINCT molecule.molecule_id), WHERE bond.bond_type = '#' AND molecule.label = '-'\n#SQL: SELECT COUNT(DISTINCT T2.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '#' AND T2.label = '-'\n```"
    ],
    "611": [
        "```\n#reason: The question wants to display the reputation of users who obtained a badge at a specific timestamp, so the SQL SELECT will include the user's reputation and filter by the badge date.\n#columns: users.Reputation, badges.Date\n#values: on 7/19/2010 7:39:08 PM refer to badges.Date = '2010-07-19 19:39:08.0'\n#SELECT: reputation of users refer to users.Reputation\n#SQL-like: Show users.Reputation, WHERE badges.Date = '2010-07-19 19:39:08.0'\n#SQL: SELECT T2.Reputation FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Date = '2010-07-19 19:39:08.0'\n```"
    ],
    "969": [
        "```\n#reason: The question wants to count the number of British drivers born in 1980, so the SQL SELECT COUNT(drivers.driverId) and WHERE strftime('%Y', drivers.dob) = '1980' AND drivers.nationality = 'British'.\n#columns: drivers.driverId, drivers.dob, drivers.nationality\n#values: born in 1980 refer to strftime('%Y', drivers.dob) = '1980', British nationality refer to drivers.nationality = 'British'\n#SELECT: SELECT COUNT(drivers.driverId) \n#SQL-like: Show COUNT(drivers.driverId), WHERE strftime('%Y', drivers.dob) = '1980' AND drivers.nationality = 'British'\n#SQL: SELECT COUNT(driverId) FROM drivers WHERE strftime('%Y', dob) = '1980' AND nationality = 'British'\n```"
    ],
    "1063": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"Aaron Doran's potential score\" which refers to the \"potential\" field in the Player_Attributes table. The filtering condition is based on the player's name \"Aaron Doran\".\n#columns: Player_Attributes.potential, Player.player_name\n#values: 'Aaron Doran's potential score' refers to Player.player_name = 'Aaron Doran'\n#SELECT: SELECT potential refer to Player_Attributes.potential\n#SQL-like: Show Player_Attributes.potential, WHERE Player.player_name = 'Aaron Doran'\n#SQL: SELECT T1.potential FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Aaron Doran'\n```"
    ],
    "173": [
        "```\n#reason: The question wants to find the frequency of account statement requests for account number 3 and the purpose of the total debiting of 3539, so the SQL SELECT will retrieve the count of requests and the k_symbol for the specified account and amount.\n#columns: order.account_id, order.k_symbol, COUNT(order.account_id)\n#values: account number 3 refers to order.account_id = 3, debiting 3539 refers to order.amount = 3539\n#SELECT: SELECT COUNT(order.account_id), order.k_symbol refer to COUNT(order.account_id), order.k_symbol\n#SQL-like: Show COUNT(order.account_id), order.k_symbol WHERE order.account_id = 3 OR order.amount = 3539\n#SQL: SELECT COUNT(order.account_id), k_symbol FROM order WHERE account_id = 3 OR amount = 3539 GROUP BY k_symbol\n```"
    ],
    "389": [
        "```\n#reason: The question wants to list down the name of cards with original types of Creature - Elf and the date of rulings for these cards, so the SQL SELECT will include the card name and the ruling date.\n#columns: cards.name, rulings.date\n#values: 'Creature - Elf' refers to cards.originalType = 'Creature - Elf'\n#SELECT: SELECT cards.name, rulings.date refer to cards.name, rulings.date\n#SQL-like: Show cards.name, rulings.date WHERE cards.originalType = 'Creature - Elf'\n#SQL: SELECT T1.name, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'\n```"
    ],
    "171": [
        "```\n#reason: The question wants to calculate the difference in the number of crimes committed between East and North Bohemia in 1996, so the SQL SELECT will sum the committed crimes in each region for that year and subtract them.\n#columns: district.A3, district.A16\n#values: 'East Bohemia' refers to district.A3 = 'east Bohemia', 'North Bohemia' refers to district.A3 = 'north Bohemia', 'in 1996' refers to district.A16\n#SELECT: SELECT (SUM(CASE WHEN district.A3 = 'north Bohemia' THEN district.A16 ELSE 0 END) - SUM(CASE WHEN district.A3 = 'east Bohemia' THEN district.A16 ELSE 0 END)) \n#SQL-like: Show the difference in total committed crimes where district.A3 IN ('east Bohemia', 'north Bohemia') AND district.A16 IS NOT NULL\n#SQL: SELECT (SUM(CASE WHEN T1.A3 = 'north Bohemia' THEN T1.A16 ELSE 0 END) - SUM(CASE WHEN T1.A3 = 'east Bohemia' THEN T1.A16 ELSE 0 END)) FROM district AS T1 WHERE T1.A3 IN ('east Bohemia', 'north Bohemia')\n```"
    ],
    "802": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the tallest superhero, which means we need to find the maximum height and display the corresponding superhero name.\n#columns: superhero.superhero_name, superhero.height_cm\n#values: tallest superhero refers to ORDER BY superhero.height_cm DESC LIMIT 1\n#SELECT: superhero_name refers to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name ORDER BY superhero.height_cm DESC LIMIT 1\n#SQL: SELECT superhero.superhero_name FROM superhero ORDER BY superhero.height_cm DESC LIMIT 1\n```"
    ],
    "588": [
        "```\n#reason: The question wants to display the total number of comments posted by user ID 13, so the SQL SELECT will count the comments where the user ID is 13.\n#columns: comments.Id\n#values: user ID 13 refers to comments.UserId = 13\n#SELECT: total number of comments refer to COUNT(comments.Id)\n#SQL-like: Show COUNT(comments.Id), WHERE comments.UserId = 13\n#SQL: SELECT COUNT(Id) FROM comments WHERE UserId = 13\n```"
    ],
    "1222": [
        "```\n#reason: The question wants to count the number of male patients with a creatinine index out of the normal range, so the SQL SELECT will count the patients where Sex is 'M' and CRE is greater than or equal to 1.5.\n#columns: Patient.SEX, Laboratory.CRE\n#values: male refers to Patient.SEX = 'M', creatinine index out of the normal range refers to Laboratory.CRE >= 1.5\n#SELECT: How many male patients refer to COUNT(Patient.SEX) and creatinine index out of the normal range refer to Laboratory.CRE.\n#SQL-like: Show COUNT(Patient.SEX), WHERE Patient.SEX = 'M' AND Laboratory.CRE >= 1.5\n#SQL: SELECT COUNT(T1.SEX) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.CRE >= 1.5\n```"
    ],
    "1074": [
        "```\n#reason: The question wants to list all the short names of the football teams that had a home team goal of 10, so the SQL SELECT will retrieve the team_short_name from the Team table where the home_team_goal in the Match table is equal to 10.\n#columns: Team.team_short_name, Match.home_team_goal\n#values: home team goal of 10 refers to Match.home_team_goal = 10\n#SELECT: SELECT team_short_name refer to Team.team_short_name\n#SQL-like: Show DISTINCT Team.team_short_name, WHERE Match.home_team_goal = 10\n#SQL: SELECT DISTINCT T1.team_short_name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_api_id = T2.home_team_api_id WHERE T2.home_team_goal = 10\n```"
    ],
    "1227": [
        "```\n#reason: The question wants to calculate the average age of male patients with high cholesterol, so the SQL SELECT will sum the ages of male patients and divide by the count of those patients.\n#columns: Patient.SEX, Patient.Birthday, Laboratory.`T-CHO`, Patient.ID\n#values: male patient refers to Patient.SEX = 'M', high cholesterol refers to Laboratory.`T-CHO` >= 250\n#SELECT: average age refer to DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(Patient.Birthday))), COUNT(Patient.ID))\n#SQL-like: Show DIVIDE(SUM(SUBTRACT(YEAR(NOW()), YEAR(Patient.Birthday))), COUNT(Patient.ID)), WHERE Patient.SEX = 'M' AND Laboratory.`T-CHO` >= 250\n#SQL: SELECT CAST(SUM(STRFTIME('%Y', DATE('now')) - STRFTIME('%Y', Patient.Birthday)) AS REAL) / COUNT(Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.SEX = 'M' AND Laboratory.`T-CHO` >= 250\n```"
    ],
    "259": [
        "```\n#reason: The question wants to count the number of elements for single bond molecules, so the SQL SELECT will count the distinct atoms associated with bonds of type single bond.\n#columns: atom.atom_id, bond.bond_type\n#values: single bond refers to bond.bond_type = '-'\n#SELECT: How many elements refer to COUNT(DISTINCT atom.atom_id)\n#SQL-like: Show COUNT(DISTINCT atom.atom_id), WHERE bond.bond_type = '-'\n#SQL: SELECT COUNT(DISTINCT T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-'\n```"
    ],
    "287": [
        "```\n#reason: The question wants to identify the percentage of chemical compounds that form a double bond among all bonds related to molecule TR047, so the SQL SELECT will calculate the count of double bonds divided by the total count of bonds for that molecule.\n#columns: bond.bond_type, bond.bond_id, bond.molecule_id\n#values: double bond refers to bond_type = '='; molecule TR047 refers to bond.molecule_id = 'TR047'\n#SELECT: percent of double bonds refer to DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent\n#SQL-like: Show DIVIDE(SUM(bond_type = '='), COUNT(bond_id)), WHERE bond.molecule_id = 'TR047'\n#SQL: SELECT CAST(SUM(CASE WHEN bond.bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(bond.bond_id) FROM bond WHERE bond.molecule_id = 'TR047'\n```"
    ],
    "1428": [
        "```\n#reason: The question wants to list the city and state of members enrolled under the Electrical and Computer Engineering Department, so the SQL SELECT will retrieve the city and state for members whose position is 'Member' and are linked to the specified department.\n#columns: zip_code.city, zip_code.state\n#values: 'Electrical and Computer Engineering Department' refers to major.department = 'Electrical and Computer Engineering Department' and 'members enrolled' refers to member.position = 'Member'.\n#SELECT: SELECT zip_code.city, zip_code.state\n#SQL-like: Show zip_code.city, zip_code.state WHERE major.department = 'Electrical and Computer Engineering Department' AND member.position = 'Member'\n#SQL: SELECT T1.city, T2.state FROM zip_code AS T2 INNER JOIN member AS T1 ON T1.zip = T2.zip_code INNER JOIN major AS T3 ON T1.link_to_major = T3.major_id WHERE T3.department = 'Electrical and Computer Engineering Department' AND T1.position = 'Member'\n```"
    ],
    "853": [
        "```\n#reason: The question wants to fetch the names of the races held on the circuits in Spain, so the SQL SELECT will focus on retrieving race names and filtering by the country.\n#columns: races.name, circuits.country\n#values: Spain refers to circuits.country = 'Spain'\n#SELECT: SELECT races.name refer to races.name\n#SQL-like: SHOW races.name WHERE circuits.country = 'Spain'\n#SQL: SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Spain'\n```"
    ],
    "436": [
        "```\n#reason: The question wants to count the number of cards and list their ids where the frame effect is 'extendedart', so the SQL SELECT COUNT(id) and id FROM cards WHERE frameEffects = 'extendedart' and id is used.\n#columns: cards.id\n#values: frame effect as extendedart refers to frameEffects = 'extendedart'\n#SELECT: How many cards refer to COUNT(id), the id of those cards refer to id\n#SQL-like: Show COUNT(id), id WHERE frameEffects = 'extendedart'\n#SQL: SELECT COUNT(id), id FROM cards WHERE frameEffects = 'extendedart'\n```"
    ],
    "54": [
        "```\n#reason: The question wants to specify all of the schools and their related mailing zip codes that are under Avetik Atoian's administration, so the SQL SELECT will retrieve the school names and their corresponding zip codes where the administrator's first and last names match.\n#columns: schools.School, schools.MailZip\n#values: 'under Avetik Atoian's administration' refer to schools.AdmFName1 = 'Avetik' AND schools.AdmLName1 = 'Atoian'\n#SELECT: SELECT schools.School, schools.MailZip refer to schools.School, schools.MailZip\n#SQL-like: Show schools.School, schools.MailZip WHERE schools.AdmFName1 = 'Avetik' AND schools.AdmLName1 = 'Atoian'\n#SQL: SELECT schools.School, schools.MailZip FROM schools WHERE schools.AdmFName1 = 'Avetik' AND schools.AdmLName1 = 'Atoian'\n```"
    ],
    "1141": [
        "```\n#reason: The question wants to determine the speed class of the KSV Cercle Brugge team, so the SQL SELECT will retrieve the buildUpPlaySpeedClass for the specified team_long_name.\n#columns: Team.team_long_name, Team_Attributes.buildUpPlaySpeedClass\n#values: KSV Cercle Brugge refers to Team.team_long_name = 'KSV Cercle Brugge'\n#SELECT: SELECT buildUpPlaySpeedClass refer to Team_Attributes.buildUpPlaySpeedClass\n#SQL-like: Show Team_Attributes.buildUpPlaySpeedClass WHERE Team.team_long_name = 'KSV Cercle Brugge'\n#SQL: SELECT T2.buildUpPlaySpeedClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'KSV Cercle Brugge'\n```"
    ],
    "11": [
        "```\n#reason: The question wants to list the codes of the schools with a total enrollment of over 500, so the SQL SELECT will sum the `Enrollment (K-12)` and `Enrollment (Ages 5-17)` and filter where this sum is greater than 500.\n#columns: frpm.CDSCode\n#values: total enrollment of over 500 refers to (frpm.`Enrollment (K-12)` + frpm.`Enrollment (Ages 5-17)`) > 500\n#SELECT: SELECT frpm.CDSCode refer to frpm.CDSCode\n#SQL-like: Show frpm.CDSCode, WHERE (frpm.`Enrollment (K-12)` + frpm.`Enrollment (Ages 5-17)`) > 500\n#SQL: SELECT frpm.CDSCode FROM frpm WHERE (frpm.`Enrollment (K-12)` + frpm.`Enrollment (Ages 5-17)`) > 500\n```"
    ],
    "12": [
        "```\n#reason: The question wants to find the highest eligible free rate for students aged 5-17 among schools with an SAT excellence rate of over 0.3, so the SQL SELECT will focus on the MAX eligible free rate derived from the division of `Free Meal Count (Ages 5-17)` by `Enrollment (Ages 5-17)` while filtering for schools with an SAT excellence rate calculated as `NumGE1500 / NumTstTakr > 0.3`.\n#columns: satscores.NumGE1500, satscores.NumTstTakr, frpm.`Free Meal Count (Ages 5-17)`, frpm.`Enrollment (Ages 5-17)`\n#values: SAT excellence rate > 0.3 refers to satscores.NumGE1500 / satscores.NumTstTakr > 0.3\n#SELECT: the highest eligible free rate refer to MAX(frpm.`Free Meal Count (Ages 5-17)` / frpm.`Enrollment (Ages 5-17)`)\n#SQL-like: Show MAX(frpm.`Free Meal Count (Ages 5-17)` / frpm.`Enrollment (Ages 5-17)`), WHERE satscores.NumGE1500 / satscores.NumTstTakr > 0.3\n#SQL: SELECT MAX(frpm.`Free Meal Count (Ages 5-17)` / frpm.`Enrollment (Ages 5-17)`) FROM frpm INNER JOIN satscores ON frpm.CDSCode = satscores.cds WHERE satscores.NumGE1500 / satscores.NumTstTakr > 0.3\n```"
    ],
    "699": [
        "```\n#reason: The question wants to know when the user known as 'IrishStat' created his or her account, so the SQL SELECT will retrieve the CreationDate for the user with the specified DisplayName.\n#columns: users.CreationDate\n#values: DisplayName = 'IrishStat' refers to users.DisplayName = 'IrishStat'\n#SELECT: CreationDate refer to users.CreationDate\n#SQL-like: Show users.CreationDate WHERE users.DisplayName = 'IrishStat'\n#SQL: SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat'\n```"
    ],
    "1462": [
        "```\n#reason: The question wants to identify the budget category and the amount budgeted for the 'January Speaker' event, so the SQL SELECT will retrieve the category and amount from the budget table where the event name matches 'January Speaker'.\n#columns: budget.category, budget.amount\n#values: 'January Speaker' refers to event.event_name = 'January Speaker'\n#SELECT: SELECT category, amount refer to budget.category, budget.amount\n#SQL-like: Show budget.category, budget.amount WHERE event.event_name = 'January Speaker'\n#SQL: SELECT T1.category, T2.amount FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'January Speaker'\n```"
    ],
    "307": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the elements of the atoms that form a specific bond, so the SQL SELECT will fetch the elements from the atom table by joining with the connected table to filter by bond ID.\n#columns: atom.element\n#values: bond ID 'TR000_2_3' refers to connected.bond_id = 'TR000_2_3'\n#SELECT: atoms' elements refer to atom.element\n#SQL-like: Show atom.element WHERE connected.bond_id = 'TR000_2_3'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR000_2_3'\n```"
    ],
    "1414": [
        "```\n#reason: The question wants to display \"the name of major\" that Phillip Cullen has joined, so the SQL SELECT will filter based on the member's full name and join the major table to get the corresponding major name.\n#columns: major.major_name, member.member_id, member.first_name, member.last_name\n#values: 'Phillip Cullen' refer to member.first_name = 'Phillip' AND member.last_name = 'Cullen'\n#SELECT: SELECT major.major_name\n#SQL-like: Show major.major_name, WHERE member.first_name = 'Phillip' AND member.last_name = 'Cullen'\n#SQL: SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Phillip' AND T2.last_name = 'Cullen'\n```"
    ],
    "1529": [
        "```\n#reason: The question wants to display the amount spent by customer \"38508\" at the gas stations and also filter the results to show how much had the customer spent in January 2012. This requires a SUM of the Amount column for customer 38508 filtered by the Date in January 2012.\n#columns: transactions_1k.Amount, yearmonth.Date, transactions_1k.CustomerID\n#values: customer \"38508\" refers to transactions_1k.CustomerID = 38508, January 2012 refers to yearmonth.Date = '201201'\n#SELECT: amount spent refer to SUM(transactions_1k.Amount)\n#SQL-like: Show SUM(transactions_1k.Amount), WHERE transactions_1k.CustomerID = 38508 AND yearmonth.Date = '201201'\n#SQL: SELECT SUM(T1.Amount) FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.CustomerID = 38508 AND T2.Date = '201201'\n```"
    ],
    "553": [
        "```\n#reason: The question wants to count the number of badges obtained by the user 'csgillespie' in the year 2011, so the SQL SELECT COUNT(badges.Id) and it filters by user display name and the year of the badge date.\n#columns: badges.Id, users.DisplayName, badges.Date\n#values: 'csgillespie' refer to users.DisplayName = 'csgillespie', 'in 2011' refer to strftime('%Y', badges.Date) = '2011'\n#SELECT: SELECT COUNT(badges.Id) refer to badges.Id\n#SQL-like: Show COUNT(badges.Id), WHERE users.DisplayName = 'csgillespie' AND strftime('%Y', badges.Date) = '2011'\n#SQL: SELECT COUNT(badges.Id) FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'csgillespie' AND strftime('%Y', badges.Date) = '2011'\n```"
    ],
    "1356": [
        "```\n#reason: The question wants to identify the department of a specific club position, so the SQL SELECT will retrieve the department from the major table where the position is 'President'.\n#columns: major.department\n#values: 'President' refers to member.position = 'President'\n#SELECT: SELECT major.department\n#SQL-like: Show major.department WHERE member.position = 'President'\n#SQL: SELECT T1.department FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'President'\n```"
    ],
    "676": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"all display names of users\" who are classified as adults, where adults are defined as users with an age between 19 and 65.\n#columns: users.DisplayName\n#values: adults refer to users.Age BETWEEN 19 AND 65\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName WHERE users.Age BETWEEN 19 AND 65\n#SQL: SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65\n```"
    ],
    "53": [
        "```\n#reason: The question wants to display \"How many test takers\", so the SQL SELECT COUNT(numtsttakr) and we filter by the mailing city address being in 'Fresno'.\n#columns: satscores.NumTstTakr, schools.MailCity\n#values: 'in Fresno' refer to schools.MailCity = 'Fresno'\n#SELECT: SELECT COUNT(satscores.NumTstTakr) refer to satscores.NumTstTakr\n#SQL-like: Show COUNT(satscores.NumTstTakr) FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.MailCity = 'Fresno'\n#SQL: SELECT COUNT(satscores.NumTstTakr) FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.MailCity = 'Fresno'\n```"
    ],
    "397": [
        "```\n#reason: The question wants to find the \"mana cost\" of cards that meet specific criteria, so the SQL SELECT will include the mana cost from the cards table while filtering based on layout, frame version, border color, and availability.\n#columns: cards.manaCost\n#values: 'normal layout' refer to cards.layout = 'normal', '2003 frame version' refer to cards.frameVersion = '2003', 'black border color' refer to cards.borderColor = 'black', 'available in paper and mtgo' refer to cards.availability = 'mtgo,paper'\n#SELECT: SELECT cards.manaCost\n#SQL-like: Show cards.manaCost WHERE cards.layout = 'normal' AND cards.frameVersion = '2003' AND cards.borderColor = 'black' AND cards.availability = 'mtgo,paper'\n#SQL: SELECT T1.manaCost FROM cards AS T1 WHERE T1.layout = 'normal' AND T1.frameVersion = '2003' AND T1.borderColor = 'black' AND T1.availability = 'mtgo,paper'\n```"
    ],
    "478": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"card number 4\" in the set \"Coldsnap\", so the SQL SELECT will request the card's number based on the filter of the set name.\n#columns: cards.number, sets.name\n#values: card set Coldsnap refer to cards.setCode = 'Coldsnap', card number 4 refer to cards.number = '4'\n#SELECT: SELECT card number refer to cards.number\n#SQL-like: Show cards.number, WHERE cards.setCode = 'Coldsnap' AND cards.number = '4'\n#SQL: SELECT cards.number FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.number = '4'\n```"
    ],
    "655": [
        "```\n#reason: The question wants to retrieve the related posts titles and link type IDs for a specific post title, so the SQL SELECT will join the posts and postLinks tables to filter by the post title.\n#columns: posts.Title, postLinks.LinkTypeId\n#values: 'What are principal component scores?' refer to posts.Title = 'What are principal component scores?'\n#SELECT: SELECT posts.Title, postLinks.LinkTypeId\n#SQL-like: Show posts.Title, postLinks.LinkTypeId, WHERE posts.Title = 'What are principal component scores?'\n#SQL: SELECT T1.Title, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'What are principal component scores?'\n```"
    ],
    "602": [
        "```\n#reason: The question requires listing \"all post ID\" and \"user ID\" for posts with \"score more than 60\". So the SQL SELECT will include posts.Id and posts.OwnerUserId for the filtering condition.\n#columns: posts.Id, posts.OwnerUserId\n#values: score more than 60 refers to posts.Score > 60\n#SELECT: SELECT posts.Id, posts.OwnerUserId refer to posts.Id, posts.OwnerUserId\n#SQL-like: Show posts.Id, posts.OwnerUserId WHERE posts.Score > 60\n#SQL: SELECT posts.Id, posts.OwnerUserId FROM posts WHERE posts.Score > 60\n```"
    ],
    "1041": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the names of the teams with less than average chance creation passing for those teams with normal build-up play dribbling class in 2014, so the SQL SELECT will fetch the team names ordered by their chance creation passing descending.\n#columns: Team.team_long_name, Team_Attributes.chanceCreationPassing\n#values: normal build-up play dribbling class refers to Team_Attributes.buildUpPlayDribblingClass = 'Normal'; in 2014 refers to Team_Attributes.date >= '2014-01-01 00:00:00' AND Team_Attributes.date <= '2014-01-31 00:00:00'; less than average chance creation passing refers to Team_Attributes.chanceCreationPassing < (SELECT AVG(chanceCreationPassing) FROM Team_Attributes)\n#SELECT: SELECT team_long_name refer to Team.team_long_name\n#SQL-like: Show Team.team_long_name, WHERE Team_Attributes.buildUpPlayDribblingClass = 'Normal' AND Team_Attributes.date >= '2014-01-01 00:00:00' AND Team_Attributes.date <= '2014-01-31 00:00:00' AND Team_Attributes.chanceCreationPassing < (SELECT AVG(chanceCreationPassing) FROM Team_Attributes) ORDER BY Team_Attributes.chanceCreationPassing DESC\n#SQL: SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlayDribblingClass = 'Normal' AND T2.date >= '2014-01-01 00:00:00' AND T2.date <= '2014-01-31 00:00:00' AND T2.chanceCreationPassing < (SELECT AVG(chanceCreationPassing) FROM Team_Attributes) ORDER BY T2.chanceCreationPassing DESC\n```"
    ],
    "1": [
        "```\n#reason: The question wants to list the lowest three eligible free rates for students aged 5-17 in continuation schools, so the SQL SELECT will calculate the eligible free rates and filter for continuation schools.\n#columns: frpm.`Free Meal Count (Ages 5-17)`, frpm.`Enrollment (Ages 5-17)`\n#values: eligible free rates for students aged 5-17 refer to `frpm.Free Meal Count (Ages 5-17)` / `frpm.Enrollment (Ages 5-17)`, and continuation schools refer to `frpm.School Type = 'Continuation High Schools'`\n#SELECT: lowest three eligible free rates refer to `frpm.Free Meal Count (Ages 5-17) / frpm.Enrollment (Ages 5-17)`\n#SQL-like: Show frpm.`Free Meal Count (Ages 5-17) / frpm.`Enrollment (Ages 5-17`, WHERE frpm.`School Type` = 'Continuation High Schools' ORDER BY eligible free rates LIMIT 3\n#SQL: SELECT (frpm.`Free Meal Count (Ages 5-17)` / frpm.`Enrollment (Ages 5-17)`) AS eligible_free_rate FROM frpm WHERE frpm.`School Type` = 'Continuation High Schools' ORDER BY eligible_free_rate LIMIT 3\n```"
    ],
    "9": [
        "```\n#reason: The question wants to count the number of schools that are directly charter-funded and have an average score in Math over 560 in the SAT test, so the SQL SELECT will count the schools that meet these criteria.\n#columns: schools.School, satscores.AvgScrMath, frpm.`Charter Funding Type`\n#values: average score in Math over 560 refers to satscores.AvgScrMath > 560, directly charter-funded refers to frpm.`Charter Funding Type` = 'Directly funded'\n#SELECT: SELECT COUNT(schools.School) refer to schools.School\n#SQL-like: Show COUNT(schools.School) WHERE satscores.AvgScrMath > 560 AND frpm.`Charter Funding Type` = 'Directly funded'\n#SQL: SELECT COUNT(schools.School) FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE satscores.AvgScrMath > 560 AND frpm.`Charter Funding Type` = 'Directly funded'\n```"
    ],
    "897": [
        "```\n#reason: The question wants to identify the driver with the most wins, along with his nationality and maximum point scores. The most winning refers to MAX(COUNT(wins)), and maximum point scores refers to MAX(points). \n#columns: drivers.forename, drivers.surname, drivers.nationality, driverStandings.points\n#values: MAX(wins) refer to driverStandings.wins, no specific filtering conditions provided for nationality and points.\n#SELECT: SELECT drivers.forename, drivers.surname, drivers.nationality, MAX(driverStandings.points) \n#SQL-like: Show drivers.forename, drivers.surname, drivers.nationality, MAX(driverStandings.points) GROUP BY drivers.driverId ORDER BY COUNT(driverStandings.wins) DESC LIMIT 1\n#SQL: SELECT drivers.forename, drivers.surname, drivers.nationality, MAX(driverStandings.points) FROM drivers INNER JOIN driverStandings ON drivers.driverId = driverStandings.driverId GROUP BY drivers.driverId ORDER BY COUNT(driverStandings.wins) DESC LIMIT 1\n```"
    ],
    "356": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires display in order: \"How many cards\". \"infinite power\" is a filtering condition specified by power = '*'.\n#columns: cards.id, cards.power\n#values: infinite power refers to power = '*'\n#SELECT: How many cards refer to COUNT(id)\n#SQL-like: Show COUNT(cards.id), WHERE cards.power = '*'\n#SQL: SELECT COUNT(id) FROM cards WHERE power = '*'\n```"
    ],
    "125": [
        "```\n#reason: The question requires listing the district and state along with calculating the percentage increment in the unemployment rate from 1995 to 1996 for loan contracts that are still running and where clients are in debt. The percentage increment is calculated using the formula provided, and the filtering condition specifies that the loan status must be 'D'.\n#columns: district.A2, district.A3, district.A12, district.A13\n#values: 'loan contracts which are still running where client are in debt' refer to loan.status = 'D'\n#SELECT: SELECT district.A2, district.A3, (CAST((district.A13 - district.A12) AS REAL) / district.A12) * 100 AS unemployment_increment\n#SQL-like: Show district.A2, district.A3, (CAST((district.A13 - district.A12) AS REAL) / district.A12) * 100, WHERE loan.status = 'D'\n#SQL: SELECT district.A2, district.A3, (CAST((T1.A13 - T1.A12) AS REAL) / T1.A12) * 100 AS unemployment_increment FROM district AS T1 INNER JOIN loan AS T2 ON T1.district_id = T2.account_id WHERE T2.status = 'D'\n```"
    ],
    "978": [
        "```\n#reason: The question wants to count how many times the circuits were held in Austria and provide their location and coordinates. So the SQL SELECT will count the circuits and retrieve their location and coordinates where the country is Austria.\n#columns: circuits.location, circuits.lat, circuits.lng\n#values: Austria refers to circuits.country = 'Austria'\n#SELECT: How many times refer to COUNT(circuits.circuitId), location coordinates refer to circuits.lat, circuits.lng\n#SQL-like: Show COUNT(circuits.circuitId), circuits.location, circuits.lat, circuits.lng WHERE circuits.country = 'Austria'\n#SQL: SELECT COUNT(T1.circuitId), T1.location, T1.lat, T1.lng FROM circuits AS T1 WHERE T1.country = 'Austria'\n```"
    ],
    "36": [
        "```\n#reason: The question wants to find the full names of the administrators of the school that has the highest number of students scoring 1500 or more on the SAT, so the SQL SELECT will gather the names of the administrators from the schools database, filtered by the maximum number of test takers with scores greater than or equal to 1500.\n#columns: schools.AdmFName1, schools.AdmLName1, satscores.NumGE1500, schools.sname\n#values: highest number of students scoring 1500 or more on the SAT refers to MAX(satscores.NumGE1500)\n#SELECT: SELECT full names of administrators refer to schools.AdmFName1, schools.AdmLName1\n#SQL-like: Show schools.AdmFName1, schools.AdmLName1 FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds ORDER BY satscores.NumGE1500 DESC LIMIT 1\n#SQL: SELECT T1.AdmFName1, T1.AdmLName1 FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.NumGE1500 DESC LIMIT 1\n```"
    ],
    "1104": [
        "```\n#reason: The question wants to display the potential for Francesco Parravicini on a specific date, so the SQL SELECT will retrieve the potential score from the Player_Attributes table where the player's name matches and the date corresponds to the specified date.\n#columns: Player_Attributes.potential, Player.player_name, Player_Attributes.date\n#values: 'Francesco Parravicini' refer to Player.player_name = 'Francesco Parravicini', '2010/8/30' refer to Player_Attributes.date = '2010-08-30 00:00:00'\n#SELECT: SELECT Player_Attributes.potential refer to Player_Attributes.potential\n#SQL-like: Show Player_Attributes.potential WHERE Player.player_name = 'Francesco Parravicini' AND Player_Attributes.date = '2010-08-30 00:00:00'\n#SQL: SELECT T1.potential FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Francesco Parravicini' AND T1.date = '2010-08-30 00:00:00'\n```"
    ],
    "1518": [
        "```\n#reason: The question wants to identify the country for a specific deal based on the date and time, so the SQL SELECT will filter by the date and time of the transaction.\n#columns: gasstations.Country, transactions_1k.Date, transactions_1k.Time\n#values: '2012/8/24 12:42:00' refer to transactions_1k.Date = '2012-08-24' AND transactions_1k.Time = '12:42:00'\n#SELECT: which country refer to gasstations.Country\n#SQL-like: Show gasstations.Country, WHERE transactions_1k.Date = '2012-08-24' AND transactions_1k.Time = '12:42:00'\n#SQL: SELECT T1.Country FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Date = '2012-08-24' AND T2.Time = '12:42:00'\n```"
    ],
    "191": [
        "```\n#reason: The question wants to count the number of loan accounts for pre-payment of duration of 24 months with weekly issuance of statement, so the SQL SELECT COUNT(loan.loan_id) and COUNT(account.account_id) and COUNT(loan.duration) and COUNT(account.frequency) will be used.\n#columns: loan.loan_id, account.account_id, loan.duration, account.frequency\n#values: duration of 24 months refer to loan.duration = 24, frequency of 'POPLATEK TYDNE' refer to account.frequency = 'POPLATEK TYDNE'\n#SELECT: How many loan accounts refer to COUNT(loan.loan_id)\n#SQL-like: Show COUNT(loan.loan_id), WHERE loan.duration = 24 AND account.frequency = 'POPLATEK TYDNE'\n#SQL: SELECT COUNT(T1.loan_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.duration = 24 AND T2.frequency = 'POPLATEK TYDNE'\n```"
    ],
    "1113": [
        "```\n#reason: The question wants to display the defence aggression class for the team \"Hannover 96\" on a specific date, so the SQL SELECT will retrieve the defence aggression class from the Team_Attributes table, filtered by the team name and date.\n#columns: Team_Attributes.defenceAggressionClass, Team.team_long_name, Team_Attributes.date\n#values: 'Hannover 96' refer to Team.team_long_name = 'Hannover 96', '2015-09-10' refer to Team_Attributes.date LIKE '2015-09-10%'\n#SELECT: SELECT defenceAggressionClass refer to Team_Attributes.defenceAggressionClass\n#SQL-like: Show Team_Attributes.defenceAggressionClass, WHERE Team.team_long_name = 'Hannover 96' AND Team_Attributes.date LIKE '2015-09-10%'\n#SQL: SELECT T1.defenceAggressionClass FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.team_long_name = 'Hannover 96' AND T1.date LIKE '2015-09-10%'\n```"
    ],
    "761": [
        "```\n#reason: The question wants to list the super hero names of male superheroes whose weight is greater than 79% of the average weight of all superheroes, so the SQL SELECT will fetch the superhero_name from the superhero table filtered by gender = 'Male' and weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero).\n#columns: superhero.superhero_name\n#values: male superheroes refers to gender = 'Male' and weight greater than 79% of average weight refers to weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero)\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name WHERE superhero.gender_id = (SELECT id FROM gender WHERE gender = 'Male') AND superhero.weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero)\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 WHERE T1.gender_id = (SELECT id FROM gender WHERE gender = 'Male') AND T1.weight_kg > (SELECT AVG(weight_kg) * 0.79 FROM superhero)\n```"
    ],
    "1190": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of patients with a proteinuria level within the normal range who have a uric acid level below the normal range, so the SQL SELECT will count the patients meeting both conditions and calculate the percentage.\n#columns: Laboratory.`U-PRO`, Laboratory.UA\n#values: proteinuria level within the normal range refers to Laboratory.`U-PRO` > 0 AND Laboratory.`U-PRO` < 30, uric acid level below the normal range refers to Laboratory.UA <= 6.5\n#SELECT: percentage of patients with a proteinuria level within the normal range who have a uric acid level below the normal range refer to MULTIPLY(DIVIDE(COUNT(Laboratory.UA <= 6.5), COUNT(Laboratory.`U-PRO` > 0 AND Laboratory.`U-PRO` < 30)), 100)\n#SQL-like: Show MULTIPLY(DIVIDE(COUNT(Laboratory.UA <= 6.5), COUNT(Laboratory.`U-PRO` > 0 AND Laboratory.`U-PRO` < 30)), 100), WHERE Laboratory.`U-PRO` > 0 AND Laboratory.`U-PRO` < 30 AND Laboratory.UA <= 6.5\n#SQL: SELECT CAST(SUM(CASE WHEN T1.UA <= 6.5 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T1.`U-PRO` > 0 AND T1.`U-PRO` < 30 THEN 1 END) FROM Laboratory AS T1 WHERE T1.`U-PRO` > 0 AND T1.`U-PRO` < 30\n```"
    ],
    "258": [
        "```\n#reason: The question wants to display the bond types for atoms with the element Tin, so the SQL SELECT will retrieve bond_type from the bond table by joining it with the atom table based on the molecule_id, filtering for atoms where the element is 'sn'.\n#columns: bond.bond_type, atom.element\n#values: element Tin refers to atom.element = 'sn'\n#SELECT: bond type refer to bond.bond_type\n#SQL-like: Show bond.bond_type, WHERE atom.element = 'sn'\n#SQL: SELECT T1.bond_type FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'sn'\n```"
    ],
    "1102": [
        "```\n#reason: The question wants to find the oldest player with a specific overall rating on a specific date, so the SQL SELECT will filter players with an overall rating of 77 on the date of 2016-06-23 and order them by birthday to find the oldest.\n#columns: Player.player_name, Player.birthday, Player_Attributes.overall_rating, Player_Attributes.date\n#values: overall rating is 77 refers to Player_Attributes.overall_rating = 77, on 2016/6/23 refers to Player_Attributes.date LIKE '2016-06-23%'\n#SELECT: name of the player refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.overall_rating = 77 AND Player_Attributes.date LIKE '2016-06-23%', ORDER BY Player.birthday ASC\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating = 77 AND T2.date LIKE '2016-06-23%' ORDER BY T1.birthday ASC LIMIT 1\n```"
    ],
    "139": [
        "```\n#reason: The question wants to count the number of high-level credit cards with \"OWNER\" type of disposition, so the SQL SELECT will count the distinct card IDs where the card type is 'gold' and the disposition type is 'OWNER'.\n#columns: card.card_id, disp.type\n#values: high-level credit cards refer to card.type = 'gold', \"OWNER\" type of disposition refers to disp.type = 'OWNER'\n#SELECT: How many high-level credit cards refer to COUNT(DISTINCT card.card_id)\n#SQL-like: Show COUNT(DISTINCT card.card_id), WHERE card.type = 'gold' AND disp.type = 'OWNER'\n#SQL: SELECT COUNT(DISTINCT T1.card_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T1.type = 'gold' AND T2.type = 'OWNER'\n```"
    ],
    "764": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the superpowers of heroes with ID 1\", so the SQL SELECT will retrieve the power_name for heroes where hero_id = 1.\n#columns: superpower.power_name\n#values: hero_id = 1 refer to hero_power.hero_id = 1\n#SELECT: superpowers refer to superpower.power_name\n#SQL-like: Show superpower.power_name, WHERE hero_power.hero_id = 1\n#SQL: SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 1\n```"
    ],
    "1111": [
        "```\n#reason: The question wants to identify the \"chance creation passing class\" for \"PEC Zwolle\" on \"2013/9/20\", so the SQL SELECT will retrieve the appropriate class from the Team_Attributes table and filter based on the team name and date.\n#columns: Team.team_long_name, Team_Attributes.chanceCreationPassingClass, Team_Attributes.date\n#values: \"PEC Zwolle\" refers to Team.team_long_name = 'PEC Zwolle', on 2013/9/20 refers to Team_Attributes.date = '2013-09-20 00:00:00'\n#SELECT: SELECT Team_Attributes.chanceCreationPassingClass refer to Team_Attributes.chanceCreationPassingClass\n#SQL-like: Show Team_Attributes.chanceCreationPassingClass WHERE Team.team_long_name = 'PEC Zwolle' AND Team_Attributes.date = '2013-09-20 00:00:00'\n#SQL: SELECT T2.chanceCreationPassingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'PEC Zwolle' AND T2.date = '2013-09-20 00:00:00'\n```"
    ],
    "1344": [
        "```\n#reason: The question wants to display the \"notes of the fundraising\". The filtering condition is the \"source\" and \"date received\" of the income.\n#columns: income.notes, income.source, income.date_received\n#values: 'fundraising' refer to income.source = 'Fundraising', '2019/9/14' refer to income.date_received = '2019-09-14'\n#SELECT: notes of the fundraising refer to income.notes\n#SQL-like: Show income.notes, WHERE income.source = 'Fundraising' AND income.date_received = '2019-09-14'\n#SQL: SELECT T1.notes FROM income AS T1 WHERE T1.source = 'Fundraising' AND T1.date_received = '2019-09-14'\n```"
    ],
    "342": [
        "```\n#reason: The question wants to list the card names with the highest face converted mana cost, so the SQL SELECT will retrieve the names of the cards where the faceConvertedManaCost is equal to the maximum value of faceConvertedManaCost.\n#columns: cards.name, cards.faceConvertedManaCost\n#values: faceConvertedManaCost is the maximum value refer to faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards)\n#SELECT: SELECT name refer to cards.name\n#SQL-like: Show cards.name WHERE faceConvertedManaCost = MAX(faceConvertedManaCost)\n#SQL: SELECT name FROM cards WHERE faceConvertedManaCost = (SELECT MAX(faceConvertedManaCost) FROM cards)\n```"
    ],
    "945": [
        "```\n#reason: The question requires determining \"How many circuits\" with the filtering condition being \"in Adelaide, Australia\". \"Adelaide\" refers to circuits.location and \"Australia\" refers to circuits.country.\n#columns: circuits.circuitId\n#values: Adelaide refers to circuits.location = 'Adelaide', Australia refers to circuits.country = 'Australia'\n#SELECT: How many circuits refer to COUNT(circuits.circuitId)\n#SQL-like: Show COUNT(circuits.circuitId), WHERE circuits.location = 'Adelaide' AND circuits.country = 'Australia'\n#SQL: SELECT COUNT(circuitId) FROM circuits WHERE location = 'Adelaide' AND country = 'Australia'\n```"
    ],
    "1272": [
        "```\n#reason: The question wants to identify the first patient with an abnormal anti-SSA value, so the SQL SELECT will include the patient's ID while filtering for the first date they came to the hospital and where the anti-SSA result is abnormal.\n#columns: Patient.ID, Patient.`First Date`, Laboratory.SSA\n#values: abnormal anti-SSA refers to Laboratory.SSA NOT IN('negative', '0')\n#SELECT: ID refer to Patient.ID\n#SQL-like: Show Patient.ID WHERE Laboratory.SSA NOT IN('negative', '0') ORDER BY Patient.`First Date` ASC LIMIT 1\n#SQL: SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA NOT IN('negative', '0') ORDER BY T1.`First Date` ASC LIMIT 1\n```"
    ],
    "1021": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the height of the tallest player and his name. The tallest player refers to MAX(height), so the SQL SELECT must include both height and player_name.\n#columns: Player.height, Player.player_name\n#values: N/A\n#SELECT: SELECT height refer to Player.height, name refer to Player.player_name\n#SQL-like: Show Player.height, Player.player_name, ORDER BY Player.height DESC LIMIT 1\n#SQL: SELECT T1.height, T1.player_name FROM Player AS T1 ORDER BY T1.height DESC LIMIT 1\n```"
    ],
    "328": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all the elements with double bond, consisted in molecule TR024, so the SQL SELECT will retrieve the elements from the atom table that are connected through bonds of type '=' for the specified molecule.\n#columns: atom.element\n#values: double bond refers to bond.bond_type = '='; consisted in molecule TR024 refers to bond.molecule_id = 'TR024'\n#SELECT: SELECT atom.element refer to atom.element\n#SQL-like: Show atom.element, WHERE bond.bond_type = '=' AND bond.molecule_id = 'TR024'\n#SQL: SELECT DISTINCT a.element FROM atom AS a INNER JOIN bond AS b ON a.molecule_id = b.molecule_id WHERE b.bond_type = '=' AND b.molecule_id = 'TR024'\n```"
    ],
    "248": [
        "```\n#reason: The question wants to display the atoms of a specific triple bond associated with a molecule, so the SQL SELECT will retrieve the atom IDs connected by that bond and filter by the specified molecule ID and bond type.\n#columns: connected.atom_id, connected.atom_id2\n#values: molecule \"TR041\" refers to connected.bond_id in bond where bond.molecule_id = 'TR041' AND bond.bond_type = '#'\n#SELECT: SELECT both atom ids of the bond refer to connected.atom_id, connected.atom_id2.\n#SQL-like: Show connected.atom_id, connected.atom_id2, WHERE bond.molecule_id = 'TR041' AND bond.bond_type = '#'\n#SQL: SELECT T1.atom_id, T1.atom_id2 FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T2.molecule_id = 'TR041' AND T2.bond_type = '#'\n```"
    ],
    "80": [
        "```\n#reason: The question wants to identify \"the school type\" of the school with the \"highest latitude\", so the SQL SELECT will retrieve the school type, name, and latitude of the school with the maximum latitude value.\n#columns: schools.School Type, schools.School, schools.Latitude\n#values: highest latitude refers to ordering by schools.Latitude DESC LIMIT 1\n#SELECT: school type refer to schools.School Type, name of the school refer to schools.School, latitude coordinates refer to schools.Latitude\n#SQL-like: Show schools.School Type, schools.School, schools.Latitude ORDER BY schools.Latitude DESC LIMIT 1\n#SQL: SELECT T1.`School Type`, T1.`School`, T1.Latitude FROM schools AS T1 ORDER BY T1.Latitude DESC LIMIT 1\n```"
    ],
    "696": [
        "```\n#reason: The question wants to count the number of posts that have the tag 'careers', so the SQL SELECT COUNT(posts.Id) and join it with the tags table to filter based on TagName.\n#columns: posts.Id, tags.TagName\n#values: 'tag specified as careers' refer to tags.TagName = 'careers'\n#SELECT: SELECT COUNT(posts.Id)\n#SQL-like: Show COUNT(posts.Id), WHERE tags.TagName = 'careers'\n#SQL: SELECT COUNT(posts.Id) FROM posts INNER JOIN postLinks ON posts.Id = postLinks.PostId INNER JOIN tags ON postLinks.RelatedPostId = tags.Id WHERE tags.TagName = 'careers'\n```"
    ],
    "702": [
        "```\n#reason: The question wants to count the number of posts with a score less than 20, so the SQL SELECT COUNT(posts.Id) and the filtering condition is Score < 20.\n#columns: posts.Id, posts.Score\n#values: score less than 20 refers to Score < 20\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id), WHERE posts.Score < 20\n#SQL: SELECT COUNT(Id) FROM posts WHERE Score < 20\n```"
    ],
    "741": [
        "```\n#reason: The question wants to identify the superhero with the most powers, so the SQL SELECT will group by superhero_name and order by the count of powers in descending order to find the maximum.\n#columns: superhero.superhero_name, hero_power.hero_id\n#values: 'the most powers' refer to MAX(COUNT(hero_power.hero_id))\n#SELECT: SELECT superhero.superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, GROUP BY superhero.superhero_name, ORDER BY COUNT(hero_power.hero_id) DESC LIMIT 1\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.superhero_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1\n```"
    ],
    "1525": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the percentage of customers who used EUR on a specific date, so the SQL SELECT will calculate the count of customers using EUR on that date divided by the total count of customers on the same date.\n#columns: customers.Currency, transactions_1k.CustomerID, transactions_1k.Date\n#values: 'used EUR' refers to customers.Currency = 'EUR', 'on 2012/8/25' refers to transactions_1k.Date = '2012-08-25'\n#SELECT: SELECT content (percentage of customers using EUR) refers to (CAST(SUM(CASE WHEN customers.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(transactions_1k.CustomerID))\n#SQL-like: Show CAST(SUM(CASE WHEN customers.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(transactions_1k.CustomerID) WHERE transactions_1k.Date = '2012-08-25'\n#SQL: SELECT CAST(SUM(CASE WHEN customers.Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(transactions_1k.CustomerID) FROM customers INNER JOIN transactions_1k ON customers.CustomerID = transactions_1k.CustomerID WHERE transactions_1k.Date = '2012-08-25'\n```"
    ],
    "1298": [
        "```\n#reason: The question wants to count the number of patients whose total cholesterol is within the normal range and have a P pattern observed in the sheet of ANA examination, so the SQL SELECT COUNT(Patient.ID) and the necessary filtering conditions must be applied.\n#columns: Patient.ID, Laboratory.`T-CHO`, Examination.`ANA Pattern`\n#values: total cholesterol is within the normal range refer to `T-CHO` < 250, P pattern observed in the sheet of ANA examination refer to Examination.`ANA Pattern` = 'P'\n#SELECT: how many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Laboratory.`T-CHO` < 250 AND Examination.`ANA Pattern` = 'P'\n#SQL: SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-CHO` < 250 AND T3.`ANA Pattern` = 'P'\n```"
    ],
    "442": [
        "```\n#reason: The question wants to mention the base set size and set code of the set that was in the block named \"Masques\" and \"Mirage\", so the SQL SELECT will include these columns filtered by the specified block names.\n#columns: sets.baseSetSize, sets.code\n#values: 'in block named Masques' refers to sets.block = 'Masques', 'in block named Mirage' refers to sets.block = 'Mirage'\n#SELECT: SELECT sets.baseSetSize, sets.code\n#SQL-like: Show sets.baseSetSize, sets.code, WHERE sets.block = 'Masques' OR sets.block = 'Mirage'\n#SQL: SELECT sets.baseSetSize, sets.code FROM sets WHERE sets.block = 'Masques' OR sets.block = 'Mirage'\n```"
    ],
    "653": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the owner's display name of the most popular post, so the SQL SELECT will focus on the owner's display name where the view count is the highest (most popular post).\n#columns: posts.OwnerDisplayName, posts.ViewCount\n#values: most popular post refers to MAX(ViewCount)\n#SELECT: SELECT posts.OwnerDisplayName refer to posts.OwnerDisplayName\n#SQL-like: Show posts.OwnerDisplayName, where posts.ViewCount is the highest, order by posts.ViewCount DESC, limit 1\n#SQL: SELECT posts.OwnerDisplayName FROM posts ORDER BY posts.ViewCount DESC LIMIT 1\n```"
    ],
    "154": [
        "```\n#reason: The question wants to determine the number of male clients in the 'Hl.m. Praha' district, so the SQL SELECT COUNT(client.client_id) to get the total number of clients that meet the filtering conditions.\n#columns: client.client_id, client.gender, district.A2\n#values: 'Hl.m. Praha' refers to district.A2 = 'Hl.m. Praha', male refers to client.gender = 'M'\n#SELECT: SELECT COUNT(client.client_id) refer to client.client_id\n#SQL-like: Show COUNT(client.client_id), WHERE client.gender = 'M' AND district.A2 = 'Hl.m. Praha'\n#SQL: SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A2 = 'Hl.m. Praha'\n```"
    ],
    "1406": [
        "```\n#reason: The question wants to identify the budget entry with the highest budgeted amount for the category 'Food', so the SQL SELECT will retrieve the budget entry with the maximum amount where the category is 'Food'.\n#columns: budget.amount, budget.category\n#values: 'category is Food' refer to budget.category = 'Food'\n#SELECT: SELECT budget.amount refer to budget.amount\n#SQL-like: Show budget.amount, WHERE budget.category = 'Food', ORDER BY budget.amount DESC LIMIT 1\n#SQL: SELECT amount FROM budget WHERE category = 'Food' ORDER BY amount DESC LIMIT 1\n```"
    ],
    "947": [
        "```\n#reason: The question wants to find the count of British drivers born after 1980, so the SQL SELECT will count the number of drivers and filter based on their date of birth.\n#columns: drivers.driverId, drivers.dob\n#values: born after 1980 refers to drivers.dob > '1980-01-01'\n#SELECT: SELECT COUNT(drivers.driverId) refer to COUNT(drivers.driverId)\n#SQL-like: Show COUNT(drivers.driverId), WHERE drivers.dob > '1980-01-01' AND drivers.nationality = 'British'\n#SQL: SELECT COUNT(drivers.driverId) FROM drivers WHERE drivers.dob > '1980-01-01' AND drivers.nationality = 'British'\n```"
    ],
    "310": [
        "```\n#reason: The question wants to count the number of molecules with a double bond type and among these, how many are labeled as carcinogenic compounds, so the SQL SELECT will count the distinct molecule IDs where the bond type is double and the label is carcinogenic.\n#columns: bond.bond_type, molecule.label, bond.molecule_id\n#values: double bond refers to bond.bond_type = '='; label = '+' refers to molecule.label = '+'\n#SELECT: SELECT COUNT(DISTINCT bond.molecule_id) refer to bond.molecule_id\n#SQL-like: Show COUNT(DISTINCT bond.molecule_id), WHERE bond.bond_type = '=' AND molecule.label = '+'\n#SQL: SELECT COUNT(DISTINCT T1.molecule_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.label = '+'\n```"
    ],
    "1441": [
        "```\n#reason: The question wants to find the number of members who have an education major in the College of Education & Human Services, so the SQL SELECT will count the members filtered by the specified major and college.\n#columns: member.member_id, major.major_name, major.college\n#values: 'education major' refer to major.major_name = 'Education', 'College of Education & Human Services' refer to major.college = 'College of Education & Human Services'\n#SELECT: SELECT COUNT(member.member_id) refer to member.member_id\n#SQL-like: Show COUNT(member.member_id) WHERE major.major_name = 'Education' AND major.college = 'College of Education & Human Services'\n#SQL: SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Education' AND T2.college = 'College of Education & Human Services'\n```"
    ],
    "79": [
        "```\n#reason: The question wants to determine which county offers the most number of schools that do not offer a physical building, so the SQL SELECT will count the number of schools grouped by county and filter for virtual schools.\n#columns: schools.County, COUNT(schools.School)\n#values: 'San Diego' and 'Santa Barbara' refer to schools.County IN ('San Diego', 'Santa Barbara'), 'does not offer physical building' refers to schools.Virtual = 'F'\n#SELECT: SELECT COUNT(schools.School) refer to COUNT(schools.School)\n#SQL-like: Show COUNT(schools.School), WHERE schools.County IN ('San Diego', 'Santa Barbara') AND schools.Virtual = 'F' GROUP BY schools.County\n#SQL: SELECT schools.County, COUNT(schools.School) FROM schools WHERE schools.County IN ('San Diego', 'Santa Barbara') AND schools.Virtual = 'F' GROUP BY schools.County\n```"
    ],
    "522": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"cards ranked 1st on EDHRec\", which refers to filtering by edhrecRank = 1. \"cards name\" refers to the cards.name column, and \"its banned play format\" refers to legalities.status = 'Banned'.\n#columns: cards.name, legalities.status\n#values: 'ranked 1st on EDHRec' refers to cards.edhrecRank = 1, 'banned play format' refers to legalities.status = 'Banned'\n#SELECT: SELECT cards.name, legalities.status\n#SQL-like: Show cards.name, legalities.status WHERE cards.edhrecRank = 1 AND legalities.status = 'Banned'\n#SQL: SELECT cards.name, legalities.status FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.edhrecRank = 1 AND legalities.status = 'Banned'\n```"
    ],
    "917": [
        "```\n#reason: The question wants to find the website for Anthony Davidson, so the SQL SELECT will retrieve the url associated with the driver.\n#columns: drivers.url\n#values: 'Anthony Davidson' refers to drivers.forename = 'Anthony' AND drivers.surname = 'Davidson'\n#SELECT: url refers to drivers.url\n#SQL-like: Show drivers.url, WHERE drivers.forename = 'Anthony' AND drivers.surname = 'Davidson'\n#SQL: SELECT url FROM drivers WHERE forename = 'Anthony' AND surname = 'Davidson'\n```"
    ],
    "1095": [
        "```\n#reason: The question wants to find the average build up play speed of the Heart of Midlothian team, so the SQL SELECT will calculate AVG(buildUpPlaySpeed) and filter by team_long_name = 'Heart of Midlothian'.\n#columns: Team_Attributes.buildUpPlaySpeed, Team.team_long_name\n#values: 'Heart of Midlothian' refer to Team.team_long_name = 'Heart of Midlothian'\n#SELECT: average build up play speed refer to AVG(buildUpPlaySpeed)\n#SQL-like: Show AVG(buildUpPlaySpeed), WHERE Team.team_long_name = 'Heart of Midlothian'\n#SQL: SELECT AVG(T1.buildUpPlaySpeed) FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.team_long_name = 'Heart of Midlothian'\n```"
    ],
    "133": [
        "```\n#reason: The question wants to identify the districts with the highest unemployment rate in 1996, so the SQL SELECT will retrieve the branch location and district name, filtering by the unemployment rate in 1996.\n#columns: district.A2, district.A13\n#values: 'highest unemployment rate in 1996' refer to 'district.A13 = (SELECT MAX(A13) FROM district WHERE A13 IS NOT NULL)'.\n#SELECT: SELECT district.A4, district.A2\n#SQL-like: Show district.A4, district.A2 WHERE district.A13 = (SELECT MAX(A13) FROM district WHERE A13 IS NOT NULL)\n#SQL: SELECT district.A4, district.A2 FROM district WHERE district.A13 = (SELECT MAX(A13) FROM district WHERE A13 IS NOT NULL)\n```"
    ],
    "1213": [
        "```\n#reason: The question wants to identify the ID of the patient born on April 1st, 1982, and check if their alkaliphophatase (ALP) is within the normal range. So the SQL SELECT will retrieve the Patient.ID and check if Laboratory.ALP is less than 300.\n#columns: Patient.ID, Laboratory.ALP\n#values: 'born on April 1st, 1982' refers to Patient.Birthday = '1982-04-01', 'alkaliphophatase (ALP) within normal range' refers to Laboratory.ALP < 300\n#SELECT: SELECT Patient.ID, Laboratory.ALP refer to Patient.ID, Laboratory.ALP\n#SQL-like: Show Patient.ID, Laboratory.ALP, WHERE Patient.Birthday = '1982-04-01' AND Laboratory.ALP < 300\n#SQL: SELECT P.ID, L.ALP FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Birthday = '1982-04-01' AND L.ALP < 300\n```"
    ],
    "887": [
        "```\n#reason: The question wants to list the races in year 2017 that are not hosted in year 2000, so the SQL SELECT will filter for races from 2017 and exclude those from 2000.\n#columns: races.name, races.year\n#values: not hosted in year 2000 refers to races.year <> 2000 and year 2017 refers to races.year = 2017\n#SELECT: name of races refer to races.name\n#SQL-like: Show races.name, WHERE races.year = 2017 AND races.year <> 2000\n#SQL: SELECT name FROM races WHERE year = 2017 AND year <> 2000\n```"
    ],
    "338": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"atom ID of double bonded carbon\" in the \"TR012\" molecule, so the SQL SELECT will retrieve the atom ID where the element is carbon and the bond type is double.\n#columns: atom.atom_id, bond.bond_type, bond.molecule_id, atom.element\n#values: 'TR012' refers to bond.molecule_id = 'TR012', 'double bond' refers to bond.bond_type = '=' and 'carbon' refers to atom.element = 'c'\n#SELECT: atom ID refers to atom.atom_id\n#SQL-like: Show atom.atom_id WHERE bond.bond_type = '=' AND atom.element = 'c' AND bond.molecule_id = 'TR012'\n#SQL: SELECT T1.atom_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.bond_type = '=' AND T2.molecule_id = 'TR012'\n```"
    ],
    "531": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to compare the reputations of two users, so the SQL SELECT will fetch the user with the highest reputation between them.\n#columns: users.DisplayName, users.Reputation\n#values: 'Harlan' refers to users.DisplayName = 'Harlan', 'Jarrod Dixon' refers to users.DisplayName = 'Jarrod Dixon'\n#SELECT: SELECT users.DisplayName, users.Reputation\n#SQL-like: Show users.DisplayName, users.Reputation WHERE users.DisplayName in ('Harlan', 'Jarrod Dixon') ORDER BY users.Reputation DESC LIMIT 1\n#SQL: SELECT DisplayName, Reputation FROM users WHERE DisplayName IN ('Harlan', 'Jarrod Dixon') ORDER BY Reputation DESC LIMIT 1\n```"
    ],
    "1058": [
        "```\n#reason: The question wants to find the player with the highest average finishing rate between the tallest and shortest football players. The SQL will need to calculate the maximum height (for the tallest player) and minimum height (for the shortest player) first, and then compute the average finishing rate for these players to find the maximum. \n#columns: Player.player_name, Player_Attributes.finishing, Player.height\n#values: 'height is maximum' refers to Player.height = (SELECT MAX(height) FROM Player), 'height is minimum' refers to Player.height = (SELECT MIN(height) FROM Player)\n#SELECT: SELECT MAX(AVG(finishing)) refer to AVG(Player_Attributes.finishing)\n#SQL-like: Show AVG(finishing) WHERE height = (SELECT MAX(height) FROM Player) OR height = (SELECT MIN(height) FROM Player) GROUP BY Player.height ORDER BY AVG(finishing) DESC LIMIT 1\n#SQL: SELECT MAX(avgFinishing) FROM (SELECT AVG(PA.finishing) as avgFinishing FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE P.height = (SELECT MAX(height) FROM Player) OR P.height = (SELECT MIN(height) FROM Player) GROUP BY P.player_api_id)\n```"
    ],
    "256": [
        "```\n#reason: The question requires counting the total number of atoms consisting of the elements carbon and hydrogen, so the SQL SELECT COUNT(atom.atom_id) and filtering for elements in ('c', 'h') will be used.\n#columns: atom.atom_id, atom.element\n#values: consisting of element carbon and hydrogen refers to atom.element IN ('c', 'h')\n#SELECT: total atoms refers to COUNT(atom.atom_id)\n#SQL-like: Show COUNT(atom.atom_id), WHERE atom.element IN ('c', 'h')\n#SQL: SELECT COUNT(atom.atom_id) FROM atom WHERE atom.element IN ('c', 'h')\n```"
    ],
    "953": [
        "```\n#reason: The question wants to count the number of French constructors with a lap number of over 50, so the SQL SELECT will count the distinct constructor IDs from the results table where the nationality is French and the lap number is greater than 50.\n#columns: results.constructorId, drivers.nationality, results.laps\n#values: 'French' refers to drivers.nationality = 'French', 'lap number of over 50' refers to results.laps > 50\n#SELECT: SELECT COUNT(DISTINCT results.constructorId) \n#SQL-like: Show COUNT(DISTINCT results.constructorId), WHERE drivers.nationality = 'French' AND results.laps > 50\n#SQL: SELECT COUNT(DISTINCT results.constructorId) FROM results INNER JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.nationality = 'French' AND results.laps > 50\n```"
    ],
    "341": [
        "```\n#reason: The question wants to find \"borderless cards\" that are available \"without powerful foils\", so the SQL SELECT will filter for borderColor and check for the absence of cardKingdomFoilId paired with a non-null cardKingdomId.\n#columns: cards.borderColor, cards.cardKingdomFoilId, cards.cardKingdomId\n#values: 'borderless cards' refer to cards.borderColor = 'borderless', 'without powerful foils' refer to cards.cardKingdomFoilId IS NULL OR cards.cardKingdomId IS NULL\n#SELECT: borderless cards refer to cards.borderColor\n#SQL-like: Show cards.borderColor, WHERE cards.borderColor = 'borderless' AND (cards.cardKingdomFoilId IS NULL OR cards.cardKingdomId IS NULL)\n#SQL: SELECT * FROM cards WHERE cards.borderColor = 'borderless' AND (cards.cardKingdomFoilId IS NULL OR cards.cardKingdomId IS NULL)\n```"
    ],
    "121": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list account ID and account opening date for accounts from 'Prachatice', so the SQL SELECT will include account.account_id and account.date, and it will filter based on the district name.\n#columns: account.account_id, account.date\n#values: 'Prachatice' refer to district.A2 = 'Prachatice'\n#SELECT: account ID and account opening date refer to account.account_id, account.date\n#SQL-like: Show account.account_id, account.date, WHERE district.A2 = 'Prachatice'\n#SQL: SELECT T1.account_id, T1.date FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Prachatice'\n```"
    ],
    "211": [
        "```\n#reason: The question wants to identify which atoms are connected in non-carcinogenic type molecules, so the SQL SELECT will focus on the connected atoms from the connected table where the corresponding molecule is non-carcinogenic.\n#columns: connected.atom_id, connected.atom_id2\n#values: label = '-' refers to molecule.label = '-'\n#SELECT: SELECT connected.atom_id, connected.atom_id2 refer to connected.atom_id, connected.atom_id2\n#SQL-like: Show connected.atom_id, connected.atom_id2 WHERE molecule.label = '-'\n#SQL: SELECT T1.atom_id, T1.atom_id2 FROM connected AS T1 INNER JOIN molecule AS T2 ON T1.bond_id = T2.molecule_id WHERE T2.label = '-'\n```"
    ],
    "749": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the superpowers of a specific superhero named \"Deathlok\", so the SQL SELECT will need to combine the superhero's information with their associated powers.\n#columns: superpower.power_name, superhero.superhero_name\n#values: 'Deathlok' refers to superhero.superhero_name = 'Deathlok'\n#SELECT: superpowers refers to superpower.power_name\n#SQL-like: Show superpower.power_name, WHERE superhero.superhero_name = 'Deathlok'\n#SQL: SELECT T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Deathlok'\n```"
    ],
    "712": [
        "```\n#reason: The question wants to display the post ID and the comments for the post titled \"Group differences on a five point Likert item\", so the SQL SELECT will include posts.Id and comments.Text, and the filtering condition is based on the title of the post.\n#columns: posts.Id, comments.Text\n#values: Title = 'Group differences on a five point Likert item' refer to posts.Title = 'Group differences on a five point Likert item'\n#SELECT: post ID refer to posts.Id, comments refer to comments.Text\n#SQL-like: Show posts.Id, comments.Text, WHERE posts.Title = 'Group differences on a five point Likert item'\n#SQL: SELECT T1.Id, T2.Text FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T1.Title = 'Group differences on a five point Likert item'\n```"
    ],
    "1067": [
        "```\n#reason: The question wants to list the short names of teams that have a build-up play passing score greater than 70, so the SQL SELECT will filter teams based on their build-up play passing score and return the short names.\n#columns: Team.team_short_name, Team_Attributes.buildUpPlayPassing\n#values: build up play passing more than 70 refers to Team_Attributes.buildUpPlayPassing > 70\n#SELECT: SELECT Team.team_short_name refer to Team.team_short_name\n#SQL-like: Show Team.team_short_name, WHERE Team_Attributes.buildUpPlayPassing > 70\n#SQL: SELECT T1.team_short_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlayPassing > 70\n```"
    ],
    "826": [
        "```\n#reason: The question wants to identify the heaviest superhero in DC Comics, so the SQL SELECT will find the superhero with the maximum weight in kilograms from the DC Comics publisher.\n#columns: superhero.superhero_name, superhero.weight_kg\n#values: 'DC Comics' refers to publisher.publisher_name = 'DC Comics'\n#SELECT: SELECT superhero_name, weight_kg\n#SQL-like: Show superhero_name, weight_kg WHERE publisher_name = 'DC Comics' ORDER BY weight_kg DESC LIMIT 1\n#SQL: SELECT T1.superhero_name, T1.weight_kg FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics' ORDER BY T1.weight_kg DESC LIMIT 1\n```"
    ],
    "1286": [
        "```\n#reason: The question wants to determine how many patients have an abnormal alkaliphophatase level and are admitted to the hospital, so the SQL SELECT will count the patients with the specified conditions.\n#columns: Laboratory.ALP, Patient.Admission\n#values: abnormal alkaliphophatase level refers to Laboratory.ALP >= 300; admitted to the hospital refers to Patient.Admission = '+'\n#SELECT: How many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID) WHERE Laboratory.ALP >= 300 AND Patient.Admission = '+'\n#SQL: SELECT COUNT(Patient.ID) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Laboratory.ALP >= 300 AND Patient.Admission = '+'\n```"
    ],
    "1164": [
        "```\n#reason: The question wants to count the number of patients with the most serious thrombosis cases examined in 1997 who are women, so the SQL SELECT COUNT(DISTINCT Patient.ID) and COUNT(DISTINCT Patient.ID) will be used to get the total number of unique patients.\n#columns: Patient.ID, Patient.SEX, Examination.Thrombosis, Examination.`Examination Date`\n#values: 'the most serious thrombosis' refer to Examination.Thrombosis = 1, 'examined in 1997' refer to strftime('%Y', Examination.`Examination Date`) = '1997', 'women' refer to Patient.SEX = 'F'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Examination.Thrombosis = 1 AND strftime('%Y', Examination.`Examination Date`) = '1997' AND Patient.SEX = 'F'\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID WHERE E.Thrombosis = 1 AND strftime('%Y', E.`Examination Date`) = '1997' AND P.SEX = 'F'\n```"
    ],
    "293": [
        "```\n#reason: The question requires counting the number of atoms belonging to molecules labeled as carcinogenic. Therefore, the SQL SELECT statement will count the atoms linked to the molecules where the label is '+'.\n#columns: atom.atom_id\n#values: label = '+' refers to molecule.label = '+'\n#SELECT: SELECT COUNT(atom.atom_id) refer to atom.atom_id\n#SQL-like: Show COUNT(atom.atom_id), WHERE molecule.label = '+'\n#SQL: SELECT COUNT(atom.atom_id) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '+'\n```"
    ],
    "1225": [
        "```\n#reason: The question want to group all patients by sex for total bilirubin (T-BIL) level not within the normal range, so the SQL SELECT GROUP_CONCAT(DISTINCT Patient.ID) to get the patient IDs grouped by sex.\n#columns: Patient.SEX, Laboratory.`T-BIL`, Patient.ID\n#values: total bilirubin (T-BIL) not within normal range refers to Laboratory.`T-BIL` >= 2.0\n#SELECT: SELECT GROUP_CONCAT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show GROUP_CONCAT(DISTINCT Patient.ID) from Patient, Laboratory WHERE Laboratory.`T-BIL` >= 2.0 GROUP BY Patient.SEX\n#SQL: SELECT Patient.SEX, GROUP_CONCAT(DISTINCT Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.`T-BIL` >= 2.0 GROUP BY Patient.SEX\n```"
    ],
    "165": [
        "```\n#reason: The question wants to display all the transactions made by accounts from district 5, so the SQL SELECT ... will include all transaction details filtered by district ID.\n#columns: trans.trans_id, trans.account_id, trans.operation, trans.amount, trans.date, trans.balance, trans.k_symbol, trans.type\n#values: district 5 refer to account.district_id = 5\n#SELECT: SELECT all transactions refer to trans.trans_id, trans.account_id, trans.operation, trans.amount, trans.date, trans.balance, trans.k_symbol, trans.type\n#SQL-like: Show all transactions, WHERE account.district_id = 5\n#SQL: SELECT T1.trans_id, T1.account_id, T1.operation, T1.amount, T1.date, T1.balance, T1.k_symbol, T1.type FROM trans AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.district_id = 5\n```"
    ],
    "73": [
        "```\n#reason: The question wants to retrieve the free or reduced price meal count for ages 5 to 17 in the Youth Authority School with a specific mailing address, so the SQL SELECT will focus on the relevant columns and apply the necessary filters.\n#columns: frpm.`Free Meal Count (Ages 5-17)`, schools.EdOpsName, schools.MailStreet\n#values: 'Youth Authority School' refer to schools.EdOpsName = 'Youth Authority School', 'PO Box 1040' refer to schools.MailStreet = 'PO Box 1040'\n#SELECT: SELECT frpm.`Free Meal Count (Ages 5-17)`\n#SQL-like: Show frpm.`Free Meal Count (Ages 5-17)`, WHERE schools.EdOpsName = 'Youth Authority School' AND schools.MailStreet = 'PO Box 1040'\n#SQL: SELECT frpm.`Free Meal Count (Ages 5-17)` FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.EdOpsName = 'Youth Authority School' AND schools.MailStreet = 'PO Box 1040'\n```"
    ],
    "698": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to know how many comments and answers were left by the users on the post titled 'Clustering 1D data', so the SQL SELECT will count the comments and filter by the post's title.\n#columns: posts.Id, comments.Id, posts.AnswerCount\n#values: title 'Clustering 1D data' refers to posts.Title = 'Clustering 1D data'\n#SELECT: COUNT(comments.Id), posts.AnswerCount refer to posts.Id\n#SQL-like: Show COUNT(comments.Id), COUNT(posts.AnswerCount), WHERE posts.Title = 'Clustering 1D data'\n#SQL: SELECT COUNT(comments.Id), (SELECT AnswerCount FROM posts WHERE Title = 'Clustering 1D data') FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.Title = 'Clustering 1D data'\n```"
    ],
    "954": [
        "```\n#reason: The question wants to calculate the race completion percentage of Japanese drivers from 2007 to 2009, so the SQL SELECT will count the number of Japanese drivers who completed the race (time is not null) and divide it by the total number of Japanese drivers in that period, multiplying by 100 for the percentage.\n#columns: results.driverId, results.time, races.year, drivers.nationality\n#values: 'Japanese drivers' refer to drivers.nationality = 'Japanese', 'from 2007 to 2009' refer to races.year BETWEEN 2007 AND 2009\n#SELECT: SELECT content refers to 'race completion percentage' refer to (COUNT(results.driverId) WHERE results.time IS NOT NULL AND races.year BETWEEN 2007 AND 2009) / COUNT(results.driverId) WHERE races.year BETWEEN 2007 AND 2009\n#SQL-like: Show (COUNT(results.driverId WHERE results.time IS NOT NULL AND races.year BETWEEN 2007 AND 2009) / COUNT(results.driverId WHERE races.year BETWEEN 2007 AND 2009)) * 100\n#SQL: SELECT CAST(COUNT(T1.driverId) AS REAL) * 100 / COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T1.time IS NOT NULL AND T2.year BETWEEN 2007 AND 2009 AND T3.nationality = 'Japanese'\n```"
    ],
    "440": [
        "```\n#reason: The question wants to identify the foreign language used by \"A Pedra Fellwar\", so the SQL SELECT will filter based on the name of the card and retrieve the corresponding foreign language.\n#columns: foreign_data.language, foreign_data.name\n#values: 'A Pedra Fellwar' refer to foreign_data.name = 'A Pedra Fellwar'\n#SELECT: Which foreign language refer to foreign_data.language\n#SQL-like: Show foreign_data.language, WHERE foreign_data.name = 'A Pedra Fellwar'\n#SQL: SELECT T1.language FROM foreign_data AS T1 WHERE T1.name = 'A Pedra Fellwar'\n```"
    ],
    "1350": [
        "```\n#reason: The question wants to find the status of the event associated with the expense description \"Post Cards, Posters\" on 2019/8/20, so the SQL SELECT will retrieve the event status based on the expense description and date.\n#columns: budget.event_status, expense.expense_description, expense.expense_date\n#values: 'Post Cards, Posters' refers to expense.expense_description = 'Post Cards, Posters', 'on 2019/8/20' refers to expense.expense_date = '2019-08-20'\n#SELECT: SELECT budget.event_status refer to budget.event_status\n#SQL-like: Show budget.event_status WHERE expense.expense_description = 'Post Cards, Posters' AND expense.expense_date = '2019-08-20'\n#SQL: SELECT T1.event_status FROM budget AS T1 INNER JOIN expense AS T2 ON T1.link_to_budget = T2.link_to_budget WHERE T2.expense_description = 'Post Cards, Posters' AND T2.expense_date = '2019-08-20'\n```"
    ],
    "1270": [
        "```\n#reason: The question wants to count how many female patients with normal anti-scl70 also do not have any symptoms, so the SQL SELECT DISTINCT COUNT(Patient.ID) is used to count unique patients who meet these conditions.\n#columns: Patient.ID, Patient.SEX, Examination.Symptoms, Laboratory.SC170\n#values: normal anti-scl70 refers to Laboratory.SC170 IN ('negative', '0'), female refers to Patient.SEX = 'F', does not have any symptom refers to Examination.Symptoms IS NULL\n#SELECT: SELECT DISTINCT COUNT(Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID) WHERE Patient.SEX = 'F' AND Laboratory.SC170 IN ('negative', '0') AND Examination.Symptoms IS NULL\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T1.SEX = 'F' AND T2.SC170 IN ('negative', '0') AND T3.Symptoms IS NULL\n```"
    ],
    "260": [
        "```\n#reason: The question requires calculating the total number of atoms with triple-bond molecules containing either phosphorus or bromine. The SQL SELECT statement will sum the number of atoms filtered by bond type and element conditions.\n#columns: atom.atom_id\n#values: triple bond refers to bond_type = '#', phosphorus refers to element = 'p', bromine refers to element = 'br'\n#SELECT: total atoms refer to COUNT(atom.atom_id)\n#SQL-like: Show COUNT(atom.atom_id) WHERE bond.bond_type = '#' AND (atom.element = 'p' OR atom.element = 'br')\n#SQL: SELECT COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND (T1.element = 'p' OR T1.element = 'br')\n```"
    ],
    "1064": [
        "```\n#reason: The question requires listing players whose preferred foot is left, so the SQL SELECT will focus on the preferred_foot column and filter for 'left'.\n#columns: Player_Attributes.preferred_foot, Player.player_name\n#values: preferred_foot = 'left' refers to Player_Attributes.preferred_foot = 'left'\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.preferred_foot = 'left'\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.preferred_foot = 'left'\n```"
    ],
    "490": [
        "```\n#reason: The question wants to retrieve the magic card market id for a specific set, so the SQL SELECT will involve filtering by the set code 'SS2'.\n#columns: sets.mcmId\n#values: 'SS2' refer to sets.code = 'SS2'\n#SELECT: mcmId refers to sets.mcmId\n#SQL-like: Show sets.mcmId, WHERE sets.code = 'SS2'\n#SQL: SELECT mcmId FROM sets WHERE code = 'SS2'\n```"
    ],
    "1221": [
        "```\n#reason: The question wants to provide the ID, sex, and birthday of all patients diagnosed with 'RA' that are within the UN normal index, so the SQL SELECT will extract these columns while applying the specified filters.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday, Laboratory.UN\n#values: Diagnosis = 'RA' refers to Patient.Diagnosis = 'RA', within the UN normal index refers to Laboratory.UN < 30\n#SELECT: ID, sex, birthday refer to Patient.ID, Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Birthday, WHERE Patient.Diagnosis = 'RA' AND Laboratory.UN < 30\n#SQL: SELECT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'RA' AND T2.UN < 30\n```"
    ],
    "1040": [
        "```\n#reason: The question wants to list the top 10 players' names whose heights are above 180 in descending order of average heading accuracy. This involves filtering players based on height and calculating the average heading accuracy.\n#columns: Player.player_name, Player_Attributes.heading_accuracy\n#values: heights are above 180 refer to Player.height > 180\n#SELECT: SELECT Player.player_name refer to Player.player_name, average heading accuracy refer to DIVIDE(SUM(Player_Attributes.heading_accuracy), COUNT(Player.player_fifa_api_id))\n#SQL-like: Show Player.player_name, ORDER BY DIVIDE(SUM(Player_Attributes.heading_accuracy), COUNT(Player.player_fifa_api_id)) DESC LIMIT 10\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height > 180 GROUP BY T1.player_name ORDER BY DIVIDE(SUM(T2.heading_accuracy), COUNT(T1.player_fifa_api_id)) DESC LIMIT 10\n```"
    ],
    "984": [
        "```\n#reason: The question wants to find the website of the constructor who has the most total wins, so the SQL SELECT will aggregate the wins and filter for the constructor with the maximum total wins.\n#columns: constructors.url, results.wins\n#values: most total wins refer to MAX(SUM(wins)) in the results table.\n#SELECT: SELECT constructors.url, SUM(results.wins) AS total_wins\n#SQL-like: Show constructors.url, WHERE condition is the maximum total wins, GROUP BY constructors.url ORDER BY total_wins DESC LIMIT 1\n#SQL: SELECT T1.url FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId GROUP BY T1.url ORDER BY SUM(T2.wins) DESC LIMIT 1\n```"
    ],
    "739": [
        "```\n#reason: The question requires displaying the names of superheroes who possess a specific power known as \"Death Touch\". Therefore, the SQL SELECT will include the superhero's name filtered by the power name.\n#columns: superhero.superhero_name, superpower.power_name\n#values: 'the power of death touch' refers to superpower.power_name = 'Death Touch'\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE superpower.power_name = 'Death Touch'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Death Touch'\n```"
    ],
    "1480": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the gas consumption peak month for SME customers in 2013, so the SQL SELECT will focus on the total consumption grouped by month for SME customers within the specified year range.\n#columns: yearmonth.Date, yearmonth.Consumption\n#values: 'in 2013' refer to 'yearmonth.Date BETWEEN 201301 AND 201312'\n#SELECT: SELECT the month with the highest gas consumption refer to 'yearmonth.Date and yearmonth.Consumption'\n#SQL-like: Show yearmonth.Date, SUM(yearmonth.Consumption), WHERE yearmonth.Date BETWEEN 201301 AND 201312 AND yearmonth.CustomerID IN (SELECT CustomerID FROM customers WHERE Segment = 'SME'), GROUP BY yearmonth.Date ORDER BY SUM(yearmonth.Consumption) DESC LIMIT 1\n#SQL: SELECT T1.Date FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date BETWEEN 201301 AND 201312 AND T2.Segment = 'SME' GROUP BY T1.Date ORDER BY SUM(T1.Consumption) DESC LIMIT 1\n```"
    ],
    "558": [
        "```\n#reason: The question wants to display the count of votes taken by a specific user on a specific date, so the SQL SELECT will count the votes where the user ID matches and the creation date is on the specified date.\n#columns: votes.UserId, votes.CreationDate\n#values: user No.58 refer to votes.UserId = 58, on 2010/7/19 refer to votes.CreationDate = '2010-07-19'\n#SELECT: How many votes refer to COUNT(votes.Id)\n#SQL-like: Show COUNT(votes.Id), WHERE votes.UserId = 58 AND votes.CreationDate = '2010-07-19'\n#SQL: SELECT COUNT(Id) FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19'\n```"
    ],
    "82": [
        "```\n#reason: The question wants to identify the \"grade span offered\" in the \"school with the highest longitude\". The \"highest longitude\" refers to identifying the school with the maximum absolute value of the longitude.\n#columns: schools.GSoffered, schools.Longitude\n#values: highest longitude refers to |longitude| = MAX(|Longitude|) which implies taking the school with the maximum absolute value of Longitude.\n#SELECT: SELECT content refers to schools.GSoffered\n#SQL-like: Show schools.GSoffered, ORDER BY ABS(schools.Longitude) DESC LIMIT 1\n#SQL: SELECT T1.GSoffered FROM schools AS T1 ORDER BY ABS(T1.Longitude) DESC LIMIT 1\n```"
    ],
    "235": [
        "```\n#reason: The question wants to count the number of molecules that are carcinogenic and have the bromine element, so the SQL SELECT will count the unique molecule IDs where the label is '+' and the element is 'br'.\n#columns: molecule.molecule_id, atom.element\n#values: carcinogenic refers to molecule.label = '+', have bromine element refers to atom.element = 'br'\n#SELECT: SELECT COUNT(DISTINCT molecule.molecule_id) refer to COUNT(DISTINCT molecule.molecule_id)\n#SQL-like: Show COUNT(DISTINCT molecule.molecule_id), WHERE molecule.label = '+' AND atom.element = 'br'\n#SQL: SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.element = 'br'\n```"
    ],
    "1202": [
        "```\n#reason: The question wants to count how many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with Behcet disease did not stay in the hospital for treatment, so the SQL SELECT will count distinct patients based on the specified conditions.\n#columns: Patient.SEX, Examination.`Examination Date`, Patient.Admission, Patient.Diagnosis\n#values: male refers to Patient.SEX = 'M', underwent testing between 1995 and 1997 refers to Examination.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31', Behcet refers to Patient.Diagnosis = 'Behcet', did not stay in the hospital refers to Patient.Admission = '-'\n#SELECT: COUNT(DISTINCT Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.SEX = 'M' AND Examination.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31' AND Patient.Diagnosis = 'Behcet' AND Patient.Admission = '-'\n#SQL: SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Patient.SEX = 'M' AND Examination.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31' AND Patient.Diagnosis = 'Behcet' AND Patient.Admission = '-'\n```"
    ],
    "603": [
        "```\n#reason: The question wants to find the total number of favorites gained by a specific user in a particular year, so the SQL SELECT will sum the FavoriteCount from the posts table where the user ID matches and the creation date falls within the year 2011.\n#columns: posts.FavoriteCount, posts.CreaionDate\n#values: 'in 2011' refer to strftime('%Y', posts.CreaionDate) = '2011', 'user ID 686' refer to posts.OwnerUserId = 686\n#SELECT: SELECT SUM(posts.FavoriteCount) refer to SUM(posts.FavoriteCount)\n#SQL-like: Show SUM(posts.FavoriteCount), WHERE strftime('%Y', posts.CreaionDate) = '2011' AND posts.OwnerUserId = 686\n#SQL: SELECT SUM(posts.FavoriteCount) FROM posts WHERE strftime('%Y', posts.CreaionDate) = '2011' AND posts.OwnerUserId = 686\n```"
    ],
    "460": [
        "```\n#reason: The question wants to identify \"which artist\" designed the card with a specific promotional name, so the SQL SELECT will retrieve the artist's name based on the filtering condition of the promotional name.\n#columns: cards.artist, cards.flavorName\n#values: 'promotional name is \"Battra, Dark Destroyer\"' refer to cards.flavorName = 'Battra, Dark Destroyer'\n#SELECT: SELECT cards.artist refer to cards.artist\n#SQL-like: Show cards.artist WHERE cards.flavorName = 'Battra, Dark Destroyer'\n#SQL: SELECT cards.artist FROM cards WHERE cards.flavorName = 'Battra, Dark Destroyer'\n```"
    ],
    "1391": [
        "```\n#reason: The question wants to calculate the ratio between students majored in finance and physics, so the SQL SELECT must sum the counts of each major and divide them accordingly.\n#columns: major.major_name\n#values: 'majored in finance' refer to major.major_name = 'Finance', 'students majored in physics' refer to major.major_name = 'Physics'\n#SELECT: SELECT DIVIDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics')) refer to major.major_name.\n#SQL-like: Show DIVIDE(SUM(major_name = 'Finance'), SUM(major_name = 'Physics'))\n#SQL: SELECT CAST(SUM(CASE WHEN major_name = 'Finance' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN major_name = 'Physics' THEN 1 ELSE 0 END) FROM major\n```"
    ],
    "1455": [
        "```\n#reason: The question wants to determine which budget allowed the most money for specific items, so the SQL SELECT will focus on finding the maximum cost for the given expense description.\n#columns: budget.budget_id, expense.cost\n#values: 'expense_description is Water, chips, and cookies' refer to expense.expense_description = 'Water, cookies, chips'\n#SELECT: SELECT budget.budget_id refer to budget.budget_id\n#SQL-like: Show budget.budget_id WHERE expense.expense_description = 'Water, cookies, chips' ORDER BY expense.cost DESC LIMIT 1\n#SQL: SELECT T1.budget_id FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T2.expense_description = 'Water, cookies, chips' ORDER BY T2.cost DESC LIMIT 1\n```"
    ],
    "302": [
        "```\n#reason: The question wants to identify the elements that comprise the atoms of a specific bond, so the SQL SELECT will retrieve the elements associated with the atoms linked to the bond TR001_2_4.\n#columns: atom.element\n#values: bond_id 'TR001_2_4' refers to connected.bond_id = 'TR001_2_4'\n#SELECT: SELECT atom.element refer to atom.element\n#SQL-like: Show atom.element WHERE connected.bond_id = 'TR001_2_4'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 WHERE T2.bond_id = 'TR001_2_4'\n```"
    ],
    "785": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the names of neutral alignment superheroes\", so the SQL SELECT will retrieve the superhero_name where the alignment is 'Neutral'.\n#columns: superhero.superhero_name, alignment.alignment\n#values: neutral alignment refers to alignment.alignment = 'Neutral'\n#SELECT: names of superheroes refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE alignment.alignment = 'Neutral'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T2.alignment = 'Neutral'\n```"
    ],
    "715": [
        "```\n#reason: The question wants to list down the display names of users who have made comments with scores between 1 and 5 and have 0 down votes, so the SQL SELECT will involve filtering the comments by score and users by down votes.\n#columns: comments.UserDisplayName, users.DownVotes\n#values: score between 1 and 5 refers to comments.Score BETWEEN 1 AND 5, DownVotes = 0 refers to users.DownVotes = 0\n#SELECT: display names refer to comments.UserDisplayName\n#SQL-like: Show comments.UserDisplayName, WHERE comments.Score BETWEEN 1 AND 5 AND users.DownVotes = 0\n#SQL: SELECT comments.UserDisplayName FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Score BETWEEN 1 AND 5 AND users.DownVotes = 0\n```"
    ],
    "445": [
        "```\n#reason: The question wants to display \"the language\", \"flavor text\", and \"the type of this card\". \"colorpie watermark\" is a filtering condition.\n#columns: foreign_data.language, foreign_data.flavorText, cards.type\n#values: colorpie watermark refers to cards.watermark = 'colorpie'\n#SELECT: language refers to foreign_data.language, flavor text refers to foreign_data.flavorText, type refers to cards.type\n#SQL-like: Show foreign_data.language, foreign_data.flavorText, cards.type WHERE cards.watermark = 'colorpie'\n#SQL: SELECT T1.language, T1.flavorText, T2.type FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.watermark = 'colorpie'\n```"
    ],
    "313": [
        "```\n#reason: The question requires displaying \"How many atoms\". The molecule id TR001 is a filtering condition.\n#columns: atom.atom_id, atom.molecule_id\n#values: molecule id TR001 refer to atom.molecule_id = 'TR001'\n#SELECT: How many atoms refer to COUNT(atom.atom_id)\n#SQL-like: Show COUNT(atom.atom_id), WHERE atom.molecule_id = 'TR001'\n#SQL: SELECT COUNT(atom_id) FROM atom WHERE molecule_id = 'TR001'\n```"
    ],
    "752": [
        "```\n#reason: The question wants to display \"the name of the alien superheroes\". To achieve this, we need to filter for the race 'Alien' and select the corresponding superhero name column.\n#columns: superhero.superhero_name, race.race\n#values: race = 'Alien' refers to race.race = 'Alien'\n#SELECT: the name of superhero refers to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE race.race = 'Alien'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'\n```"
    ],
    "1028": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the away team that won the most matches during the 2010 season in the Scotland Premier League, so the SQL SELECT will gather the team names based on aggregate COUNT of the winning matches.\n#columns: Team.team_long_name\n#values: Scotland Premier League refers to League.name = 'Scotland Premier League'; away team that won the most refers to (away_team_goal > home_team_goal) and season = '2009/2010'\n#SELECT: SELECT the away team that won the most during the 2010 season refer to Team.team_long_name\n#SQL-like: Show Team.team_long_name, WHERE (party_team_goal > home_team_goal) AND League.name = 'Scotland Premier League' AND Match.season = '2009/2010', GROUP BY Match.away_team_api_id, ORDER BY COUNT(*) DESC LIMIT 1\n#SQL: SELECT T1.team_long_name FROM Match AS T2 INNER JOIN Team AS T1 ON T2.away_team_api_id = T1.team_api_id INNER JOIN League AS T3 ON T2.league_id = T3.id WHERE T3.name = 'Scotland Premier League' AND T2.season = '2009/2010' AND T2.away_team_goal > T2.home_team_goal GROUP BY T2.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1\n```"
    ],
    "732": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the publisher of the superhero with the slowest attribute value, so the SQL SELECT will include the publisher's name based on the minimum speed attribute value.\n#columns: publisher.publisher_name, hero_attribute.attribute_value\n#values: slowest superhero refers to attribute_name = 'Speed' and MIN(attribute_value) refers to MIN(hero_attribute.attribute_value)\n#SELECT: SELECT publisher.publisher_name refer to publisher.publisher_name\n#SQL-like: Show publisher.publisher_name, WHERE hero_attribute.attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed') AND hero_attribute.attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed'))\n#SQL: SELECT publisher.publisher_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE hero_attribute.attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed') AND hero_attribute.attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute WHERE attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Speed'))\n```"
    ],
    "508": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the available printing types of cards that are created by Aleksi Briclot and do not have a text box, so the SQL SELECT will include the availability column from the cards table with the specified filters.\n#columns: cards.availability\n#values: 'created by Aleksi Briclot' refer to cards.artist = 'Aleksi Briclot', 'doesn't have a text box' refer to cards.isTextless = 1\n#SELECT: available printing types refer to cards.availability\n#SQL-like: Show cards.availability, WHERE cards.artist = 'Aleksi Briclot' AND cards.isTextless = 1\n#SQL: SELECT cards.availability FROM cards WHERE cards.artist = 'Aleksi Briclot' AND cards.isTextless = 1\n```"
    ],
    "795": [
        "```\n#reason: The question wants to know the number of superheroes with a neutral alignment, so the SQL SELECT will count the superheroes where alignment_id is 3.\n#columns: superhero.id\n#values: neutral alignment refers to alignment_id = 3\n#SELECT: How many superheroes refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.alignment_id = 3\n#SQL: SELECT COUNT(id) FROM superhero WHERE alignment_id = 3\n```"
    ],
    "815": [
        "```\n#reason: The question wants to count the good female superheroes, so the SQL SELECT will count superheroes that meet the conditions of being good and female.\n#columns: superhero.id, superhero.gender_id, superhero.alignment_id\n#values: good refers to alignment.id = 1, female refers to gender.id = 2\n#SELECT: COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.gender_id = 2 AND superhero.alignment_id = 1\n#SQL: SELECT COUNT(superhero.id) FROM superhero WHERE superhero.gender_id = 2 AND superhero.alignment_id = 1\n```"
    ],
    "839": [
        "```\n#reason: The question wants to list the full name of superheroes with weight less than 100 and brown eyes, so the SQL SELECT will include superhero.full_name and apply the filtering conditions for weight and eye color.\n#columns: superhero.full_name, superhero.weight_kg, superhero.eye_colour_id, colour.id\n#values: weight less than 100 refers to superhero.weight_kg < 100, brown eyes refers to colour.id = superhero.eye_colour_id AND colour.colour = 'Brown'\n#SELECT: SELECT superhero.full_name\n#SQL-like: Show superhero.full_name, WHERE superhero.weight_kg < 100 AND superhero.eye_colour_id = (SELECT id FROM colour WHERE colour = 'Brown')\n#SQL: SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg < 100 AND T2.colour = 'Brown'\n```"
    ],
    "324": [
        "```\n#reason: The question wants to calculate the percentage of atoms that have a single bond, referring to bond_type = '-'. The percentage is calculated by dividing the count of bonds of type '-' by the total count of bonds and multiplying by 100.\n#columns: bond.bond_type, bond.bond_id\n#values: single bond refers to bond.bond_type = '-'\n#SELECT: SELECT content refers to percentage of atoms with single bond which is calculated as DIVIDE(SUM(bond_type = '-'), COUNT(bond_id)) * 100\n#SQL-like: Show DIVIDE(SUM(bond_type = '-'), COUNT(bond_id)) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) FROM bond AS T1\n```"
    ],
    "995": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"average score\" of Lewis Hamilton in the Turkish Grand Prix, so the SQL SELECT will calculate AVG(points) for the specific driver and race.\n#columns: results.points, drivers.driverId, races.raceId\n#values: 'Lewis Hamilton' refers to drivers.surname = 'Hamilton' and drivers.forename = 'Lewis', 'Turkish Grand Prix' refers to races.name = 'Turkish Grand Prix'\n#SELECT: SELECT AVG(results.points) refer to results.points\n#SQL-like: Show AVG(results.points), WHERE drivers.surname = 'Hamilton' AND drivers.forename = 'Lewis' AND races.name = 'Turkish Grand Prix'\n#SQL: SELECT AVG(T1.points) FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T2.surname = 'Hamilton' AND T2.forename = 'Lewis' AND T3.name = 'Turkish Grand Prix'\n```"
    ],
    "262": [
        "```\n#reason: The question requires identifying molecules that are not carcinogenic among those with a single bond. 'label = '-' means molecules are non-carcinogenic' is a filtering condition, and 'single bond refers to bond_type = '-'' is another filtering condition.\n#columns: molecule.molecule_id\n#values: label = '-' refer to molecule.label = '-' and bond_type = '-' refer to bond.bond_type = '-'\n#SELECT: SELECT content refer to molecule.molecule_id\n#SQL-like: Show molecule.molecule_id, WHERE molecule.label = '-' AND bond.bond_type = '-'\n#SQL: SELECT DISTINCT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' AND T2.bond_type = '-'\n```"
    ],
    "1117": [
        "```\n#reason: The question wants to display the player api id of the 10 heaviest players, so the SQL SELECT will order the weights in descending order and limit the result to the top 10 players.\n#columns: Player.player_api_id, Player.weight\n#values: none (no specific filtering conditions)\n#SELECT: player api id of 10 heaviest players refer to Player.player_api_id\n#SQL-like: Show Player.player_api_id, ORDER BY Player.weight DESC LIMIT 10\n#SQL: SELECT Player.player_api_id FROM Player ORDER BY Player.weight DESC LIMIT 10\n```"
    ],
    "418": [
        "```\n#reason: The question wants to find out the kind of printing on the card created by Daren Bader, so the SQL SELECT will retrieve the availability of the card where the artist is 'Daren Bader'.\n#columns: cards.availability\n#values: 'Daren Bader created' refer to cards.artist = 'Daren Bader'\n#SELECT: availability refer to cards.availability\n#SQL-like: Show cards.availability, WHERE cards.artist = 'Daren Bader'\n#SQL: SELECT availability FROM cards WHERE artist = 'Daren Bader'\n```"
    ],
    "375": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list down all the card IDs with a converted mana cost of 0, so the SQL SELECT will retrieve the card IDs where the converted mana cost is 0.\n#columns: cards.id\n#values: converted mana cost of 0 refers to cards.convertedManaCost = 0\n#SELECT: SELECT card IDs refer to cards.id\n#SQL-like: Show cards.id WHERE cards.convertedManaCost = 0\n#SQL: SELECT id FROM cards WHERE convertedManaCost = 0\n```"
    ],
    "1305": [
        "```\n#reason: The question wants to count the number of patients who accepted to the hospital with a normal level of white blood cells, so the SQL SELECT will count the patients where Admission is '+' and WBC is between 3.5 and 9.0.\n#columns: Patient.Admission, Laboratory.WBC\n#values: accepted to the hospital refers to Admission = '+', normal level of white blood cells refers to WBC BETWEEN 3.5 AND 9.0\n#SELECT: How many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Patient.Admission = '+' AND Laboratory.WBC BETWEEN 3.5 AND 9.0\n#SQL: SELECT COUNT(Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.Admission = '+' AND Laboratory.WBC BETWEEN 3.5 AND 9.0\n```"
    ],
    "400": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to list the set code of all cards translated into Spanish, so the SQL SELECT will extract setCode from sets where the language is Spanish from set_translations.)\n#columns: set_translations.setCode\n#values: Spanish refer to set_translations.language = 'Spanish'\n#SELECT: SELECT set_translations.setCode\n#SQL-like: Show set_translations.setCode, WHERE set_translations.language = 'Spanish'\n#SQL: SELECT set_translations.setCode FROM set_translations WHERE set_translations.language = 'Spanish'\n```"
    ],
    "1145": [
        "```\n#reason: The question wants to display the top 4 leagues that had the most games in the 2015-2016 season, so the SQL SELECT will include the League.name and group by League.id while counting the number of games to order by the most games played.\n#columns: League.name, Match.id, Match.season\n#values: in the 2015-2016 season refers to Match.season = '2015/2016'\n#SELECT: SELECT League.name refer to League.name\n#SQL-like: Show League.name, WHERE Match.season = '2015/2016', GROUP BY League.id, ORDER BY COUNT(Match.id) DESC LIMIT 4\n#SQL: SELECT T1.name FROM League AS T1 INNER JOIN Match AS T2 ON T1.id = T2.league_id WHERE T2.season = '2015/2016' GROUP BY T1.id ORDER BY COUNT(T2.id) DESC LIMIT 4\n```"
    ],
    "1291": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count male patients who have a normal level of both albumin and total protein, so the SQL SELECT will count distinct Patient.ID and apply the necessary filters for sex and laboratory values.\n#columns: Patient.ID, Laboratory.ALB, Laboratory.TP\n#values: male refers to Patient.SEX = 'M'; normal level of albumin refers to Laboratory.ALB > 3.5 AND Laboratory.ALB < 5.5; normal level of total protein refers to Laboratory.TP > 6.0 AND Laboratory.TP < 8.5\n#SELECT: How many male patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.SEX = 'M' AND Laboratory.ALB > 3.5 AND Laboratory.ALB < 5.5 AND Laboratory.TP > 6.0 AND Laboratory.TP < 8.5\n#SQL: SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.SEX = 'M' AND Laboratory.ALB > 3.5 AND Laboratory.ALB < 5.5 AND Laboratory.TP > 6.0 AND Laboratory.TP < 8.5\n```"
    ],
    "962": [
        "```\n#reason: The question wants to calculate the percentage of drivers who were born before 1985 and had lap numbers over 50 during the years 2000 to 2005. The SQL SELECT statement will count the number of drivers meeting the criteria and divide it by the total number of drivers in the specified years, multiplying by 100 to get the percentage.\n#columns: drivers.dob, lapTimes.lap, races.year, lapTimes.driverId\n#values: 'born before 1985' refers to year(dob) < 1985, 'in 2000 to 2005' refers to races.year BETWEEN 2000 AND 2005\n#SELECT: SELECT (CAST(COUNT(T1.driverId) AS REAL) * 100 / COUNT(T2.driverId)) \n#SQL-like: Show (CAST(COUNT(driverId WHERE year(dob) < 1985 AND lap > 50) AS REAL) * 100 / COUNT(driverId WHERE year BETWEEN 2000 AND 2005))\n#SQL: SELECT CAST(COUNT(CASE WHEN strftime('%Y', T1.dob) < '1985' AND T2.lap > 50 THEN 1 END) AS REAL) * 100 / COUNT(T2.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.year BETWEEN 2000 AND 2005\n```"
    ],
    "1500": [
        "```\n#reason: The question wants to list the product descriptions of the products consumed in September 2013, so the SQL SELECT will query the product description based on the conditions related to consumption date.\n#columns: products.Description\n#values: September 2013 refers to yearmonth.Date = '201309'\n#SELECT: SELECT products.Description refer to products.Description\n#SQL-like: Show products.Description, WHERE yearmonth.Date = '201309'\n#SQL: SELECT products.Description FROM products INNER JOIN yearmonth ON products.ProductID = yearmonth.CustomerID WHERE yearmonth.Date = '201309'\n```"
    ],
    "973": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the top 10 Spanish drivers who were born before 1982 and have the latest lap time, so the SQL SELECT will include the driver's details and filter based on their nationality and date of birth, while also considering the maximum lap time.\n#columns: drivers.forename, drivers.surname, drivers.dob, lapTimes.time\n#values: born before 1982 refers to year(dob) < 1982; top 10 Spanish drivers refers to drivers.nationality = 'Spanish'\n#SELECT: SELECT top 10 Spanish drivers refer to drivers.forename, drivers.surname, drivers.dob; latest lap time refers to MAX(lapTimes.time)\n#SQL-like: Show drivers.forename, drivers.surname, drivers.dob, WHERE year(dob) < 1982 AND drivers.nationality = 'Spanish' ORDER BY lapTimes.time DESC LIMIT 10\n#SQL: SELECT T1.forename, T1.surname, T1.dob FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE year(T1.dob) < 1982 AND T1.nationality = 'Spanish' ORDER BY T2.time DESC LIMIT 10\n```"
    ],
    "252": [
        "```\n#reason: The question wants to find atoms that can bond with the atom that has the element lead, so the SQL SELECT will retrieve the connected atoms based on the bond relationships.\n#columns: connected.atom_id2\n#values: atom that has the element lead refers to atom.atom_id where atom.element = 'pb'\n#SELECT: SELECT connected.atom_id2 refer to connected.atom_id2\n#SQL-like: Show connected.atom_id2, WHERE connected.atom_id IN (SELECT atom_id FROM atom WHERE element = 'pb')\n#SQL: SELECT connected.atom_id2 FROM connected INNER JOIN atom ON connected.atom_id = atom.atom_id WHERE atom.element = 'pb'\n```"
    ],
    "1030": [
        "```\n#reason: The question wants to identify the league with the most matches ending in a draw during the 2016 season, so the SQL SELECT statement will sum occurrences where the home team goal equals the away team goal and group the results by league.\n#columns: League.name, Match.home_team_goal, Match.away_team_goal, Match.season\n#values: '2016 season' refers to Match.season = '2015/2016'\n#SELECT: SELECT League.name refer to League.name\n#SQL-like: Show League.name, WHERE Match.season = '2015/2016', GROUP BY League.name, ORDER BY SUM(Match.home_team_goal = Match.away_team_goal) DESC LIMIT 1\n#SQL: SELECT L.name FROM League AS L INNER JOIN Match AS M ON L.id = M.league_id WHERE M.season = '2015/2016' GROUP BY L.name ORDER BY SUM(M.home_team_goal = M.away_team_goal) DESC LIMIT 1\n```"
    ],
    "398": [
        "```\n#reason: The question wants to find the total cost of unconverted mana for all cards created by Rob Alexander, so the SQL SELECT will sum the manaCost for cards where the artist is Rob Alexander.\n#columns: cards.manaCost\n#values: 'Rob Alexander' refer to cards.artist = 'Rob Alexander'\n#SELECT: total cost of unconverted mana refer to SUM(cards.manaCost)\n#SQL-like: Show SUM(cards.manaCost), WHERE cards.artist = 'Rob Alexander'\n#SQL: SELECT SUM(cards.manaCost) FROM cards WHERE cards.artist = 'Rob Alexander'\n```"
    ],
    "927": [
        "```\n#reason: The question wants to display the \"driver\" who created the \"fastest lap speed\" in a Formula 1 race, so the SQL SELECT will include the driver's forename and surname along with the fastest lap speed.\n#columns: drivers.forename, drivers.surname, results.fastestLapSpeed\n#values: fastest lap speed refers to the maximum value of results.fastestLapSpeed\n#SELECT: SELECT drivers.forename, drivers.surname WHERE results.fastestLapSpeed = MAX(results.fastestLapSpeed)\n#SQL-like: Show drivers.forename, drivers.surname WHERE results.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)\n#SQL: SELECT drivers.forename, drivers.surname FROM drivers INNER JOIN results ON drivers.driverId = results.driverId WHERE results.fastestLapSpeed = (SELECT MAX(fastestLapSpeed) FROM results)\n```"
    ],
    "759": [
        "```\n#reason: The question wants to display the \"eye colour\" of the \"heaviest superhero\". \"Heaviest superhero\" refers to MAX(weight_kg), and \"eye colour\" corresponds to the colour where eye_colour_id = colour.id.\n#columns: colour.colour, superhero.weight_kg\n#values: the heaviest superhero refers to superhero.weight_kg = (SELECT MAX(weight_kg) FROM superhero)\n#SELECT: eye colour refers to colour.colour\n#SQL-like: Show colour.colour, WHERE superhero.weight_kg = (SELECT MAX(weight_kg) FROM superhero)\n#SQL: SELECT T1.colour FROM colour AS T1 INNER JOIN superhero AS T2 ON T2.eye_colour_id = T1.id WHERE T2.weight_kg = (SELECT MAX(weight_kg) FROM superhero)\n```"
    ],
    "534": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"display name of the user\" who has the \"most number of views\", so the SQL SELECT will focus on the user display name and order by the views in descending order.\n#columns: users.DisplayName, users.Views\n#values: most number of views refers to Max(Views)\n#SELECT: display name of the user refer to users.DisplayName\n#SQL-like: Show users.DisplayName, ORDER BY users.Views DESC LIMIT 1\n#SQL: SELECT users.DisplayName FROM users ORDER BY users.Views DESC LIMIT 1\n```"
    ],
    "757": [
        "```\n#reason: The question wants to identify the race of the superhero who weighed 169 kg, so the SQL SELECT will retrieve the race based on the filter of weight_kg being 169.\n#columns: race.race, superhero.weight_kg\n#values: 'weighed 169 kg' refer to superhero.weight_kg = 169\n#SELECT: SELECT race.race refer to race.race\n#SQL-like: Show race.race WHERE superhero.weight_kg = 169\n#SQL: SELECT T1.race FROM race AS T1 INNER JOIN superhero AS T2 ON T1.id = T2.race_id WHERE T2.weight_kg = 169\n```"
    ],
    "647": [
        "```\n#reason: The question wants to provide the badge names received in 2011 for the user whose location is in the North Pole, so the SQL SELECT will filter by the year of the badge date and the user's location.\n#columns: badges.Name, badges.Date, users.Location\n#values: 'in 2011' refer to strftime('%Y', badges.Date) = '2011', 'location is in the North Pole' refer to users.Location = 'North Pole'\n#SELECT: SELECT badges.Name refer to badges.Name\n#SQL-like: Show badges.Name WHERE strftime('%Y', badges.Date) = '2011' AND users.Location = 'North Pole'\n#SQL: SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE strftime('%Y', badges.Date) = '2011' AND users.Location = 'North Pole'\n```"
    ],
    "942": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the average fastest lap time in seconds for Lewis Hamilton across all Formula 1 races, so the SQL SELECT will include the average of the fastest lap times and convert them to seconds.\n#columns: results.fastestLapTime, drivers.driverRef\n#values: 'Lewis Hamilton' refers to drivers.driverRef = 'hamilton'\n#SELECT: average fastest lap time in seconds refers to AVG(STRFTIME('%s', results.fastestLapTime)) \n#SQL-like: Show AVG(STRFTIME('%s', results.fastestLapTime)), WHERE drivers.driverRef = 'hamilton'\n#SQL: SELECT AVG(STRFTIME('%s', T1.fastestLapTime)) FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.driverRef = 'hamilton'\n```"
    ],
    "1244": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all patients who first came to the hospital after year 1992 with prothrombin time (PT) level that are normal, so the SQL SELECT will include the patient details and apply the necessary filters.\n#columns: Patient.ID, Patient.First Date, Laboratory.PT\n#values: first came to the hospital after year 1992 refers to strftime('%Y', Patient.`First Date`) > '1992', prothrombin time (PT) level that are normal refers to Laboratory.PT < 14\n#SELECT: SELECT content refers to Patient.ID, Patient.`First Date`, Laboratory.PT\n#SQL-like: Show Patient.ID, Patient.`First Date`, Laboratory.PT, WHERE strftime('%Y', Patient.`First Date`) > '1992' AND Laboratory.PT < 14\n#SQL: SELECT Patient.ID, Patient.`First Date`, Laboratory.PT FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', Patient.`First Date`) > '1992' AND Laboratory.PT < 14\n```"
    ],
    "970": [
        "```\n#reason: The question requires displaying the \"top 3 German drivers\" who \"were born from 1980-1990\" and have the \"earliest lap time\". \"born from 1980-1990\" refers to year(dob) between 1980 and 1990, and \"earliest lap time\" refers to Min(time).\n#columns: drivers.forename, drivers.surname, drivers.dob, lapTimes.time\n#values: year(dob) between 1980 and 1990 refers to STRFTIME('%Y', drivers.dob) BETWEEN '1980' AND '1990'\n#SELECT: top 3 German drivers refers to drivers.forename, drivers.surname, drivers.dob; earliest lap time refers to Min(lapTimes.time)\n#SQL-like: Show drivers.forename, drivers.surname, drivers.dob, WHERE STRFTIME('%Y', drivers.dob) BETWEEN '1980' AND '1990', ORDER BY lapTimes.time ASC LIMIT 3\n#SQL: SELECT T1.forename, T1.surname, T1.dob FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE STRFTIME('%Y', T1.dob) BETWEEN '1980' AND '1990' ORDER BY T2.time ASC LIMIT 3\n```"
    ],
    "429": [
        "```\n#reason: The question requires displaying \"language\" and \"expansion type\" for \"set number 206\". \"set number 206\" is a filtering condition with id = 206.\n#columns: set_translations.language, sets.type\n#values: set number 206 refers to sets.id = 206\n#SELECT: language and expansion type refer to set_translations.language, sets.type\n#SQL-like: Show set_translations.language, sets.type WHERE sets.id = 206\n#SQL: SELECT T1.language, T2.type FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.id = 206\n```"
    ],
    "246": [
        "```\n#reason: The question wants to list the bond type and bond ID of the atom 45, so the SQL SELECT will include the bond type from the bond table and the bond ID based on a condition on the atom_id.\n#columns: bond.bond_type, bond.bond_id\n#values: bond ID of atom 45 refer to SUBSTR(atom_id, 7, 2) + 0 = 45\n#SELECT: bond type and bond ID refer to bond.bond_type, bond.bond_id\n#SQL-like: Show bond.bond_type, bond.bond_id WHERE SUBSTR(atom_id, 7, 2) + 0 = 45\n#SQL: SELECT T1.bond_type, T1.bond_id FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE SUBSTR(T2.atom_id, 7, 2) + 0 = 45\n```"
    ],
    "1302": [
        "```\n#reason: The question wants to find out the count of patients with a normal range of creatinine phosphokinase and a positive measure of degree of coagulation, so the SQL SELECT COUNT(Patient.ID) will count patients that meet these criteria.\n#columns: Patient.ID, Laboratory.CPK, Examination.KCT, Examination.RVVT, Examination.LAC\n#values: normal range of creatinine phosphokinase refers to CPK < 250; positive measure of degree of coagulation refers to KCT = '+' or RVVT = '+' or LAC = '+'\n#SELECT: COUNT(Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(Patient.ID) WHERE Laboratory.CPK < 250 AND (Examination.KCT = '+' OR Examination.RVVT = '+' OR Examination.LAC = '+')\n#SQL: SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.CPK < 250 AND (T3.KCT = '+' OR T3.RVVT = '+' OR T3.LAC = '+')\n```"
    ],
    "704": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question asks for the excerpt post ID and wiki post ID of the tag named sample, which requires filtering on the tag's name.\n#columns: tags.ExcerptPostId, tags.WikiPostId\n#values: TagName = 'sample' refers to tags.TagName = 'sample'\n#SELECT: excerpt post ID and wiki post ID refers to tags.ExcerptPostId, tags.WikiPostId\n#SQL-like: Show tags.ExcerptPostId, tags.WikiPostId WHERE tags.TagName = 'sample'\n#SQL: SELECT tags.ExcerptPostId, tags.WikiPostId FROM tags WHERE tags.TagName = 'sample'\n```"
    ],
    "573": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the contents of comments with a specific score, so the SQL SELECT will retrieve the Text column from the comments table where the Score equals 17.\n#columns: comments.Text\n#values: score of 17 refers to Score = 17\n#SELECT: contents of comments refers to comments.Text\n#SQL-like: Show comments.Text WHERE Score = 17\n#SQL: SELECT Text FROM comments WHERE Score = 17\n```"
    ],
    "827": [
        "```\n#reason: The question wants to calculate the average height of a non-human superhero in Dark Horse Comics, so the SQL SELECT will calculate AVG(height_cm) where race <> 'Human' and publisher_name = 'Dark Horse Comics'.\n#columns: superhero.height_cm, publisher.publisher_name, race.race\n#values: 'non-human superhero' refers to race.race <> 'Human', 'Dark Horse Comics' refers to publisher.publisher_name = 'Dark Horse Comics'\n#SELECT: average height refers to AVG(superhero.height_cm)\n#SQL-like: Show AVG(superhero.height_cm) WHERE race.race <> 'Human' AND publisher.publisher_name = 'Dark Horse Comics'\n#SQL: SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T3.race <> 'Human' AND T2.publisher_name = 'Dark Horse Comics'\n```"
    ],
    "226": [
        "```\n#reason: The question want to calculate the percentage of double bonds in the molecule TR008, so the SQL SELECT counts the occurrence of double bonds and divides by the total count of bonds in the molecule.\n#columns: bond.bond_type, bond.bond_id, bond.molecule_id\n#values: double bond refers to bond_type = '=', TR008 refers to bond.molecule_id = 'TR008'\n#SELECT: percentage of double bonds refer to DIVIDE(SUM(bond_type = '='), COUNT(bond_id)) as percent\n#SQL-like: Show DIVIDE(SUM(bond_type = '='), COUNT(bond_id)), WHERE molecule_id = 'TR008'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.bond_type = '=' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) as percent FROM bond AS T1 WHERE T1.molecule_id = 'TR008'\n```"
    ],
    "833": [
        "```\n#reason: The question wants to find the superhero associated with the full name 'Charles Chandler', so the SQL SELECT will return the superhero_name based on the condition for full_name.\n#columns: superhero.superhero_name, superhero.full_name\n#values: 'Charles Chandler' refer to superhero.full_name = 'Charles Chandler'\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name WHERE superhero.full_name = 'Charles Chandler'\n#SQL: SELECT superhero.superhero_name FROM superhero WHERE superhero.full_name = 'Charles Chandler'\n```"
    ],
    "1073": [
        "```\n#reason: The question wants to know the total number of matches held in the league Germany 1. Bundesliga from August to October 2008, so the SQL SELECT will count the matches filtered by the league name and date range.\n#columns: Match.id, League.name, Match.date\n#values: Germany 1. Bundesliga refers to League.name = 'Germany 1. Bundesliga'; from August to October 2008 refers to strftime('%Y-%m', Match.date) BETWEEN '2008-08' AND '2008-10'\n#SELECT: COUNT(Match.id) refer to Match.id\n#SQL-like: Show COUNT(Match.id), WHERE League.name = 'Germany 1. Bundesliga' AND strftime('%Y-%m', Match.date) BETWEEN '2008-08' AND '2008-10'\n#SQL: SELECT COUNT(M.id) FROM Match AS M INNER JOIN League AS L ON M.league_id = L.id WHERE L.name = 'Germany 1. Bundesliga' AND strftime('%Y-%m', M.date) BETWEEN '2008-08' AND '2008-10'\n```"
    ],
    "466": [
        "```\n#reason: The question wants to count the number of cards designed by Adam Rex in the set \"Hauptset Zehnte Edition\", so the SQL SELECT will count the distinct card IDs and filter by the specified artist and translation.\n#columns: cards.id, set_translations.translation, cards.artist\n#values: 'Hauptset Zehnte Edition' refer to set_translations.translation = 'Hauptset Zehnte Edition', 'Adam Rex' refer to cards.artist = 'Adam Rex'\n#SELECT: SELECT COUNT(DISTINCT cards.id) refer to cards.id\n#SQL-like: Show COUNT(DISTINCT cards.id), WHERE set_translations.translation = 'Hauptset Zehnte Edition' AND cards.artist = 'Adam Rex'\n#SQL: SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'\n```"
    ],
    "228": [
        "```\n#reason: The question wants to calculate the percentage of hydrogen atoms in molecule TR206, so the SQL SELECT will sum the hydrogen atoms and divide by the total number of atoms in that molecule, filtering by molecule_id = 'TR206'.\n#columns: atom.element, atom.atom_id, atom.molecule_id\n#values: 'hydrogen' refers to atom.element = 'h', 'TR206' refers to atom.molecule_id = 'TR206'\n#SELECT: percentage of hydrogen in molecule TR206 refers to (SUM(element = 'h') / COUNT(atom_id)) * 100\n#SQL-like: Show (SUM(element = 'h') / COUNT(atom_id)) * 100, WHERE atom.molecule_id = 'TR206'\n#SQL: SELECT CAST(SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(atom_id) FROM atom WHERE molecule_id = 'TR206'\n```"
    ],
    "402": [
        "```\n#reason: The question wants to calculate the percentage of Story Spotlight cards that do not have a text box, so the SQL SELECT will calculate the percentage using the specified conditions and list the IDs of the cards at the same time.\n#columns: cards.id, cards.isStorySpotlight, cards.isTextless\n#values: Story Spotlight cards that do not have a text box refers to cards.isStorySpotlight = 1 AND cards.isTextless = 0\n#SELECT: percentage of Story Spotlight cards that do not have a text box refer to (SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) / COUNT(id)) * 100, List their ID refer to cards.id\n#SQL-like: Show (SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) * 100 / COUNT(id)) WHERE isStorySpotlight = 1 AND isTextless = 0, List them by their ID\n#SQL: SELECT CAST(SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id), id FROM cards WHERE isStorySpotlight = 1 AND isTextless = 0\n```"
    ],
    "1359": [
        "```\n#reason: The question requires calculating how many times the budget amount for the \"Yearly Kickoff\" meeting is more than that for the \"October Meeting.\" The components for this are defined by dividing the sum of the budget amounts filtered by each event name. The SQL SELECT clause sums the budget amounts for each respective event and applies the proper filtering conditions.\n#columns: budget.amount, event.event_name, budget.category\n#values: 'Advertisement' refer to budget.category = 'Advertisement', 'Yearly Kickoff' refer to event.event_name = 'Yearly Kickoff', 'October Meeting' refer to event.event_name = 'October Meeting'\n#SELECT: number of times more in budget refers to DIVIDE(SUM(amount when event_name = 'Yearly Kickoff'), SUM(amount when event_name = 'October Meeting'))\n#SQL-like: Show DIVIDE(SUM(budget.amount WHERE event.event_name = 'Yearly Kickoff' AND budget.category = 'Advertisement'), SUM(budget.amount WHERE event.event_name = 'October Meeting' AND budget.category = 'Advertisement'))\n#SQL: SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement'\n```"
    ],
    "444": [
        "```\n#reason: The question wants to display the foreign name of the card and its type, so the SQL SELECT will include foreign_data.name and cards.type with a filtering condition on the watermark.\n#columns: foreign_data.name, cards.type\n#values: boros watermark refers to cards.watermark = 'boros'\n#SELECT: foreign name of the card, type of this card refer to foreign_data.name, cards.type\n#SQL-like: Show foreign_data.name, cards.type WHERE cards.watermark = 'boros'\n#SQL: SELECT foreign_data.name, cards.type FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.watermark = 'boros'\n```"
    ],
    "1520": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the spending and date for a customer who paid 124.05 on 2012/8/24, filtering them by the January of 2012, so the SQL SELECT will gather the date and consumption amount for those criteria.\n#columns: transactions_1k.Date, yearmonth.Consumption\n#values: 'paid 124.05' refer to transactions_1k.Price = 124.05 AND 'on 2012-08-24' refer to transactions_1k.Date = '2012-08-24' AND 'during January of 2012' refer to yearmonth.Date = '201201'\n#SELECT: SELECT the expenditure date and total consumption refer to transactions_1k.Date, yearmonth.Consumption\n#SQL-like: Show transactions_1k.Date, yearmonth.Consumption, WHERE transactions_1k.Price = 124.05 AND transactions_1k.Date = '2012-08-24' AND yearmonth.Date = '201201'\n#SQL: SELECT T1.Date, T2.Consumption FROM transactions_1k AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price = 124.05 AND T1.Date = '2012-08-24' AND T2.Date = '201201'\n```"
    ],
    "618": [
        "```\n#reason: The question wants to list out the age of users who are located in Vienna, Austria and obtained the badge. \"Vienna, Austria\" is the filtering condition. \n#columns: users.Age, users.Location, badges.UserId\n#values: 'Vienna, Austria' refer to users.Location = 'Vienna, Austria'\n#SELECT: age of users refer to users.Age\n#SQL-like: Show users.Age, WHERE users.Location = 'Vienna, Austria'\n#SQL: SELECT U.Age FROM users AS U INNER JOIN badges AS B ON U.Id = B.UserId WHERE U.Location = 'Vienna, Austria'\n```"
    ],
    "604": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the average of up votes and the average user age for users who have created more than 10 posts, so the SQL SELECT will include the averages calculated from the respective columns and will filter users based on their post count.\n#columns: users.UpVotes, users.Age, posts.OwnerUserId\n#values: creating more than 10 posts refers to Count(posts.OwnerUserId) > 10\n#SELECT: average of the up votes refers to CAST(SUM(users.UpVotes) AS REAL) / COUNT(users.Id), average user age refers to CAST(SUM(users.Age) AS REAL) / COUNT(users.Id)\n#SQL-like: Show CAST(SUM(users.UpVotes) AS REAL) / COUNT(users.Id), CAST(SUM(users.Age) AS REAL) / COUNT(users.Id), WHERE Count(posts.OwnerUserId) > 10 GROUP BY users.Id\n#SQL: SELECT CAST(SUM(users.UpVotes) AS REAL) / COUNT(users.Id), CAST(SUM(users.Age) AS REAL) / COUNT(users.Id) FROM users INNER JOIN posts ON users.Id = posts.OwnerUserId GROUP BY users.Id HAVING COUNT(posts.OwnerUserId) > 10\n```"
    ],
    "832": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the tallest superhero, so the SQL SELECT will retrieve the superhero's name based on the maximum height.\n#columns: superhero.superhero_name, superhero.height_cm\n#values: tallest superhero refers to MAX(height_cm)\n#SELECT: Name the tallest superhero refers to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, ORDER BY superhero.height_cm DESC LIMIT 1\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 ORDER BY T1.height_cm DESC LIMIT 1\n```"
    ],
    "1379": [
        "```\n#reason: The question wants to count the number of meeting events held in the year 2020, so the SQL SELECT COUNT(*) and applies filtering for event type and event date.\n#columns: event.type, event.event_date\n#values: 'meeting events' refer to event.type = 'Meeting', 'held in 2020' refer to strftime('%Y', event.event_date) = '2020'\n#SELECT: COUNT(*) refer to event.event_id\n#SQL-like: Show COUNT(*), WHERE event.type = 'Meeting' AND strftime('%Y', event.event_date) = '2020'\n#SQL: SELECT COUNT(event.event_id) FROM event WHERE event.type = 'Meeting' AND strftime('%Y', event.event_date) = '2020'\n```"
    ],
    "1096": [
        "```\n#reason: The question wants to calculate the \"average overall rating\" of \"Pietro Marino\". The average overall rating is defined as AVG(T1.overall_rating), and \"Pietro Marino\" is the filtering condition.\n#columns: Player_Attributes.overall_rating, Player.player_name\n#values: 'Pietro Marino' refer to Player.player_name = 'Pietro Marino'\n#SELECT: SELECT AVG(T1.overall_rating) refer to Player_Attributes.overall_rating\n#SQL-like: Show AVG(Player_Attributes.overall_rating), WHERE Player.player_name = 'Pietro Marino'\n#SQL: SELECT AVG(T1.overall_rating) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Pietro Marino'\n```"
    ],
    "233": [
        "```\n#reason: The question wants to list the top two bonds associated with the molecule TR006 in alphabetical order, so the SQL SELECT will retrieve the bond IDs for the specified molecule and limit the results to two, with an order clause to sort them alphabetically.\n#columns: bond.bond_id\n#values: TR006 refer to bond.molecule_id = 'TR006'\n#SELECT: SELECT bond.bond_id refer to bond.bond_id\n#SQL-like: Show bond.bond_id WHERE bond.molecule_id = 'TR006' ORDER BY bond.bond_id ASC LIMIT 2\n#SQL: SELECT bond.bond_id FROM bond WHERE bond.molecule_id = 'TR006' ORDER BY bond.bond_id ASC LIMIT 2\n```"
    ],
    "393": [
        "```\n#reason: The question wants to count the number of cards designed by John Avon that are non-powerful foils, so the SQL SELECT COUNT(*) and the filtering conditions are based on the artist and the conditions for foil cards.\n#columns: cards.id\n#values: 'John Avon' refers to cards.artist = 'John Avon' AND cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NULL\n#SELECT: COUNT(*) refer to cards.id\n#SQL-like: Show COUNT(*), WHERE cards.artist = 'John Avon' AND cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NULL\n#SQL: SELECT COUNT(*) FROM cards WHERE cards.artist = 'John Avon' AND cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NULL\n```"
    ],
    "646": [
        "```\n#reason: The question wants to describe the post title which got positive comments and display names of the users who posted those comments, so the SQL SELECT will include the post title and user display names where the comment score is greater than 60.\n#columns: posts.Title, users.DisplayName\n#values: positive comments refer to comments.Score > 60\n#SELECT: SELECT posts.Title, users.DisplayName\n#SQL-like: Show posts.Title, users.DisplayName WHERE comments.Score > 60\n#SQL: SELECT T1.Title, T2.DisplayName FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.Score > 60\n```"
    ],
    "848": [
        "```\n#reason: The question wants to list the year during which the race is held on circuits in Shanghai, so the SQL SELECT will retrieve the unique years from the races associated with the Shanghai circuit.\n#columns: races.year\n#values: 'Shanghai' refers to 'circuits.location = \"Shanghai\"'\n#SELECT: 'year' refers to races.year\n#SQL-like: Show DISTINCT races.year, WHERE circuits.location = 'Shanghai'\n#SQL: SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.location = 'Shanghai'\n```"
    ],
    "636": [
        "```\n#reason: The question wants to count the number of negative comments on Neil McGuigan's posts, so the SQL SELECT will count comments where the score is less than 60 and the user display name is 'Neil McGuigan'.\n#columns: comments.Score, comments.UserId, posts.OwnerUserId\n#values: negative comments refer to comments.Score < 60, 'Neil McGuigan' refer to users.DisplayName = 'Neil McGuigan'\n#SELECT: How many negative comments refer to COUNT(comments.Score)\n#SQL-like: Show COUNT(comments.Score), WHERE comments.Score < 60 AND posts.OwnerUserId IN (SELECT users.Id FROM users WHERE users.DisplayName = 'Neil McGuigan')\n#SQL: SELECT COUNT(comments.Score) FROM comments INNER JOIN posts ON comments.PostId = posts.Id INNER JOIN users ON posts.OwnerUserId = users.Id WHERE comments.Score < 60 AND users.DisplayName = 'Neil McGuigan'\n```"
    ],
    "382": [
        "```\n#reason: The question wants to display the cards that are only available in paper and in Japanese language, so the SQL SELECT will filter based on availability and language.\n#columns: cards.availability, foreign_data.language, cards.name\n#values: 'available in paper' refer to cards.availability = 'paper', 'Japanese is the language' refer to foreign_data.language = 'Japanese'\n#SELECT: SELECT cards.name refer to cards.name\n#SQL-like: Show cards.name, WHERE cards.availability = 'paper' AND foreign_data.language = 'Japanese'\n#SQL: SELECT cards.name FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.availability = 'paper' AND foreign_data.language = 'Japanese'\n```"
    ],
    "629": [
        "```\n#reason: The question wants to calculate the ratio of votes between the years 2010 and 2011, so the SQL SELECT will perform a count of the votes for each year and divide them.\n#columns: votes.Id, votes.CreationDate\n#values: 'in 2010' refers to strftime('%Y', CreationDate) = '2010', 'in 2011' refers to strftime('%Y', CreationDate) = '2011'\n#SELECT: SELECT CAST(COUNT(CASE WHEN strftime('%Y', CreationDate) = '2010' THEN Id END) AS REAL) / COUNT(CASE WHEN strftime('%Y', CreationDate) = '2011' THEN Id END) refer to votes.Id\n#SQL-like: Show CAST(COUNT(CASE WHEN strftime('%Y', CreationDate) = '2010' THEN Id END) AS REAL) / COUNT(CASE WHEN strftime('%Y', CreationDate) = '2011' THEN Id END)\n#SQL: SELECT CAST(COUNT(CASE WHEN strftime('%Y', CreationDate) = '2010' THEN Id END) AS REAL) / COUNT(CASE WHEN strftime('%Y', CreationDate) = '2011' THEN Id END) FROM votes\n```"
    ],
    "1006": [
        "```\n#reason: The question wants to find the time for the fastest lap record, so the SQL SELECT will focus on the minimum lap time.\n#columns: lapTimes.time\n#values: fastest lap refers to MIN(lapTimes.time)\n#SELECT: SELECT MIN(time) refer to lapTimes.time\n#SQL-like: Show MIN(lapTimes.time)\n#SQL: SELECT MIN(time) FROM lapTimes\n```"
    ],
    "354": [
        "```\n#reason: The question requires displaying the count of distinct card types illustrated by \"Aaron Boyd\". \"Aaron Boyd\" is the filtering condition for the artist's name.\n#columns: cards.artist, cards.type\n#values: 'Aaron Boyd' refer to cards.artist = 'Aaron Boyd'\n#SELECT: COUNT(DISTINCT cards.type) refer to COUNT(DISTINCT cards.type)\n#SQL-like: Show COUNT(DISTINCT cards.type), WHERE cards.artist = 'Aaron Boyd'\n#SQL: SELECT COUNT(DISTINCT T1.type) FROM cards AS T1 WHERE T1.artist = 'Aaron Boyd'\n```"
    ],
    "736": [
        "```\n#reason: The question wants to identify the superhero with the lowest intelligence attribute, so the SQL SELECT will target MIN(attribute_value) where attribute_name = 'Intelligence'.\n#columns: superhero.full_name, hero_attribute.attribute_value\n#values: 'attribute_name is Intelligence' refer to attribute.attribute_name = 'Intelligence'\n#SELECT: SELECT superhero.full_name, hero_attribute.attribute_value refer to superhero.full_name, hero_attribute.attribute_value\n#SQL-like: Show superhero.full_name, hero_attribute.attribute_value WHERE attribute.attribute_name = 'Intelligence' ORDER BY hero_attribute.attribute_value LIMIT 1\n#SQL: SELECT T1.full_name, T2.attribute_value FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Intelligence' ORDER BY T2.attribute_value ASC LIMIT 1\n```"
    ],
    "1235": [
        "```\n#reason: The question wants to find the diagnosis of patients who have lower red blood cells, so the SQL SELECT will gather the Diagnosis and ID of patients along with their age calculated from their birthday.\n#columns: Patient.Diagnosis, Patient.ID, Patient.Birthday\n#values: lower red blood cell refers to RBC < 3.5, age refers to SUBTRACT(year(current_timestamp), year(Birthday))\n#SELECT: SELECT Patient.Diagnosis, Patient.ID, SUBTRACT(strftime('%Y', 'now'), strftime('%Y', Patient.Birthday)) AS age\n#SQL-like: Show Patient.Diagnosis, Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday)), WHERE RBC < 3.5\n#SQL: SELECT Patient.Diagnosis, Patient.ID, (strftime('%Y', 'now') - strftime('%Y', Patient.Birthday)) AS age FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.RBC < 3.5\n```"
    ],
    "1052": [
        "```\n#reason: The question wants to determine the number of players whose weight is under 130 and who have a preferred foot of 'left' in attacking. So the SQL SELECT will count the players based on these conditions.\n#columns: Player.weight, Player_Attributes.preferred_foot\n#values: weight < 130 refer to Player.weight < 130, preferred foot in attacking refer to Player_Attributes.preferred_foot = 'left'\n#SELECT: COUNT(Player.id) refer to COUNT(Player.id)\n#SQL-like: Show COUNT(Player.id), WHERE Player.weight < 130 AND Player_Attributes.preferred_foot = 'left'\n#SQL: SELECT COUNT(T1.id) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.weight < 130 AND T2.preferred_foot = 'left'\n```"
    ],
    "836": [
        "```\n#reason: The question requires counting the total number of superheroes with \"John\" as their first name, which translates to filtering by full_name LIKE 'John%'.\n#columns: superhero.full_name\n#values: 'have John as their first name' refers to superhero.full_name LIKE 'John%'\n#SELECT: SELECT COUNT(*) refer to superhero.full_name\n#SQL-like: Show COUNT(*), WHERE superhero.full_name LIKE 'John%'\n#SQL: SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%'\n```"
    ],
    "916": [
        "```\n#reason: The question requires displaying the surnames of all the Italian drivers. \"Italian\" refers to the nationality filter.\n#columns: drivers.surname\n#values: Italian refers to drivers.nationality = 'Italian'\n#SELECT: surnames refer to drivers.surname\n#SQL-like: Show drivers.surname WHERE drivers.nationality = 'Italian'\n#SQL: SELECT T1.surname FROM drivers AS T1 WHERE T1.nationality = 'Italian'\n```"
    ],
    "1437": [
        "```\n#reason: The question wants to identify members who were approved and attended events within a specific date range, so the SQL SELECT will include the member's details and the event link.\n#columns: member.first_name, member.last_name, attendance.link_to_event\n#values: approved from 1/10/2019 to 11/19/2019 refers to expense.approved = 'true' AND expense.expense_date BETWEEN '2019-01-10' AND '2019-11-19'\n#SELECT: SELECT member.first_name, member.last_name, attendance.link_to_event\n#SQL-like: Show member.first_name, member.last_name, attendance.link_to_event, WHERE expense.approved = 'true' AND expense.expense_date BETWEEN '2019-01-10' AND '2019-11-19'\n#SQL: SELECT T1.first_name, T1.last_name, T2.link_to_event FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.approved = 'true' AND T2.expense_date BETWEEN '2019-01-10' AND '2019-11-19'\n```"
    ],
    "786": [
        "```\n#reason: The question wants to find the count of heroes that have the highest attribute value in strength, so the SQL should find the maximum attribute_value for strength and then count the heroes with that value.\n#columns: hero_attribute.hero_id\n#values: highest attribute value in strength refers to hero_attribute.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength')\n#SELECT: COUNT(hero_attribute.hero_id) refer to hero_attribute.hero_id\n#SQL-like: Show COUNT(hero_attribute.hero_id) WHERE hero_attribute.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength')\n#SQL: SELECT COUNT(hero_attribute.hero_id) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE hero_attribute.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength')\n```"
    ],
    "1101": [
        "```\n#reason: The question wants to find the \"average number of goals\" made by Parma as the away team in matches played in Italy. Therefore, the SQL SELECT needs to calculate the average of the away_team_goal column while filtering for matches where the away team is 'Parma' and the country is Italy.\n#columns: Match.away_team_goal, Team.team_long_name, Match.country_id, Country.name\n#values: 'Parma' refers to Team.team_long_name = 'Parma', 'Italy' refers to Country.name = 'Italy'\n#SELECT: SELECT AVG(away_team_goal) refer to Match.away_team_goal.\n#SQL-like: Show AVG(away_team_goal), WHERE Match.away_team_api_id = (SELECT team_api_id FROM Team WHERE team_long_name = 'Parma') AND Match.country_id = (SELECT id FROM Country WHERE name = 'Italy')\n#SQL: SELECT AVG(Match.away_team_goal) FROM Match INNER JOIN Team ON Match.away_team_api_id = Team.team_api_id INNER JOIN Country ON Match.country_id = Country.id WHERE Team.team_long_name = 'Parma' AND Country.name = 'Italy'\n```"
    ],
    "806": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the eye colour of a specific superhero, so the SQL SELECT will retrieve the eye colour based on the superhero's full name.\n#columns: colour.colour, superhero.full_name\n#values: 'Karen Beecher-Duncan' refer to superhero.full_name = 'Karen Beecher-Duncan'\n#SELECT: SELECT colour.colour refer to colour.colour. The order of columns in the SELECT clause must be the same as the order in the question.\n#SQL-like: Show colour.colour WHERE superhero.full_name = 'Karen Beecher-Duncan'\n#SQL: SELECT T1.colour FROM colour AS T1 INNER JOIN superhero AS T2 ON T2.eye_colour_id = T1.id WHERE T2.full_name = 'Karen Beecher-Duncan'\n```"
    ],
    "723": [
        "```\n#reason: The question wants to count superheroes with blue eyes who have a specific superpower, so the SQL SELECT will count the superheroes while applying the necessary filters for eye color and superpower.\n#columns: superhero.id, superhero.eye_colour_id, superpower.power_name\n#values: 'blue eyes' refer to superhero.eye_colour_id = colour.id where colour.colour = 'Blue', 'super power of \"Agility\"' refer to superpower.power_name = 'Agility'\n#SELECT: SELECT COUNT(superhero.id) refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.eye_colour_id IN (SELECT colour.id FROM colour WHERE colour.colour = 'Blue') AND superhero.id IN (SELECT hero_power.hero_id FROM hero_power INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Agility')\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue') AND T3.power_name = 'Agility'\n```"
    ],
    "1303": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the birthday of the oldest patient whose blood glucose is abnormal, so the SQL SELECT will retrieve the minimum birthday from the Patient table where blood glucose exceeds 180.\n#columns: Patient.Birthday, Laboratory.GLU\n#values: oldest patient refers to MIN(Birthday) and blood glucose is abnormal refers to Laboratory.GLU > 180\n#SELECT: SELECT Birthday refer to Patient.Birthday\n#SQL-like: Show Birthday, WHERE GLU > 180, ORDER BY Birthday ASC LIMIT 1\n#SQL: SELECT MIN(Patient.Birthday) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.GLU > 180\n```"
    ],
    "1374": [
        "```\n#reason: The question wants to count the number of events attended by a member with a specific phone number, so the SQL SELECT will count the events linked to that member's ID.\n#columns: attendance.link_to_event, attendance.link_to_member, member.phone\n#values: phone number '954-555-6240' refer to member.phone = '954-555-6240'\n#SELECT: SELECT COUNT(attendance.link_to_event) refer to attendance.link_to_event\n#SQL-like: Show COUNT(attendance.link_to_event), WHERE member.phone = '954-555-6240'\n#SQL: SELECT COUNT(T1.link_to_event) FROM attendance AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.phone = '954-555-6240'\n```"
    ],
    "872": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the abbreviated code of a driver in race No. 45 who had a specific Q3 time, so the SQL SELECT will retrieve the code from the drivers table based on the given raceId and Q3 time condition.\n#columns: drivers.code, qualifying.q3, qualifying.raceId\n#values: race No. 45 refers to qualifying.raceId = 45; had the Q3 time as 0:01:33 refers to qualifying.q3 LIKE '0:01:33%'\n#SELECT: 'his abbreviated code' refers to drivers.code\n#SQL-like: Show drivers.code, WHERE qualifying.raceId = 45 AND qualifying.q3 LIKE '0:01:33%'\n#SQL: SELECT T1.code FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 45 AND T2.q3 LIKE '0:01:33%'\n```"
    ],
    "24": [
        "```\n#reason: The question wants to display the names of the schools where the percentage of eligible free meals in K-12 is greater than 0.1, and the number of test takers whose test score is greater than or equal to 1500. Therefore, we need to filter based on these conditions and join the relevant tables.\n#columns: schools.School, satscores.NumTstTakr, satscores.NumGE1500, satscores.enroll12, satscores.cds, frpm.`Free Meal Count (K-12)`, frpm.`Enrollment (K-12)`\n#values: Percent eligible for free meals in K-12 refers to (frpm.`Free Meal Count (K-12)` / frpm.`Enrollment (K-12)`) > 0.1, test takers whose score is greater than or equal to 1500 refers to satscores.NumGE1500 > 0\n#SELECT: SELECT schools.School refer to schools.School\n#SQL-like: Show schools.School WHERE (frpm.`Free Meal Count (K-12)` / frpm.`Enrollment (K-12)`) > 0.1 AND satscores.NumGE1500 > 0\n#SQL: SELECT T1.School FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode INNER JOIN satscores AS T3 ON T1.CDSCode = T3.cds WHERE (T2.`Free Meal Count (K-12)` / T2.`Enrollment (K-12)`) > 0.1 AND T3.NumGE1500 > 0\n```"
    ],
    "782": [
        "```\n#reason: The question wants to display \"heroes' names\" whose eyes and hair colours are both black, so the SQL SELECT will target superhero_name and apply filters for eye_colour_id and hair_colour_id based on the condition where colour.colour is 'Black'.\n#columns: superhero.superhero_name, superhero.eye_colour_id, superhero.hair_colour_id, colour.id\n#values: eyes and hair colours are both black refer to superhero.eye_colour_id = colour.id AND superhero.hair_colour_id = colour.id WHERE colour.colour = 'Black'\n#SELECT: SELECT heroes' names refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name WHERE superhero.eye_colour_id = colour.id AND superhero.hair_colour_id = colour.id AND colour.colour = 'Black'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id AND T1.hair_colour_id = T2.id WHERE T2.colour = 'Black'\n```"
    ],
    "1097": [
        "```\n#reason: The question wants to retrieve the total crossing score for the player named Aaron Lennox, so the SQL SELECT will sum the crossing scores from the Player_Attributes table where the player's name matches 'Aaron Lennox'.\n#columns: Player_Attributes.crossing, Player.player_name\n#values: 'Aaron Lennox's' refers to Player.player_name = 'Aaron Lennox'\n#SELECT: SELECT SUM(crossing) refer to SUM(Player_Attributes.crossing)\n#SQL-like: Show SUM(Player_Attributes.crossing) WHERE Player.player_name = 'Aaron Lennox'\n#SQL: SELECT SUM(T1.crossing) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Aaron Lennox'\n```"
    ],
    "841": [
        "```\n#reason: The question want to display the weight and race of the superhero with a specific ID, so the SQL SELECT will involve weight_kg from the superhero table and race from the race table, using the superhero ID as a filter.\n#columns: superhero.weight_kg, race.race\n#values: superhero ID 40 refer to superhero.id = 40\n#SELECT: SELECT weight and race refer to superhero.weight_kg, race.race\n#SQL-like: Show superhero.weight_kg, race.race WHERE superhero.id = 40\n#SQL: SELECT T1.weight_kg, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.id = 40\n```"
    ],
    "906": [
        "```\n#reason: The question wants to identify Lewis Hamilton's first race and the points recorded for that race, so the SQL SELECT will find the minimum year for Hamilton's races and join it with the points recorded for that specific race.\n#columns: races.year, results.points\n#values: Lewis Hamilton refers to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'; first race refers to MIN(races.year)\n#SELECT: SELECT races.year, results.points refer to races.year, results.points\n#SQL-like: Show races.year, results.points, WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton', ORDER BY races.year LIMIT 1\n#SQL: SELECT T1.year, T2.points FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' ORDER BY T1.year LIMIT 1\n```"
    ],
    "856": [
        "```\n#reason: The question wants to display \"the time of the races held on Sepang International Circuit\", so the SQL SELECT will retrieve the time from the races table where the circuit name matches Sepang International Circuit.\n#columns: races.time, circuits.name\n#values: 'Sepang International Circuit' refer to circuits.name = 'Sepang International Circuit'\n#SELECT: time of the races refer to races.time\n#SQL-like: Show races.time, WHERE circuits.name = 'Sepang International Circuit'\n#SQL: SELECT T1.time FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Sepang International Circuit'\n```"
    ],
    "470": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the release date of the card set for \"Ancestor's Chosen\", so the SQL SELECT will fetch the release date based on the card name.\n#columns: sets.releaseDate\n#values: card set \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'\n#SELECT: SELECT releaseDate refer to sets.releaseDate\n#SQL-like: Show releaseDate WHERE name = 'Ancestor''s Chosen'\n#SQL: SELECT T2.releaseDate FROM sets AS T1 INNER JOIN cards AS T2 ON T1.code = T2.setCode WHERE T2.name = 'Ancestor''s Chosen'\n```"
    ],
    "596": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify users who have posted the most comments, so the SQL SELECT will focus on counting the comments grouped by user and retrieving their badges.\n#columns: users.Id, users.DisplayName, badges.Name\n#values: user with the most comments refers to MAX(COUNT(comments.Id)) where comments.UserId = users.Id\n#SELECT: SELECT users.Id, users.DisplayName, badges.Name refer to users.Id, users.DisplayName, badges.Name\n#SQL-like: Show users.Id, users.DisplayName, badges.Name, GROUP BY users.Id, ORDER BY COUNT(comments.Id) DESC LIMIT 1\n#SQL: SELECT users.Id, users.DisplayName, badges.Name FROM users INNER JOIN comments ON users.Id = comments.UserId INNER JOIN badges ON badges.UserId = users.Id GROUP BY users.Id ORDER BY COUNT(comments.Id) DESC LIMIT 1\n```"
    ],
    "666": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"id of the most valuable post\" which refers to the post with the \"highest FavoriteCount\" voted by \"user 1465\". The most valuable post is defined as MAX(FavoriteCount).\n#columns: posts.Id, posts.FavoriteCount, votes.UserId\n#values: user 1465 refers to votes.UserId = 1465\n#SELECT: id refer to posts.Id\n#SQL-like: Show posts.Id, WHERE votes.UserId = 1465 ORDER BY posts.FavoriteCount DESC LIMIT 1\n#SQL: SELECT T1.Id FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId WHERE T2.UserId = 1465 ORDER BY T1.FavoriteCount DESC LIMIT 1\n```"
    ],
    "688": [
        "```\n#reason: The question wants to identify the number of posts that have been viewed over 35000 times but have received no comments from other users, so the SQL SELECT will count posts where the ViewCount is greater than 35000 and the CommentCount is equal to 0.\n#columns: posts.ViewCount, posts.CommentCount\n#values: \"over 35000 times\" refer to posts.ViewCount > 35000, \"no comments\" refer to posts.CommentCount = 0\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id), WHERE posts.ViewCount > 35000 AND posts.CommentCount = 0\n#SQL: SELECT COUNT(Id) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0\n```"
    ],
    "6": [
        "```\n#reason: The question wants to display the names of schools with SAT test takers over 500 that are either magnet schools or offer a magnet program, so the SQL SELECT is for school names filtered by the conditions specified.\n#columns: schools.School Name, satscores.NumTstTakr, schools.Magnet\n#values: SAT test takers over 500 refer to satscores.NumTstTakr > 500, magnet schools or offer a magnet program refers to schools.Magnet = 1\n#SELECT: SELECT schools.School Name refer to schools.School Name\n#SQL-like: Show schools.School Name WHERE satscores.NumTstTakr > 500 AND schools.Magnet = 1\n#SQL: SELECT T1.School Name FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.NumTstTakr > 500 AND T1.Magnet = 1\n```"
    ],
    "251": [
        "```\n#reason: The question want to identify the \"least common element\" of all \"carcinogenic molecules\", so the SQL SELECT will count occurrences of elements associated with carcinogenic molecules and find the one with the minimum count.\n#columns: atom.element\n#values: label = '+' refer to molecule.label = '+'\n#SELECT: SELECT atom.element\n#SQL-like: Show atom.element, Group By atom.element, Order By COUNT(atom.element) ASC Limit 1\n#SQL: SELECT T1.element FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.label = '+' GROUP BY atom.element ORDER BY COUNT(atom.element) ASC LIMIT 1\n```"
    ],
    "1308": [
        "```\n#reason: The question wants to count how many patients have other symptoms observed, specifically filtering for those with a normal platelet level.\n#columns: Laboratory.PLT, Examination.Diagnosis\n#values: normal platelet level refer to Laboratory.PLT > 100 AND Laboratory.PLT < 400; have other symptoms refers to Examination.Diagnosis IS NOT NULL\n#SELECT: how many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Laboratory.PLT > 100 AND Laboratory.PLT < 400 AND Examination.Diagnosis IS NOT NULL\n#SQL: SELECT COUNT(Patient.ID) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Laboratory.PLT > 100 AND Laboratory.PLT < 400 AND Examination.Diagnosis IS NOT NULL\n```"
    ],
    "322": [
        "```\n#reason: The question wants to retrieve the element of toxicology for a specific atom, so the SQL SELECT will focus on the element column from the atom table where the atom_id matches the specified ID.\n#columns: atom.element\n#values: atom with ID refers to atom_id = 'TR000_1'\n#SELECT: SELECT element refer to atom.element\n#SQL-like: Show atom.element, WHERE atom.atom_id = 'TR000_1'\n#SQL: SELECT element FROM atom WHERE atom_id = 'TR000_1'\n```"
    ],
    "1194": [
        "```\n#reason: The question wants to display the sex of the patient based on filtering criteria from the medical examination and laboratory examination results, so the SQL SELECT will retrieve the Patient.SEX for patients who match the specified conditions.\n#columns: Patient.SEX\n#values: 'diagnosed with PSS' refer to Patient.Diagnosis = 'PSS', 'blood level of C-reactive protein de 2+' refer to Laboratory.CRP > 2, 'createnine 1' refer to Laboratory.CRE = 1, 'LDH 123' refer to Laboratory.LDH = 123\n#SELECT: SELECT Patient.SEX\n#SQL-like: Show Patient.SEX WHERE Patient.Diagnosis = 'PSS' AND Laboratory.CRP > 2 AND Laboratory.CRE = 1 AND Laboratory.LDH = 123\n#SQL: SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'PSS' AND T2.CRP > 2 AND T2.CRE = 1 AND T2.LDH = 123\n```"
    ],
    "201": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of carbon atoms in molecules that have double bonds, so the SQL SELECT counts the occurrences of carbon and divides it by the total number of atoms for double-bonded molecules.\n#columns: atom.element, atom.atom_id, bond.bond_type\n#values: carbon refers to atom.element = 'c', double-bond molecules refer to bond.bond_type = '='\n#SELECT: percentage of carbon in double-bond molecules refer to DIVIDE(COUNT(atom.atom_id) WHEN atom.element = 'c', COUNT(atom.atom_id))\n#SQL-like: Show DIVIDE(COUNT(atom.atom_id WHERE atom.element = 'c'), COUNT(atom.atom_id)), WHERE bond.bond_type = '='\n#SQL: SELECT CAST(SUM(CASE WHEN T1.element = 'c' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '='\n```"
    ],
    "904": [
        "```\n#reason: The question wants to identify the race and year of the race in which Michael Schumacher had his fastest lap, so the SQL SELECT will retrieve the race name and year where the lap time is the minimum for Michael Schumacher.\n#columns: races.name, races.year\n#values: fastest lap refers to MIN(lapTimes.milliseconds), Alex Yoong refers to drivers.forename = 'Alex' AND drivers.surname = 'Yoong'\n#SELECT: State the race and year of race refers to races.name, races.year\n#SQL-like: Show races.name, races.year, WHERE lapTimes.milliseconds = MIN(lapTimes.milliseconds) AND drivers.forename = 'Alex' AND drivers.surname = 'Yoong'\n#SQL: SELECT T1.name, T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T2.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes AS T4 INNER JOIN drivers AS T5 ON T4.driverId = T5.driverId WHERE T5.forename = 'Alex' AND T5.surname = 'Yoong')\n```"
    ],
    "482": [
        "```\n#reason: The question wants to display the German type of the card \"Ancestor's Chosen\", so the SQL SELECT will retrieve the type of the card where the language is German and the name matches \"Ancestor's Chosen\".\n#columns: cards.type, foreign_data.language\n#values: 'German' refer to foreign_data.language = 'German', 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen'\n#SELECT: SELECT cards.type, foreign_data.language\n#SQL-like: Show cards.type, foreign_data.language WHERE foreign_data.language = 'German' AND cards.name = 'Ancestor''s Chosen'\n#SQL: SELECT T1.type, T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.name = 'Ancestor''s Chosen'\n```"
    ],
    "1036": [
        "```\n#reason: The question wants to list the long name of teams with above-average build-up play passing in 2012, so the SQL SELECT will filter teams based on their build-up play passing being greater than the average for that year.\n#columns: Team.team_long_name, Team_Attributes.buildUpPlayPassing, Team_Attributes.date\n#values: 'in 2012' refers to \"strftime('%Y', Team_Attributes.date) = '2012'\", 'above-average build-up play passing' refers to \"Team_Attributes.buildUpPlayPassing > (SELECT AVG(buildUpPlayPassing) FROM Team_Attributes WHERE buildUpPlayPassing IS NOT NULL AND strftime('%Y', date) = '2012')\"\n#SELECT: SELECT Team.team_long_name refer to Team.team_long_name\n#SQL-like: Show Team.team_long_name WHERE Team_Attributes.buildUpPlayPassing > (SELECT AVG(buildUpPlayPassing) FROM Team_Attributes WHERE buildUpPlayPassing IS NOT NULL AND strftime('%Y', date) = '2012')\n#SQL: SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlayPassing > (SELECT AVG(buildUpPlayPassing) FROM Team_Attributes WHERE buildUpPlayPassing IS NOT NULL AND strftime('%Y', date) = '2012')\n```"
    ],
    "185": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the proportion of female customers who have accounts at the Prague branch, so the SQL SELECT will count the female clients with accounts in Prague and divide it by the total number of clients with accounts in Prague.\n#columns: client.gender, disp.client_id, account.district_id\n#values: female refers to client.gender = 'F', clients at the Prague branch refer to account.district_id in (SELECT district.district_id FROM district WHERE district.A3 = 'Prague')\n#SELECT: SELECT count(case when gender = 'F' then 1 else null end) / count(client.client_id) * 100 as percentage refer to account.district_id\n#SQL-like: Show count(female clients with accounts in Prague) / count(clients with accounts in Prague) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN T1.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id WHERE T3.district_id = (SELECT district_id FROM district WHERE A3 = 'Prague')\n```"
    ],
    "1232": [
        "```\n#reason: The question wants to provide ID, sex and age of patients whose blood glucose is not within normal range but total cholesterol is within normal range, so the SQL SELECT should include the ID and sex from the Patient table and the calculated age based on the Birthday column.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday\n#values: blood glucose (GLU) not within normal range refers to Laboratory.GLU >= 180, total cholesterol (T-CHO) within normal range refers to Laboratory.`T-CHO` < 250\n#SELECT: SELECT Patient.ID, Patient.SEX, (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', Patient.Birthday)) AS age\n#SQL-like: Show Patient.ID, Patient.SEX, age WHERE Laboratory.GLU >= 180 AND Laboratory.`T-CHO` < 250\n#SQL: SELECT T1.ID, T1.SEX, (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday)) AS age FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250\n```"
    ],
    "353": [
        "```\n#reason: The question wants to list all the sets available in Italian translation and state the total number of cards per set. \"Italian translation\" refers to language = 'Italian', and \"total number of cards per set\" refers to totalSetSize.\n#columns: sets.name, sets.totalSetSize\n#values: 'Italian translation' refers to set_translations.language = 'Italian'\n#SELECT: SELECT sets.name, sets.totalSetSize\n#SQL-like: Show sets.name, sets.totalSetSize WHERE set_translations.language = 'Italian'\n#SQL: SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'\n```"
    ],
    "437": [
        "```\n#reason: The question wants to find out which card has full artwork among those with black card borders. Therefore, the SQL SELECT clause will include the card's name while applying filters for black border color and full artwork.\n#columns: cards.name, cards.borderColor, cards.isFullArt\n#values: black card borders refer to cards.borderColor = 'black', has full artwork refers to cards.isFullArt = 1\n#SELECT: SELECT cards.name refer to cards.name.\n#SQL-like: Show cards.name WHERE cards.borderColor = 'black' AND cards.isFullArt = 1\n#SQL: SELECT cards.name FROM cards WHERE cards.borderColor = 'black' AND cards.isFullArt = 1\n```"
    ],
    "1165": [
        "```\n#reason: The question wants to calculate the age gap between the youngest and oldest patient with a normal triglyceride recorded. The age gap is defined as the difference between the maximum and minimum birth years of patients with triglyceride levels greater than or equal to 200. \n#columns: Laboratory.TG, Patient.Birthday\n#values: normal triglyceride refers to Laboratory.TG >= 200\n#SELECT: age gap refers to SUBTRACT(MAX(year(Birthday)), MIN(year(Birthday)))\n#SQL-like: Show SUBTRACT(MAX(strftime('%Y', Patient.Birthday)), MIN(strftime('%Y', Patient.Birthday))), WHERE Laboratory.TG >= 200\n#SQL: SELECT (MAX(strftime('%Y', Patient.Birthday)) - MIN(strftime('%Y', Patient.Birthday))) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Laboratory.TG >= 200\n```"
    ],
    "556": [
        "```\n#reason: The question wants to calculate the average number of badges obtained by users with more than 200 views, so the SQL SELECT will divide the count of badge IDs by the count of distinct display names for users with views greater than 200.\n#columns: badges.Id, users.DisplayName, users.Views\n#values: views greater than 200 refer to users.Views > 200\n#SELECT: average number of badges refer to Divide(Count(badges.Id), Count(DISTINCT users.DisplayName))\n#SQL-like: Show Divide(Count(badges.Id), Count(DISTINCT users.DisplayName)), WHERE users.Views > 200\n#SQL: SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200\n```"
    ],
    "62": [
        "```\n#reason: The question wants to determine the total number of non-chartered schools in the county of Los Angeles with a percent of eligible free meals for grades 1 through 12 that is less than 0.18%. The filtering conditions are non-chartered (Charter = 0), in the county of Los Angeles, and that the percent of eligible free meals for K-12 is calculated as `Free Meal Count (K-12)` * 100 / `Enrollment (K-12)` being less than 0.18%.\n#columns: schools.Charter, schools.County, frpm.`Free Meal Count (K-12)`, frpm.`Enrollment (K-12)`\n#values: 'non-chartered' refers to schools.Charter = 0, 'county of Los Angeles' refers to schools.County = 'Los Angeles', 'percent (%) of eligible free meals for grades 1 through 12 that is less than 0.18%' refers to (frpm.`Free Meal Count (K-12)` * 100 / frpm.`Enrollment (K-12)`) < 0.18\n#SELECT: SELECT total number of non-chartered schools refer to COUNT(*) \n#SQL-like: Show COUNT(*) WHERE schools.Charter = 0 AND schools.County = 'Los Angeles' AND (frpm.`Free Meal Count (K-12)` * 100 / frpm.`Enrollment (K-12)`) < 0.18\n#SQL: SELECT COUNT(*) FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.Charter = 0 AND T1.County = 'Los Angeles' AND (T2.`Free Meal Count (K-12)` * 100 / T2.`Enrollment (K-12)`) < 0.18\n```"
    ],
    "1223": [
        "```\n#reason: The question wants to compare the number of male patients and female patients with creatinine levels not within the normal range. Therefore, the SQL SELECT compares the counts of male and female patients where the creatinine level is greater than or equal to 1.5.\n#columns: Patient.SEX, Laboratory.CRE\n#values: creatinine not within the normal range refers to Laboratory.CRE >= 1.5, male refers to Patient.SEX = 'M', female refers to Patient.SEX = 'F'\n#SELECT: SUM(Patient.SEX = 'M') > SUM(Patient.SEX = 'F') refer to Laboratory.CRE >= 1.5\n#SQL-like: Show SUM(CASE WHEN Patient.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN Patient.SEX = 'F' THEN 1 ELSE 0 END), WHERE Laboratory.CRE >= 1.5\n#SQL: SELECT SUM(CASE WHEN T2.SEX = 'M' THEN 1 ELSE 0 END) > SUM(CASE WHEN T2.SEX = 'F' THEN 1 ELSE 0 END) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.CRE >= 1.5\n```"
    ],
    "1426": [
        "```\n#reason: The question wants to list the last name of members with a major in environmental engineering and include its department and college name, so the SQL SELECT will include member.last_name, major.department, and major.college.\n#columns: member.last_name, major.department, major.college\n#values: 'Environmental Engineering' refers to major.major_name = 'Environmental Engineering'\n#SELECT: SELECT member.last_name, major.department, major.college\n#SQL-like: Show member.last_name, major.department, major.college WHERE major.major_name = 'Environmental Engineering'\n#SQL: SELECT T1.last_name, T2.department, T2.college FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'\n```"
    ],
    "1490": [
        "```\n#reason: The question wants to calculate the percentage of LAM customers who consumed more than 46.73, so the SQL SELECT will count the number of LAM customers who consumed more than 46.73 and divide it by the total number of LAM customers, multiplying by 100.\n#columns: yearmonth.Consumption, customers.CustomerID\n#values: 'LAM customer' refers to customers.Segment = 'LAM', 'consumed more than 46.73' refers to yearmonth.Consumption > 46.73\n#SELECT: percentage of LAM customers who consumed more than 46.73 refer to (COUNT(yearmonth.CustomerID WHERE yearmonth.Consumption > 46.73) * 100.0 / COUNT(yearmonth.CustomerID))\n#SQL-like: Show (COUNT(yearmonth.CustomerID WHERE yearmonth.Consumption > 46.73) * 100.0 / COUNT(yearmonth.CustomerID)), WHERE customers.Segment = 'LAM'\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.Consumption > 46.73 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.CustomerID) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'LAM'\n```"
    ],
    "686": [
        "```\n#reason: The question requires identification of the total number of posts with views above average. \"views above average\" is defined as ViewCount > AVG(ViewCount).\n#columns: posts.ViewCount\n#values: views above average refer to ViewCount > (SELECT AVG(ViewCount) FROM posts)\n#SELECT: total number of posts refer to COUNT(posts.Id)\n#SQL-like: Show COUNT(posts.Id), WHERE posts.ViewCount > (SELECT AVG(ViewCount) FROM posts)\n#SQL: SELECT COUNT(Id) FROM posts WHERE ViewCount > (SELECT AVG(ViewCount) FROM posts)\n```"
    ],
    "662": [
        "```\n#reason: The question wants to display the count of posts with votes that were created in 2011 and have a bounty of 50, so the SQL SELECT COUNT(posts.Id) and COUNT(votes.Id) and filter conditions are YEAR(CreationDate) = 2011 and BountyAmount = 50.\n#columns: posts.Id, votes.BountyAmount, votes.CreationDate\n#values: created in 2011 refers to strftime('%Y', votes.CreationDate) = '2011', bounty of 50 refers to votes.BountyAmount = 50\n#SELECT: SELECT COUNT(posts.Id) \n#SQL-like: Show COUNT(posts.Id), WHERE strftime('%Y', votes.CreationDate) = '2011' AND votes.BountyAmount = 50\n#SQL: SELECT COUNT(posts.Id) FROM posts INNER JOIN votes ON posts.Id = votes.PostId WHERE strftime('%Y', votes.CreationDate) = '2011' AND votes.BountyAmount = 50\n```"
    ],
    "1333": [
        "```\n#reason: The question wants to find the city and state where the President of the Student Club grew up, so the SQL SELECT will retrieve the city and state based on the member's position being 'President'.\n#columns: zip_code.city, zip_code.state\n#values: 'President' refer to member.position = 'President'\n#SELECT: SELECT zip_code.city, zip_code.state refer to zip_code.city, zip_code.state\n#SQL-like: Show zip_code.city, zip_code.state WHERE member.position = 'President'\n#SQL: SELECT zip_code.city, zip_code.state FROM member INNER JOIN zip_code ON member.zip = zip_code.zip_code WHERE member.position = 'President'\n```"
    ],
    "1139": [
        "```\n#reason: The question wants to find the final score for a specific match on a given date in a specific league, so the SQL SELECT will retrieve the home team goal and away team goal for the match on that date in the specified league.\n#columns: Match.home_team_goal, Match.away_team_goal, Match.date, League.name\n#values: 'September 24, 2008' refers to Match.date LIKE '2008-09-24%' AND 'in the Belgian Jupiler League' refers to League.name = 'Belgium Jupiler League'\n#SELECT: SELECT home_team_goal, away_team_goal refer to Match.home_team_goal, Match.away_team_goal\n#SQL-like: Show Match.home_team_goal, Match.away_team_goal WHERE Match.date LIKE '2008-09-24%' AND League.name = 'Belgium Jupiler League'\n#SQL: SELECT Match.home_team_goal, Match.away_team_goal FROM Match INNER JOIN League ON Match.league_id = League.id WHERE Match.date LIKE '2008-09-24%' AND League.name = 'Belgium Jupiler League'\n```"
    ],
    "844": [
        "```\n#reason: The question wants to display the eye colour of a specific superhero, so the SQL SELECT will retrieve the colour based on the superhero's name.\n#columns: colour.colour, superhero.eye_colour_id\n#values: 'Blackwulf' refers to superhero.superhero_name = 'Blackwulf'\n#SELECT: SELECT colour.colour refer to colour.colour\n#SQL-like: Show colour.colour, WHERE superhero.superhero_name = 'Blackwulf'\n#SQL: SELECT T1.colour FROM colour AS T1 INNER JOIN superhero AS T2 ON T2.eye_colour_id = T1.id WHERE T2.superhero_name = 'Blackwulf'\n```"
    ],
    "333": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to count the number of carbons present in the molecule TR008, so the SQL SELECT will count the atom IDs where the element is carbon and the molecule ID is TR008)\n#columns: atom.atom_id, atom.element, atom.molecule_id\n#values: carbon refers to atom.element = 'c' and in molecule TR008 refers to atom.molecule_id = 'TR008'\n#SELECT: how many carbons refer to COUNT(atom.atom_id)\n#SQL-like: Show COUNT(atom.atom_id), WHERE atom.element = 'c' AND atom.molecule_id = 'TR008'\n#SQL: SELECT COUNT(atom.atom_id) FROM atom WHERE atom.element = 'c' AND atom.molecule_id = 'TR008'\n```"
    ],
    "680": [
        "```\n#reason: The question requires the display of \"average score\" of posts by Stephen Turner. The definition of \"average score\" is AVG(Score), and the filtering condition is that the DisplayName is 'Stephen Turner'.\n#columns: posts.Score, users.DisplayName\n#values: DisplayName = 'Stephen Turner' refers to users.DisplayName = 'Stephen Turner'\n#SELECT: average score refers to AVG(Score)\n#SQL-like: Show AVG(posts.Score), WHERE users.DisplayName = 'Stephen Turner'\n#SQL: SELECT AVG(posts.Score) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Stephen Turner'\n```"
    ],
    "391": [
        "```\n#reason: The question wants to list Artifact cards that are black in color and have foreign language translations, so the SQL SELECT will include the relevant columns and apply the necessary filters.\n#columns: cards.originalType, cards.colors, foreign_data.language\n#values: originalType = 'Artifact' refer to cards.originalType = 'Artifact', colors = 'B' refer to cards.colors = 'B', language in foreign_data refer to foreign_data.language IS NOT NULL\n#SELECT: SELECT Artifact cards refer to cards.originalType, black color refer to cards.colors, foreign language refer to foreign_data.language\n#SQL-like: Show cards.originalType, cards.colors, foreign_data.language WHERE cards.originalType = 'Artifact' AND cards.colors = 'B' AND foreign_data.language IS NOT NULL\n#SQL: SELECT T1.originalType, T1.colors, T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B' AND T2.language IS NOT NULL\n```"
    ],
    "503": [
        "```\n#reason: The question wants to find the \"expansion type\" for the set which contains the card \"Samite Pilgrim\", so the SQL SELECT will retrieve the type from the sets table where the card name matches 'Samite Pilgrim'.\n#columns: sets.type\n#values: card \"Samite Pilgrim\" refers to cards.name = 'Samite Pilgrim'\n#SELECT: expansion type refers to sets.type\n#SQL-like: Show sets.type, WHERE cards.name = 'Samite Pilgrim'\n#SQL: SELECT T1.type FROM sets AS T1 INNER JOIN cards AS T2 ON T1.id = T2.id WHERE T2.name = 'Samite Pilgrim'\n```"
    ],
    "378": [
        "```\n#reason: The question requires identifying \"foiled cards\" that are \"incredibly powerful\" when paired with \"non-foiled cards\". Therefore, the SQL SELECT will filter records where both cardKingdomFoilId and cardKingdomId are NOT NULL.\n#columns: cards.id\n#values: cardKingdomFoilId is not null refer to cards.cardKingdomFoilId IS NOT NULL AND cardKingdomId is not null refer to cards.cardKingdomId IS NOT NULL\n#SELECT: IDs refer to cards.id\n#SQL-like: Show cards.id WHERE cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SQL: SELECT cards.id FROM cards WHERE cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n```"
    ],
    "541": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"display name\" of the \"user\" who is the owner of the \"most valuable post\". \"most valuable post\" is defined by Max(FavoriteCount).\n#columns: posts.FavoriteCount, posts.OwnerDisplayName\n#values: most valuable post refers to Max(FavoriteCount)\n#SELECT: display name of the user refers to posts.OwnerDisplayName\n#SQL-like: Show posts.OwnerDisplayName, ORDER BY posts.FavoriteCount DESC LIMIT 1\n#SQL: SELECT T1.OwnerDisplayName FROM posts AS T1 ORDER BY T1.FavoriteCount DESC LIMIT 1\n```"
    ],
    "55": [
        "```\n#reason: The question wants to calculate the ratio of schools located in Colusa County against those in Humboldt County, so the SQL SELECT will count the schools in each county and divide them.\n#columns: schools.County, schools.State, schools.School\n#values: 'California' refers to schools.MailState = 'CA', 'Colusa' refers to schools.County = 'Colusa', 'Humboldt' refers to schools.County = 'Humboldt'\n#SELECT: SELECT COUNT(CASE WHEN County = 'Colusa' THEN 1 END) / COUNT(CASE WHEN County = 'Humboldt' THEN 1 END) refer to schools.County\n#SQL-like: Show COUNT(CASE WHEN County = 'Colusa' THEN 1 END) / COUNT(CASE WHEN County = 'Humboldt' THEN 1 END), WHERE schools.MailState = 'CA'\n#SQL: SELECT CAST(COUNT(CASE WHEN County = 'Colusa' THEN 1 END) AS REAL) / COUNT(CASE WHEN County = 'Humboldt' THEN 1 END) FROM schools WHERE MailState = 'CA'\n```"
    ],
    "1336": [
        "```\n#reason: The question wants to identify the department offering the major that both Pierce and Guidi took, so the SQL SELECT should focus on the department of the major linked to the members filtered by their last names.\n#columns: major.department, member.last_name, member.link_to_major\n#values: 'Pierce' refer to member.last_name = 'Pierce', 'Guidi' refer to member.last_name = 'Guidi'\n#SELECT: SELECT major.department refer to major.department\n#SQL-like: Show major.department, WHERE member.last_name = 'Pierce' OR member.last_name = 'Guidi'\n#SQL: SELECT T1.department FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.last_name = 'Pierce' OR T2.last_name = 'Guidi'\n```"
    ],
    "427": [
        "```\n#reason: The question want to display the languages available in the set known as Archenemy on the magic card market, so the SQL SELECT foreign_data.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode INNER JOIN foreign_data AS T3 ON T2.setCode = T3.setCode WHERE T1.mcmName = 'Archenemy' AND T1.code = 'ARC' and accessing the foreign data will return the languages\n#columns: foreign_data.language, sets.mcmName, sets.code\n#values: 'Archenemy' refers to sets.mcmName = 'Archenemy', 'ARC' refers to sets.code = 'ARC'\n#SELECT: SELECT foreign_data.language refer to foreign_data.language \n#SQL-like: Show foreign_data.language, WHERE sets.mcmName = 'Archenemy' AND sets.code = 'ARC'\n#SQL: SELECT T3.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode INNER JOIN foreign_data AS T3 ON T2.setCode = T3.setCode WHERE T1.mcmName = 'Archenemy' AND T1.code = 'ARC'\n```"
    ],
    "1444": [
        "```\n#reason: The question wants to list the expenses that spend more than fifty dollars on average, so the SQL SELECT will include the expense_description and we will filter based on the average cost of expenses exceeding fifty dollars.\n#columns: expense.expense_description, expense.cost\n#values: spend more than fifty dollars on average refer to CAST(SUM(expense.cost) AS REAL) / COUNT(expense.expense_id) > 50\n#SELECT: SELECT expense.expense_description\n#SQL-like: Show expense.expense_description WHERE CAST(SUM(expense.cost) AS REAL) / COUNT(expense.expense_id) > 50\n#SQL: SELECT T1.expense_description FROM expense AS T1 GROUP BY T1.expense_description HAVING CAST(SUM(T1.cost) AS REAL) / COUNT(T1.expense_id) > 50\n```"
    ],
    "979": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the race number with the most finishers, where finishers are defined as races with a non-null finish time.\n#columns: results.raceId, results.time\n#values: finishers refers to results.time IS NOT NULL\n#SELECT: SELECT raceId refer to results.raceId\n#SQL-like: Show raceId, WHERE time IS NOT NULL, GROUP BY raceId, ORDER BY COUNT(*) DESC LIMIT 1\n#SQL: SELECT raceId FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY COUNT(*) DESC LIMIT 1\n```"
    ],
    "1300": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to find the disease name of the patient with the highest level of triglyceride within the normal range, so the SQL SELECT will retrieve the Diagnosis where TG is less than 200 and is the maximum.)\n#columns: Patient.Diagnosis, Laboratory.TG\n#values: highest level of triglyceride within the normal range refers to Laboratory.TG < 200 and MAX(Laboratory.TG)\n#SELECT: SELECT Diagnosis refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis, WHERE Laboratory.TG < 200 ORDER BY Laboratory.TG DESC LIMIT 1\n#SQL: SELECT Patient.Diagnosis FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.TG < 200 ORDER BY Laboratory.TG DESC LIMIT 1\n```"
    ],
    "928": [
        "```\n#reason: The question wants to identify \"which driver ranked the first\" in the \"Canadian Grand Prix\" in 2007, so the SQL SELECT will retrieve the driver's reference name based on the race name and the finishing position.\n#columns: drivers.driverRef, results.position, races.name, races.year\n#values: 'Canadian Grand Prix' refers to races.name = 'Canadian Grand Prix', '2007' refers to races.year = 2007, 'ranked the first' refers to results.position = 1\n#SELECT: SELECT drivers.driverRef refer to drivers.driverRef\n#SQL-like: Show drivers.driverRef, WHERE races.name = 'Canadian Grand Prix' AND races.year = 2007 AND results.position = 1\n#SQL: SELECT T1.driverRef FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.name = 'Canadian Grand Prix' AND T2.year = 2007 AND T1.position = 1\n```"
    ],
    "1191": [
        "```\n#reason: The question wants to calculate the percentage of male patients who were diagnosed with BEHCET and first presented to the hospital in 1981. The SQL SELECT statement will sum up the cases where the diagnosis is BEHCET for male patients and divide it by the total number of male patients who first presented to the hospital in that year. \n#columns: Patient.SEX, Patient.`First Date`, Patient.Diagnosis\n#values: male refers to SEX = 'M', first presented to the hospital in 1981 refers to strftime('%Y', `First Date`) = '1981', BEHCET refers to Diagnosis = 'BEHCET'\n#SELECT: percentage of male patients diagnosed with BEHCET refers to SUM(Diagnosis = 'BEHCET') where strftime('%Y', `First Date`) = '1981', divided by COUNT(*) for patients who first presented in that year.\n#SQL-like: Show SUM(Diagnosis = 'BEHCET') / COUNT(*) * 100 where SEX = 'M' and strftime('%Y', `First Date`) = '1981'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.Diagnosis = 'BEHCET' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Patient AS T1 WHERE T1.SEX = 'M' AND strftime('%Y', T1.`First Date`) = '1981'\n```"
    ],
    "1507": [
        "```\n#reason: The question requires displaying \"the disparate time of the transactions\". \"Gas stations from chain no. 11\" is the filtering condition.\n#columns: transactions_1k.Time\n#values: chain no. 11 refer to gasstations.ChainID = 11\n#SELECT: the disparate time of the transactions refer to transactions_1k.Time\n#SQL-like: Show DISTINCT transactions_1k.Time, WHERE gasstations.ChainID = 11\n#SQL: SELECT DISTINCT T1.Time FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.ChainID = 11\n```"
    ],
    "518": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the play format with the highest number of banned status and the names of all the cards that meet the condition, so the SQL SELECT will include the play format and card names, grouped by play format and filtered by banned status.\n#columns: legalities.format, cards.name\n#values: 'banned status' refers to legalities.status = 'Banned'\n#SELECT: SELECT legalities.format, cards.name\n#SQL-like: Show legalities.format, cards.name WHERE legalities.status = 'Banned' GROUP BY legalities.format ORDER BY COUNT(legalities.status) DESC LIMIT 1\n#SQL: SELECT legalities.format, cards.name FROM legalities INNER JOIN cards ON legalities.uuid = cards.uuid WHERE legalities.status = 'Banned' GROUP BY legalities.format ORDER BY COUNT(legalities.status) DESC LIMIT 1\n```"
    ],
    "803": [
        "```\n#reason: The question wants to display the \"power ID\" for a specific power, so the SQL SELECT will focus on the superpower.id and apply a filter on superpower.power_name.\n#columns: superpower.id\n#values: cryokinesis refers to superpower.power_name = 'Cryokinesis'\n#SELECT: power ID refers to superpower.id\n#SQL-like: Show superpower.id WHERE superpower.power_name = 'Cryokinesis'\n#SQL: SELECT T1.id FROM superpower AS T1 WHERE T1.power_name = 'Cryokinesis'\n```"
    ],
    "605": [
        "```\n#reason: The question wants to determine the count of users who obtained a specific badge, so the SQL SELECT COUNT(UserId) and GROUP BY badge name.\n#columns: badges.UserId, badges.Name\n#values: 'Announcer' refers to badges.Name = 'Announcer'\n#SELECT: SELECT COUNT(UserId) refer to badges.UserId\n#SQL-like: Show COUNT(UserId), WHERE badges.Name = 'Announcer'\n#SQL: SELECT COUNT(UserId) FROM badges WHERE Name = 'Announcer'\n```"
    ],
    "1284": [
        "```\n#reason: The question wants to find the date when the patient with the highest lactate dehydrogenase in the normal range (less than 500) had their data first recorded, so the SQL SELECT MIN(First Date) and the filtering condition is MAX(LDH < 500).\n#columns: Patient.`First Date`, Laboratory.LDH\n#values: highest lactate dehydrogenase in the normal range refers to Laboratory.LDH < 500\n#SELECT: SELECT MIN(Patient.`First Date`) refer to Patient.`First Date`.\n#SQL-like: Show MIN(Patient.`First Date`) WHERE Laboratory.LDH < 500\n#SQL: SELECT MIN(Patient.`First Date`) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.LDH < 500\n```"
    ],
    "703": [
        "```\n#reason: The question wants to count how many tags have a tag ID below 15 and a count of posts that is 20 or below, so the SQL SELECT will be counting the tags based on those filtering conditions.\n#columns: tags.Id, tags.Count\n#values: tag ID below 15 refers to tags.Id < 15, have 20 count of posts and below refers to tags.Count <= 20\n#SELECT: how many tags refers to COUNT(tags.Id)\n#SQL-like: Show COUNT(tags.Id), WHERE tags.Id < 15 AND tags.Count <= 20\n#SQL: SELECT COUNT(Id) FROM tags WHERE Id < 15 AND Count <= 20\n```"
    ],
    "722": [
        "```\n#reason: The question wants to display the colour of Apocalypse's skin, so the SQL SELECT will reference the colour based on the superhero's skin_colour_id.\n#columns: colour.colour\n#values: Apocalypse refers to superhero.superhero_name = 'Apocalypse'\n#SELECT: SELECT colour refer to colour.colour\n#SQL-like: Show colour.colour, WHERE superhero.superhero_name = 'Apocalypse'\n#SQL: SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T1.superhero_name = 'Apocalypse'\n```"
    ],
    "621": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the names of badges obtained by users with the lowest reputation, so the SQL SELECT will involve joining the badges and users tables based on UserId and filtering by the minimum reputation.\n#columns: badges.Name, users.Reputation\n#values: lowest reputation refers to Reputation = (SELECT MIN(Reputation) FROM users)\n#SELECT: SELECT badges.Name\n#SQL-like: Show badges.Name WHERE users.Reputation = (SELECT MIN(Reputation) FROM users)\n#SQL: SELECT badges.Name FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.Reputation = (SELECT MIN(Reputation) FROM users)\n```"
    ],
    "1135": [
        "```\n#reason: The question requires displaying \"top five football players' IDs\" who have the lowest potential and prefer to use the right foot. \"lowest potential players\" refers to MIN(potential) and \"prefer to use the right foot when attacking\" refers to preferred_foot = 'right'.\n#columns: Player_Attributes.player_api_id, Player_Attributes.potential\n#values: preferred to use the right foot refers to preferred_foot = 'right'\n#SELECT: top five football players' IDs refer to Player_Attributes.player_api_id\n#SQL-like: Show Player_Attributes.player_api_id WHERE Player_Attributes.preferred_foot = 'right' ORDER BY Player_Attributes.potential ASC LIMIT 5\n#SQL: SELECT T1.player_api_id FROM Player_Attributes AS T1 WHERE T1.preferred_foot = 'right' ORDER BY T1.potential ASC LIMIT 5\n```"
    ],
    "1079": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the player with the tallest height, defined as MAX(height), so the SQL SELECT statement should focus on displaying the player's name.\n#columns: Player.player_name, Player.height\n#values: None\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name, ORDER BY Player.height DESC LIMIT 1\n#SQL: SELECT player_name FROM Player ORDER BY height DESC LIMIT 1\n```"
    ],
    "203": [
        "```\n#reason: The question wants to count the number of atoms that do not contain bromine, so the SQL SELECT will count the atom IDs where the element is not 'br'.\n#columns: atom.atom_id, atom.element\n#values: atoms with no bromine refers to atom.element <> 'br'\n#SELECT: SELECT COUNT(atom_id) refer to atom.atom_id\n#SQL-like: Show COUNT(atom.atom_id), WHERE atom.element <> 'br'\n#SQL: SELECT COUNT(atom_id) FROM atom WHERE element <> 'br'\n```"
    ],
    "631": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of posts created by 'Daniel Vassallo', so the SQL SELECT COUNT(posts.Id) and the filter is based on posts.OwnerDisplayName = 'Daniel Vassallo'.\n#columns: posts.Id, posts.OwnerDisplayName\n#values: posts.OwnerDisplayName = 'Daniel Vassallo' refers to posts.OwnerDisplayName = 'Daniel Vassallo'\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id), WHERE posts.OwnerDisplayName = 'Daniel Vassallo'\n#SQL: SELECT COUNT(Id) FROM posts WHERE OwnerDisplayName = 'Daniel Vassallo'\n```"
    ],
    "359": [
        "```\n#reason: The question wants to display the type of the card \"Ancestor's Chosen\" as originally printed, so the SQL SELECT will retrieve the original type of the card based on its name.\n#columns: cards.originalType\n#values: 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen'\n#SELECT: SELECT originalType refer to cards.originalType\n#SQL-like: Show cards.originalType, WHERE cards.name = 'Ancestor''s Chosen'\n#SQL: SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen'\n```"
    ],
    "1436": [
        "```\n#reason: The question wants to provide links to events for members who have paid more than 50 dollars, so the SQL SELECT will retrieve the event links based on the condition of expenses greater than 50.\n#columns: expense.link_to_budget, expense.cost, budget.link_to_event\n#values: paid more than 50 dollars refers to expense.cost > 50\n#SELECT: SELECT expense.link_to_budget refer to expense.link_to_budget\n#SQL-like: Show expense.link_to_budget WHERE expense.cost > 50\n#SQL: SELECT expense.link_to_budget FROM expense WHERE expense.cost > 50\n```"
    ],
    "1279": [
        "```\n#reason: The question wants to calculate the percentage of patients who have an abnormal level of glutamic oxaloacetic transaminase (GOT) and are diagnosed with SLE, so the SQL SELECT will count the patients with GOT >= 60 and Diagnosis = 'SLE' and divide it by the total count of patients with GOT >= 60.\n#columns: Laboratory.GOT, Patient.Diagnosis, Patient.ID\n#values: abnormal level of glutamic oxaloacetic transaminase refers to Laboratory.GOT >= 60, diagnosed with SLE refers to Patient.Diagnosis = 'SLE'\n#SELECT: percentage of patient refer to MULTIPLY(DIVIDE(COUNT(ID WHERE GOT >= 60 AND Diagnosis = 'SLE'), COUNT(ID WHERE GOT >= 60)), 1.0)\n#SQL-like: Show MULTIPLY(DIVIDE(COUNT(Patient.ID WHERE Laboratory.GOT >= 60 AND Patient.Diagnosis = 'SLE'), COUNT(Patient.ID WHERE Laboratory.GOT >= 60)), 1.0)\n#SQL: SELECT CAST(SUM(CASE WHEN T1.GOT >= 60 AND T2.Diagnosis = 'SLE' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.ID) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.GOT >= 60\n```"
    ],
    "645": [
        "```\n#reason: The question requires displaying the \"number of negative comments\" given by \"user ID 13\". \"negative comments\" is a filtering condition.\n#columns: comments.Id, comments.Score, comments.UserId\n#values: negative comments refers to Score < 60, user ID 13 refers to comments.UserId = 13\n#SELECT: number of negative comments refers to COUNT(Id)\n#SQL-like: Show COUNT(comments.Id), WHERE comments.Score < 60 AND comments.UserId = 13\n#SQL: SELECT COUNT(Id) FROM comments WHERE Score < 60 AND UserId = 13\n```"
    ],
    "861": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"number of the driver\" who finished in the Q3 of qualifying race No.903, where the finish time is in the format '0:0M:SS'. So the SQL SELECT will retrieve the driver's number based on the qualifying race ID and the specified finish time format.\n#columns: drivers.number, qualifying.q3, qualifying.raceId\n#values: race number is 903 refer to qualifying.raceId = 903, finished 0:0M:SS in the Q3 refers to qualifying.q3 LIKE '0:%'\n#SELECT: SELECT drivers.number refer to drivers.number\n#SQL-like: Show drivers.number, WHERE qualifying.raceId = 903 AND qualifying.q3 LIKE '0:%'\n#SQL: SELECT T1.number FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 903 AND T2.q3 LIKE '0:%'\n```"
    ],
    "796": [
        "```\n#reason: The question wants to retrieve all attributes of the superhero '3-D Man' along with their corresponding values, so the SQL SELECT will target the attributes and values associated with the specific superhero.\n#columns: attribute.attribute_name, hero_attribute.attribute_value\n#values: 3-D Man refers to superhero.superhero_name = '3-D Man'\n#SELECT: SELECT attribute_name, attribute_value refer to attribute.attribute_name, hero_attribute.attribute_value.\n#SQL-like: Show attribute.attribute_name, hero_attribute.attribute_value, WHERE superhero.superhero_name = '3-D Man'\n#SQL: SELECT T1.attribute_name, T2.attribute_value FROM superhero AS T0 INNER JOIN hero_attribute AS T2 ON T0.id = T2.hero_id INNER JOIN attribute AS T1 ON T2.attribute_id = T1.id WHERE T0.superhero_name = '3-D Man'\n```"
    ],
    "1049": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the matches held in the Scotland Premier League during the 2015/2016 season, so the SQL SELECT will count the number of matches where the league name matches and the season is specified.\n#columns: Match.league_id, Match.season, League.name\n#values: Scotland Premier League refers to League.name = 'Scotland Premier League', 2015/2016 refers to Match.season = '2015/2016'\n#SELECT: SELECT COUNT(Match.league_id) refer to Match.league_id\n#SQL-like: Show COUNT(Match.league_id), WHERE League.name = 'Scotland Premier League' AND Match.season = '2015/2016'\n#SQL: SELECT COUNT(M1.league_id) FROM Match AS M1 INNER JOIN League AS L1 ON M1.league_id = L1.id WHERE L1.name = 'Scotland Premier League' AND M1.season = '2015/2016'\n```"
    ],
    "574": [
        "```\n#reason: The question wants to identify the user who has the specified website URL, so the SQL SELECT will filter by WebsiteUrl and retrieve the corresponding DisplayName.\n#columns: users.DisplayName, users.WebsiteUrl\n#values: 'http://stackoverflow.com' refers to users.WebsiteUrl = 'http://stackoverflow.com'\n#SELECT: SELECT DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName WHERE users.WebsiteUrl = 'http://stackoverflow.com'\n#SQL: SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com'\n```"
    ],
    "148": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the accounts with a district of Tabor that are eligible for loans, so the SQL SELECT will focus on the account information where the district matches and the account type is 'OWNER'.\n#columns: account.account_id, account.district_id, disp.type\n#values: 'district is Tabor' refer to district.A2 = 'Tabor', 'account type = OWNER' refer to disp.type = 'OWNER'\n#SELECT: SELECT account.account_id refer to account.account_id\n#SQL-like: Show account.account_id, WHERE district.A2 = 'Tabor' AND disp.type = 'OWNER'\n#SQL: SELECT T1.account_id FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T3.A2 = 'Tabor' AND T2.type = 'OWNER'\n```"
    ],
    "138": [
        "```\n#reason: The question wants to find the number of male clients in the branch where the second-highest number of crimes was committed in 1995. The SQL combines an inner query to find the branch with the second-highest number of crimes and then counts the male clients in that branch.\n#columns: client.gender, district.A15, client.district_id\n#values: male refers to client.gender = 'M'\n#SELECT: SELECT COUNT(client.gender) refer to client.gender\n#SQL-like: Show COUNT(client.gender), WHERE client.gender = 'M' AND client.district_id = (SELECT district_id FROM district ORDER BY A15 DESC LIMIT 1 OFFSET 1)\n#SQL: SELECT COUNT(T1.gender) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A15 = (SELECT DISTINCT A15 FROM district ORDER BY A15 DESC LIMIT 1 OFFSET 1)\n```"
    ],
    "296": [
        "```\n#reason: The question requires identifying the \"molecule id\" associated with the bond \"TR000_1_2\" that has the first atom named \"TR000_1\". This involves filtering based on the bond_id and the first atom's id.\n#columns: bond.molecule_id\n#values: 'the first atom named TR000_1' refers to connected.atom_id = 'TR000_1'\n#SELECT: SELECT bond.molecule_id refer to bond.molecule_id\n#SQL-like: Show bond.molecule_id WHERE connected.atom_id = 'TR000_1' AND connected.bond_id = 'TR000_1_2'\n#SQL: SELECT T1.molecule_id FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.bond_id = 'TR000_1_2'\n```"
    ],
    "547": [
        "```\n#reason: The question wants to count the number of posts owned by elder users with a score of over 19, so the SQL SELECT will count the posts where the user's age is greater than 65 and the post's score is greater than or equal to 20.\n#columns: users.Age, posts.Score, posts.OwnerUserId, posts.Id\n#values: elder users refer to Age > 65, Score of over 19 refer to Score >= 20\n#SELECT: how many posts refer to COUNT(posts.Id)\n#SQL-like: Show COUNT(posts.Id), WHERE users.Age > 65 AND posts.Score >= 20\n#SQL: SELECT COUNT(T2.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.Age > 65 AND T1.Score >= 20\n```"
    ],
    "823": [
        "```\n#reason: The question want to count the number of female superheroes published by Marvel Comics, so the SQL SELECT will count the superheroes filtered by gender and publisher name.\n#columns: superhero.gender_id, superhero.publisher_id\n#values: 'female' refer to gender.gender = 'Female', 'Marvel Comics' refer to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT COUNT(superhero.gender_id) refer to superhero.gender_id\n#SQL-like: Show COUNT(superhero.gender_id) WHERE superhero.gender_id = (SELECT id FROM gender WHERE gender = 'Female') AND superhero.publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')\n#SQL: SELECT COUNT(T1.gender_id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T3.gender = 'Female' AND T2.publisher_name = 'Marvel Comics'\n```"
    ],
    "738": [
        "```\n#reason: The question wants to identify superheroes with a durability attribute value of less than 50, so the SQL SELECT will retrieve the superhero names based on the specified attribute conditions.\n#columns: superhero.superhero_name, hero_attribute.attribute_value\n#values: durability of less than 50 refers to attribute_name = 'Durability' AND attribute_value < 50\n#SELECT: SELECT superhero.superhero_name\n#SQL-like: Show superhero.superhero_name WHERE hero_attribute.attribute_value < 50 AND hero_attribute.attribute_id IN (SELECT id FROM attribute WHERE attribute_name = 'Durability')\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T3.attribute_name = 'Durability' AND T2.attribute_value < 50\n```"
    ],
    "694": [
        "```\n#reason: The question wants to provide the text of the latest 10 comments to a specific post and the display name of the user who left each comment, so the SQL SELECT will retrieve the comment text and user display name, filtering by the post title.\n#columns: comments.Text, comments.UserDisplayName\n#values: 'the title is Analysing wind data with R' refer to posts.Title = 'Analysing wind data with R'\n#SELECT: SELECT comments.Text, comments.UserDisplayName\n#SQL-like: Show comments.Text, comments.UserDisplayName, WHERE posts.Title = 'Analysing wind data with R' ORDER BY comments.CreationDate DESC LIMIT 10\n#SQL: SELECT comments.Text, comments.UserDisplayName FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.Title = 'Analysing wind data with R' ORDER BY comments.CreationDate DESC LIMIT 10\n```"
    ],
    "318": [
        "```\n#reason: The question requires display of the \"molecule id\" for a specific \"bond id\". The bond id value is used as a filtering condition.\n#columns: bond.molecule_id\n#values: bond id TR001_1_7 refer to bond.bond_id = 'TR001_1_7'\n#SELECT: molecule id refer to bond.molecule_id\n#SQL-like: Show bond.molecule_id WHERE bond.bond_id = 'TR001_1_7'\n#SQL: SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7'\n```"
    ],
    "664": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question want to find the sum of score of posts on a specific date, so the SQL SELECT sum(posts.Score) and filter by posts.LastActivityDate.)\n#columns: posts.Score\n#values: on 2010-07-19 refers to posts.LastActivityDate LIKE '2010-07-19%'\n#SELECT: SELECT sum(posts.Score) refer to posts.Score\n#SQL-like: Show sum(posts.Score), WHERE posts.LastActivityDate LIKE '2010-07-19%'\n#SQL: SELECT sum(posts.Score) FROM posts WHERE posts.LastActivityDate LIKE '2010-07-19%'\n```"
    ],
    "261": [
        "```\n#reason: The question wants to retrieve the bond ids for molecules that are carcinogenic, so the SQL SELECT will include the bond_id from the bond table where the associated molecule's label indicates that it is carcinogenic.\n#columns: bond.bond_id\n#values: carcinogenic refers to molecule.label = '+'\n#SELECT: SELECT bond.bond_id refer to bond.bond_id\n#SQL-like: Show bond.bond_id, WHERE molecule.label = '+'\n#SQL: SELECT bond.bond_id FROM bond INNER JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE molecule.label = '+'\n```"
    ],
    "20": [
        "```\n#reason: The question wants to count the number of schools in Amador with specific grade levels, so the SQL SELECT will count the schools filtered by county and grade conditions.\n#columns: schools.County, schools.LowGrade, schools.HighGrade\n#values: 'Amador' refers to schools.County = 'Amador', 'Low Grade is 9' refers to schools.LowGrade = '9', 'High Grade is 12' refers to schools.HighGrade = '12'\n#SELECT: SELECT COUNT(*) refer to COUNT(*) \n#SQL-like: Show COUNT(*), WHERE schools.County = 'Amador' AND schools.LowGrade = '9' AND schools.HighGrade = '12'\n#SQL: SELECT COUNT(*) FROM schools WHERE County = 'Amador' AND LowGrade = '9' AND HighGrade = '12'\n```"
    ],
    "117": [
        "```\n#reason: The question wants to calculate the percentage of loan amounts that have been fully paid with no issues. This is determined by filtering loans with a status of 'A' (indicating the contract is finished with no problems) and comparing the total amount of these loans to the total amount of all loans. \n#columns: loan.amount, loan.status\n#values: 'fully paid with no issue' refers to loan.status = 'A'\n#SELECT: SELECT (CAST(SUM(CASE WHEN loan.status = 'A' THEN loan.amount ELSE 0 END) AS REAL) * 100 / SUM(loan.amount)) \n#SQL-like: Show (SUM(CASE WHEN loan.status = 'A' THEN loan.amount ELSE 0 END) / SUM(loan.amount)) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN loan.status = 'A' THEN loan.amount ELSE 0 END) AS REAL) * 100 / SUM(loan.amount) FROM loan\n```"
    ],
    "1003": [
        "```\n#reason: The question wants to determine the number of accidents for the driver with the highest number of accidents in the Canadian Grand Prix, so the SQL SELECT will count the number of accidents where the status ID is 3 for the driver identified. \n#columns: results.driverId, results.statusId\n#values: name is 'Canadian Grand Prix' refer to races.name = 'Canadian Grand Prix'\n#SELECT: SELECT COUNT(*) refer to results.statusId. \n#SQL-like: Show COUNT(*) where results.statusId = 3 and races.name = 'Canadian Grand Prix', GROUP BY results.driverId, ORDER BY COUNT(*) DESC LIMIT 1\n#SQL: SELECT COUNT(*) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE results.statusId = 3 AND races.name = 'Canadian Grand Prix' GROUP BY results.driverId ORDER BY COUNT(*) DESC LIMIT 1\n```"
    ],
    "1071": [
        "```\n#reason: The question wants to list the football team with specific build-up play attributes, so the SQL SELECT will focus on the team's short name while applying the necessary filters for build-up play speed, dribbling, and passing.\n#columns: Team.team_short_name, Team_Attributes.buildUpPlaySpeed, Team_Attributes.buildUpPlayDribbling, Team_Attributes.buildUpPlayPassing\n#values: build up play speed of 31 refers to Team_Attributes.buildUpPlaySpeed = 31, build up play dribbling of 53 refers to Team_Attributes.buildUpPlayDribbling = 53, build up play passing of 32 refers to Team_Attributes.buildUpPlayPassing = 32\n#SELECT: SELECT Team.team_short_name refer to Team.team_short_name\n#SQL-like: Show Team.team_short_name WHERE Team_Attributes.buildUpPlaySpeed = 31 AND Team_Attributes.buildUpPlayDribbling = 53 AND Team_Attributes.buildUpPlayPassing = 32\n#SQL: SELECT T1.team_short_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeed = 31 AND T2.buildUpPlayDribbling = 53 AND T2.buildUpPlayPassing = 32\n```"
    ],
    "512": [
        "```\n#reason: The question wants to count the number of cards with unknown power that can't be found in foil in duel deck A, so the SQL SELECT will count the cards based on the specified conditions.\n#columns: cards.power, cards.hasFoil, cards.duelDeck\n#values: unknown power refers to cards.power IS NULL OR cards.power = '*', can't be found in foil refers to cards.hasFoil = 0, duel deck A refers to cards.duelDeck = 'a'\n#SELECT: SELECT COUNT(*) refer to cards.id\n#SQL-like: Show COUNT(*) WHERE cards.power IS NULL OR cards.power = '*' AND cards.hasFoil = 0 AND cards.duelDeck = 'a'\n#SQL: SELECT COUNT(*) FROM cards WHERE (cards.power IS NULL OR cards.power = '*') AND cards.hasFoil = 0 AND cards.duelDeck = 'a'\n```"
    ],
    "810": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"the race of the superhero with maximum attribute value\", so the SQL SELECT will involve finding the superhero with the highest attribute value and then retrieving their race.\n#columns: race.race, hero_attribute.attribute_value, superhero.id\n#values: maximum attribute value refers to MAX(hero_attribute.attribute_value)\n#SELECT: race of the superhero with maximum attribute value refers to race.race\n#SQL-like: Show race.race WHERE hero_attribute.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute)\n#SQL: SELECT T3.race FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN race AS T3 ON T1.race_id = T3.id WHERE T2.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute)\n```"
    ],
    "1503": [
        "```\n#reason: The question requires displaying the \"product description\" of products that were bought in transactions using Euro as the currency. The filtering condition indicates that we are interested in transactions associated with Euro currency.\n#columns: products.Description, customers.Currency\n#values: Euro refers to customers.Currency = 'EUR'\n#SELECT: product description refers to products.Description\n#SQL-like: Show products.Description WHERE customers.Currency = 'EUR'\n#SQL: SELECT T2.Description FROM transactions_1k AS T1 INNER JOIN products AS T2 ON T1.ProductID = T2.ProductID INNER JOIN customers AS T3 ON T1.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR'\n```"
    ],
    "237": [
        "```\n#reason: The question wants to identify the molecule associated with a specific atom and determine if it is carcinogenic, so the SQL SELECT will retrieve the molecule_id and label from the molecule table based on the atom_id.\n#columns: molecule.molecule_id, molecule.label\n#values: 'TR001_10' refers to atom.atom_id = 'TR001_10'\n#SELECT: SELECT molecule_id, label refer to molecule.molecule_id, molecule.label\n#SQL-like: Show molecule.molecule_id, molecule.label WHERE atom.atom_id = 'TR001_10'\n#SQL: SELECT T2.molecule_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'\n```"
    ],
    "457": [
        "```\n#reason: The question wants to list the websites where cards can be purchased, so the SQL SELECT will filter for cards with the promotional type of \"bundle\" and retrieve the purchase URLs.\n#columns: cards.purchaseUrls, cards.promoTypes\n#values: promotional type of \"bundle\" refer to cards.promoTypes = 'bundle'\n#SELECT: SELECT cards.purchaseUrls refer to cards.purchaseUrls\n#SQL-like: Show cards.purchaseUrls, WHERE cards.promoTypes = 'bundle'\n#SQL: SELECT purchaseUrls FROM cards WHERE promoTypes = 'bundle'\n```"
    ],
    "1201": [
        "```\n#reason: The question wants to calculate the percentage of women among patients born in 1980 who were diagnosed with RA. Therefore, the SQL SELECT will count the number of female patients and divide it by the total number of patients who meet the criteria, multiplying by 100 for the percentage.\n#columns: Patient.Birthday, Patient.Diagnosis, Patient.SEX\n#values: born in 1980 refers to strftime('%Y', Patient.Birthday) = '1980', 'RA' refers to Patient.Diagnosis = 'RA', women refers to Patient.SEX = 'F'\n#SELECT: percentage of women among patients born in 1980 diagnosed with RA refers to MULTIPLY(DIVIDE(SUM(SEX = 'F'), COUNT(SEX)), 100)\n#SQL-like: Show MULTIPLY(DIVIDE(SUM(SEX = 'F'), COUNT(SEX)), 100) WHERE strftime('%Y', Patient.Birthday) = '1980' AND Patient.Diagnosis = 'RA'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.SEX) FROM Patient AS T1 WHERE strftime('%Y', T1.Birthday) = '1980' AND T1.Diagnosis = 'RA'\n```"
    ],
    "1293": [
        "```\n#reason: The question wants to find the highest anti-nucleus antibody concentration level of a patient with a normal creatinine level, so the SQL SELECT will retrieve the maximum value of the ANA column where the CRE column is less than 1.5.\n#columns: Examination.ANA, Laboratory.CRE\n#values: normal creatinine level refers to Laboratory.CRE < 1.5\n#SELECT: highest anti-nucleus antibody concentration level refer to MAX(Examination.ANA)\n#SQL-like: Show MAX(Examination.ANA) WHERE Laboratory.CRE < 1.5\n#SQL: SELECT MAX(T1.ANA) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.CRE < 1.5\n```"
    ],
    "1153": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the disease diagnosed for patient '30609' and list all the laboratory test dates for this patient, so the SQL SELECT will include the disease from the Patient table and the laboratory test dates from the Laboratory table.\n#columns: Patient.Diagnosis, Laboratory.Date\n#values: Patient ID '30609' refers to Patient.ID = 30609\n#SELECT: SELECT Patient.Diagnosis, Laboratory.Date\n#SQL-like: Show Patient.Diagnosis, Laboratory.Date WHERE Patient.ID = 30609\n#SQL: SELECT P.Diagnosis, L.Date FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.ID = 30609\n```"
    ],
    "1482": [
        "```\n#reason: The question wants to identify which of the three segments—SME, LAM, and KAM—has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013. This requires calculating the consumption difference for each segment for the specified years, then computing the percentage increase based on the 2013 consumption. The filtering conditions relate to segment types and year.\n#columns: yearmonth.Consumption, yearmonth.CustomerID, customers.Segment\n#values: 'between 2012 and 2013' refer to yearmonth.Date BETWEEN '201201' AND '201312', 'paid in EUR' refer to customers.Currency = 'EUR'\n#SELECT: SELECT Segment, (CAST((SUM(CASE WHEN yearmonth.Date LIKE '201301%' THEN Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.Date LIKE '201201%' THEN Consumption ELSE 0 END)) AS REAL) / SUM(CASE WHEN yearmonth.Date LIKE '201301%' THEN Consumption ELSE 0 END)) * 100 AS PercentageIncrease\n#SQL-like: Show Segment, (CAST(SUM(CASE WHEN yearmonth.Date LIKE '201301%' THEN Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.Date LIKE '201201%' THEN Consumption ELSE 0 END) AS REAL) / SUM(CASE WHEN yearmonth.Date LIKE '201301%' THEN Consumption ELSE 0 END)) * 100 AS PercentageIncrease WHERE customers.Currency = 'EUR' GROUP BY customers.Segment\n#SQL: SELECT T3.Segment, (CAST((SUM(CASE WHEN T2.Date LIKE '201301%' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '201201%' THEN T2.Consumption ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '201301%' THEN T2.Consumption ELSE 0 END)) * 100 AS PercentageIncrease FROM yearmonth AS T2 INNER JOIN customers AS T3 ON T2.CustomerID = T3.CustomerID WHERE T3.Currency = 'EUR' AND T2.Date BETWEEN '201201' AND '201312' GROUP BY T3.Segment\n```"
    ],
    "1077": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"long name\" for the team identified by the short name 'GEN', so the SQL SELECT will include the long name from the Team table where the short name matches 'GEN'.\n#columns: Team.team_long_name, Team.team_short_name\n#values: team_short_name = 'GEN' refers to Team.team_short_name = 'GEN'\n#SELECT: long name for the team refer to Team.team_long_name\n#SQL-like: Show Team.team_long_name, WHERE Team.team_short_name = 'GEN'\n#SQL: SELECT team_long_name FROM Team WHERE team_short_name = 'GEN'\n```"
    ],
    "1440": [
        "```\n#reason: The question wants to display emails of people who have made expenses greater than $20 within a specific date range. The SQL SELECT will filter expenses based on date and amount.\n#columns: member.email, expense.cost, expense.expense_date\n#values: 'from 9/10/2019 to 11/19/2019' refer to expense.expense_date BETWEEN '2019-09-10' AND '2019-11-19'; 'cost > 20' refers to expense.cost > 20\n#SELECT: SELECT emails of people who paid more than 20 dollars refer to member.email\n#SQL-like: Show member.email WHERE expense_date BETWEEN '2019-09-10' AND '2019-11-19' AND cost > 20\n#SQL: SELECT T1.email FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_date BETWEEN '2019-09-10' AND '2019-11-19' AND T2.cost > 20\n```"
    ],
    "131": [
        "```\n#reason: The question wants to identify the district with the highest number of active loans, which refers to the count of loans that are in status 'C' or 'D'. Hence, the SQL will involve counting the loans and grouping them by district.\n#columns: district.A3, loan.status\n#values: active loan refers to loan.status IN ('C', 'D')\n#SELECT: SELECT district.A3 refer to district names\n#SQL-like: Show district.A3, count(loan.status) WHERE loan.status IN ('C', 'D') GROUP BY district.A3 ORDER BY COUNT(loan.status) DESC LIMIT 1\n#SQL: SELECT T1.A3 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T3.status IN ('C', 'D') GROUP BY T1.A3 ORDER BY COUNT(T3.status) DESC LIMIT 1\n```"
    ],
    "319": [
        "```\n#reason: The question wants to count the number of elements related to a specific bond, so the SQL SELECT will count the occurrences of atom elements tied to the given bond_id.\n#columns: atom.atom_id, atom.element, bond.bond_id\n#values: bond_id TR001_3_4 refers to bond.bond_id = 'TR001_3_4'\n#SELECT: How many elements refer to COUNT(atom.element)\n#SQL-like: Show COUNT(atom.element), WHERE bond.bond_id = 'TR001_3_4'\n#SQL: SELECT COUNT(atom.element) FROM atom INNER JOIN bond ON atom.molecule_id = bond.molecule_id WHERE bond.bond_id = 'TR001_3_4'\n```"
    ],
    "67": [
        "```\n#reason: The question wants to find the total amount of Community College District closures in 1989 in the city of San Francisco, so the SQL SELECT will count the number of closures filtered by the specified conditions.\n#columns: schools.StatusType, schools.City, schools.DOCType\n#values: 'Community College District' refer to schools.DOCType = 'Community College District', 'Closed' refer to schools.StatusType = 'Closed', '1989' refer to strftime('%Y', schools.ClosedDate) = '1989', 'San Francisco' refer to schools.City = 'San Francisco'\n#SELECT: total amount refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE schools.DOCType = 'Community College District' AND schools.StatusType = 'Closed' AND strftime('%Y', schools.ClosedDate) = '1989' AND schools.City = 'San Francisco'\n#SQL: SELECT COUNT(*) FROM schools WHERE schools.DOCType = 'Community College District' AND schools.StatusType = 'Closed' AND strftime('%Y', schools.ClosedDate) = '1989' AND schools.City = 'San Francisco'\n```"
    ],
    "1396": [
        "```\n#reason: The question wants to provide the number of events attended by Luisa Guidi and her major, so the SQL SELECT will count the events in which she participated and retrieve her major.\n#columns: COUNT(attendance.link_to_event), major.major_name\n#values: 'Luisa Guidi' refers to member.first_name = 'Luisa' AND member.last_name = 'Guidi'\n#SELECT: SELECT COUNT(attendance.link_to_event), major.major_name\n#SQL-like: Show COUNT(attendance.link_to_event), major.major_name WHERE member.first_name = 'Luisa' AND member.last_name = 'Guidi'\n#SQL: SELECT COUNT(T1.link_to_event), T2.major_name FROM attendance AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Luisa' AND T2.last_name = 'Guidi'\n```"
    ],
    "1090": [
        "```\n#reason: The question wants to find the \"long passing score of the oldest player\", so the SQL SELECT will retrieve the long passing score based on the player's oldest birthday.\n#columns: Player_Attributes.long_passing, Player.birthday\n#values: oldest player refers to MIN(Player.birthday)\n#SELECT: long passing score refers to Player_Attributes.long_passing\n#SQL-like: Show Player_Attributes.long_passing, WHERE Player.birthday = (SELECT MIN(birthday) FROM Player)\n#SQL: SELECT T1.long_passing FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.birthday = (SELECT MIN(birthday) FROM Player)\n```"
    ],
    "1387": [
        "```\n#reason: The question wants to identify the student who has been entrusted to manage the budget for the 'Yearly Kickoff', so the SQL SELECT will retrieve the full name of the student associated with the budget for that event.\n#columns: member.first_name, member.last_name\n#values: 'Yearly Kickoff' refers to budget.link_to_event = (SELECT event.event_id FROM event WHERE event.event_name = 'Yearly Kickoff')\n#SELECT: SELECT member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, WHERE budget.link_to_event = (SELECT event.event_id FROM event WHERE event.event_name = 'Yearly Kickoff')\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN budget AS T2 ON T1.member_id = T2.link_to_member WHERE T2.link_to_event = (SELECT event_id FROM event WHERE event_name = 'Yearly Kickoff')\n```"
    ],
    "315": [
        "```\n#reason: The question wants to identify molecules that contain the \"cl\" element and are carcinogenic, so the SQL SELECT will filter based on the element and label.\n#columns: molecule.molecule_id, molecule.label, atom.element\n#values: 'contain \"cl\" element' refers to atom.element = 'cl', 'are carcinogenic' refers to molecule.label = '+'\n#SELECT: SELECT molecule.molecule_id, molecule.label refer to molecule.molecule_id, molecule.label\n#SQL-like: Show molecule.molecule_id, molecule.label WHERE atom.element = 'cl' AND molecule.label = '+'\n#SQL: SELECT T1.molecule_id, T1.label FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl' AND T1.label = '+'\n```"
    ],
    "1043": [
        "```\n#reason: The question wants to display the \"short name of the football team\". \"Queens Park Rangers\" is the filtering condition referring to team_long_name = 'Queens Park Rangers'.\n#columns: Team.team_short_name\n#values: 'Queens Park Rangers' refers to Team.team_long_name = 'Queens Park Rangers'\n#SELECT: SELECT Team.team_short_name refer to Team.team_short_name\n#SQL-like: Show Team.team_short_name, WHERE Team.team_long_name = 'Queens Park Rangers'\n#SQL: SELECT T1.team_short_name FROM Team AS T1 WHERE T1.team_long_name = 'Queens Park Rangers'\n```"
    ],
    "1417": [
        "```\n#reason: The question wants to list the type of events which have remaining budget more than 30 USD, so the SQL SELECT will include the event type and filter based on the remaining budget.\n#columns: event.type, budget.remaining\n#values: remaining budget more than 30 USD refers to budget.remaining > 30\n#SELECT: SELECT event.type\n#SQL-like: Show event.type, WHERE budget.remaining > 30\n#SQL: SELECT T1.type FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.remaining > 30\n```"
    ],
    "770": [
        "```\n#reason: The question wants to know the \"eyes colour\" of Abraham Sapien, so the SQL SELECT will retrieve the colour associated with the eye_colour_id of the superhero's record.\n#columns: colour.colour, superhero.eye_colour_id, colour.id\n#values: 'Abraham Sapien' refer to superhero.full_name = 'Abraham Sapien'\n#SELECT: eyes colour refer to colour.colour\n#SQL-like: Show colour.colour, WHERE superhero.eye_colour_id = colour.id AND superhero.full_name = 'Abraham Sapien'\n#SQL: SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.full_name = 'Abraham Sapien'\n```"
    ],
    "1220": [
        "```\n#reason: The question wants to provide all ID, sex and birthday of patients whose urea nitrogen (UN) just within the borderline of passing, so the SQL SELECT will include Patient.ID, Patient.SEX, and Patient.Birthday with a filter on Laboratory.UN.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday\n#values: urea nitrogen (UN) just within the borderline of passing refers to Laboratory.UN = 29\n#SELECT: ID, sex, birthday refer to Patient.ID, Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Birthday WHERE Laboratory.UN = 29\n#SQL: SELECT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.UN = 29\n```"
    ],
    "476": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the name of the cards in the set Coldsnap with the highest converted mana cost, so the SQL SELECT will gather card names based on the maximum converted mana cost from the subset of those cards that belong to the set named 'Coldsnap'.\n#columns: cards.name, cards.convertedManaCost, sets.name\n#values: card set Coldsnap refers to sets.name = 'Coldsnap'\n#SELECT: name of the cards refer to cards.name\n#SQL-like: Show cards.name WHERE cards.convertedManaCost = (SELECT MAX(cards.convertedManaCost) FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap')\n#SQL: SELECT cards.name FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.convertedManaCost = (SELECT MAX(cards.convertedManaCost) FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap')\n```"
    ],
    "1182": [
        "```\n#reason: The question wants to count the total number of laboratory tests for a specific patient diagnosed with SJS who first came to the hospital on a specific date, so the SQL SELECT will count the ID from the Laboratory table where the patient meets the specified conditions.\n#columns: Laboratory.ID, Patient.`First Date`, Patient.Diagnosis\n#values: 'first came to the hospital on 1991/6/13' refer to Patient.`First Date` = '1991-06-13', 'SJS' refer to Patient.Diagnosis = 'SJS', 'in 1995' refer to strftime('%Y', Laboratory.Date) = '1995'\n#SELECT: SELECT COUNT(Laboratory.ID) refer to COUNT(ID)\n#SQL-like: Show COUNT(Laboratory.ID), WHERE Patient.`First Date` = '1991-06-13' AND Patient.Diagnosis = 'SJS' AND strftime('%Y', Laboratory.Date) = '1995'\n#SQL: SELECT COUNT(Laboratory.ID) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.`First Date` = '1991-06-13' AND Patient.Diagnosis = 'SJS' AND strftime('%Y', Laboratory.Date) = '1995'\n```"
    ],
    "1243": [
        "```\n#reason: The question wants to calculate the percentage of female patients older than 55 who have abnormal prothrombin time (PT). The SQL SELECT clause will count the number of females with abnormal PT and divide it by the total number of patients with abnormal PT, then multiply by 100. The filtering conditions involve patients being older than 55 years based on their birthday and having a prothrombin time greater than or equal to 14. \n#columns: Patient.Birthday, Patient.SEX, Laboratory.PT\n#values: older than 55 years old refer to SUBTRACT(year(current_timestamp), year(Birthday)) > 55 and abnormal prothrombin time (PT) refers to Laboratory.PT >= 14\n#SELECT: percentage of female who has abnormal prothrombin time (PT) refer to (SUM(Laboratory.PT >= 14 AND Patient.SEX = 'F') / SUM(Laboratory.PT >= 14)) * 100\n#SQL-like: Show MULTIPLY(DIVIDE(SUM(Laboratory.PT >= 14 AND Patient.SEX = 'F'), SUM(Laboratory.PT >= 14)), 100) WHERE SUBTRACT(year(current_timestamp), year(Patient.Birthday)) > 55\n#SQL: SELECT CAST(SUM(CASE WHEN T2.PT >= 14 AND T1.SEX = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T2.PT >= 14 THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE SUBTRACT(year(current_timestamp), year(T1.Birthday)) > 55\n```"
    ],
    "804": [
        "```\n#reason: The question wants to display \"the name of superhero\" based on the \"superhero ID 294\" filtering condition.\n#columns: superhero.superhero_name\n#values: superhero ID 294 refers to superhero.id = 294\n#SELECT: name of superhero refers to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE superhero.id = 294\n#SQL: SELECT superhero_name FROM superhero WHERE id = 294\n```"
    ],
    "1065": [
        "```\n#reason: The question wants to list all team names which have a speed class of fast, so the SQL SELECT will retrieve the team_long_name where the buildUpPlaySpeedClass equals 'Fast'.\n#columns: Team.team_long_name, Team_Attributes.buildUpPlaySpeedClass\n#values: speed class refers to buildUpPlaySpeedClass = 'Fast'\n#SELECT: SELECT Team.team_long_name\n#SQL-like: Show Team.team_long_name WHERE Team_Attributes.buildUpPlaySpeedClass = 'Fast'\n#SQL: SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Fast'\n```"
    ],
    "294": [
        "```\n#reason: The question wants to identify bond ids that are double-bonded with carcinogenic compounds, so the SQL SELECT will filter for bond_type being double and the molecule label being carcinogenic.\n#columns: bond.bond_id, molecule.label\n#values: double bond refers to bond_type = '=', carcinogenic compound refers to molecule.label = '+'\n#SELECT: SELECT bond.bond_id refer to bond.bond_id\n#SQL-like: Show bond.bond_id, WHERE bond.bond_type = '=' AND molecule.label = '+'\n#SQL: SELECT T1.bond_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.label = '+'\n```"
    ],
    "225": [
        "```\n#reason: The question wants to list the top five molecules that have double bonds, so the SQL SELECT will retrieve the molecule IDs associated with double bonds and order them alphabetically, limiting the results to five.\n#columns: molecule.molecule_id, bond.bond_type\n#values: double bond refers to bond.bond_type = '='\n#SELECT: top five molecules refer to molecule.molecule_id\n#SQL-like: Show DISTINCT molecule.molecule_id, WHERE bond.bond_type = '=' ORDER BY molecule.molecule_id LIMIT 5\n#SQL: SELECT DISTINCT T2.molecule_id FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' ORDER BY T2.molecule_id LIMIT 5\n```"
    ],
    "1031": [
        "```\n#reason: The question wants to calculate the age of players who have a sprint speed of no less than 97 between 2013 to 2015, so the SQL SELECT will include the player's age calculated from their birthday and filter based on sprint speed and the date range.\n#columns: Player.birthday, Player_Attributes.sprint_speed, Player_Attributes.date\n#values: sprint speed of no less than 97 refers to Player_Attributes.sprint_speed >= 97; between 2013 to 2015 refers to strftime('%Y', Player_Attributes.date) >= '2013' AND strftime('%Y', Player_Attributes.date) <= '2015'\n#SELECT: SELECT (strftime('%Y', 'now') - strftime('%Y', Player.birthday)) refer to Player.birthday\n#SQL-like: Show (strftime('%Y', 'now') - strftime('%Y', Player.birthday)), WHERE Player_Attributes.sprint_speed >= 97 AND strftime('%Y', Player_Attributes.date) >= '2013' AND strftime('%Y', Player_Attributes.date) <= '2015'\n#SQL: SELECT strftime('%Y', 'now') - strftime('%Y', T1.birthday) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.sprint_speed >= 97 AND strftime('%Y', T2.date) >= '2013' AND strftime('%Y', T2.date) <= '2015'\n```"
    ],
    "1011": [
        "```\n#reason: The question wants to find the driver with the shortest lap time ever recorded in a Formula 1 race, so the SQL SELECT will retrieve the full names of the top 20 drivers based on their lap times.\n#columns: drivers.forename, drivers.surname, lapTimes.time\n#values: shortest lap time refers to MIN(time) in the format 'MM:SS.mmm' or 'M:SS.mmm'\n#SELECT: SELECT drivers.forename, drivers.surname\n#SQL-like: Show drivers.forename, drivers.surname, WHERE lapTimes.time is the minimum, ORDER BY lapTimes.time LIMIT 20\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId ORDER BY T2.time LIMIT 20\n```"
    ],
    "199": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of non-carcinogenic molecules that contain sodium atoms, so the SQL SELECT will count the distinct molecule IDs where the element is sodium and the label indicates non-carcinogenic.\n#columns: DISTINCT molecule.molecule_id, molecule.label, atom.element\n#values: non-carcinogenic refers to molecule.label = '-', sodium atoms refer to atom.element = 'na'\n#SELECT: how many sodium atoms refer to COUNT(DISTINCT molecule.molecule_id)\n#SQL-like: Show COUNT(DISTINCT molecule.molecule_id), WHERE atom.element = 'na' AND molecule.label = '-'\n#SQL: SELECT COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'na' AND T2.label = '-'\n```"
    ],
    "1310": [
        "```\n#reason: The question wants to calculate the average prothrombin time for male patients with a normal prothrombin time, so the SQL SELECT will compute AVG(PT) and filter by Sex = 'M' and PT < 14.\n#columns: Patient.SEX, Laboratory.PT\n#values: male refers to Patient.SEX = 'M', normal prothrombin time refers to Laboratory.PT < 14\n#SELECT: average prothrombin time refer to AVG(Laboratory.PT)\n#SQL-like: Show AVG(Laboratory.PT), WHERE Patient.SEX = 'M' AND Laboratory.PT < 14\n#SQL: SELECT AVG(Laboratory.PT) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.SEX = 'M' AND Laboratory.PT < 14\n```"
    ],
    "654": [
        "```\n#reason: The question wants to display the \"display name\" and \"location\" of the user who owned the excerpt post with the \"hypothesis-testing\" tag, so the SQL SELECT will filter based on the tag and retrieve the corresponding user information.\n#columns: users.DisplayName, users.Location\n#values: 'hypothesis-testing' refers to tags.TagName = 'hypothesis-testing'\n#SELECT: SELECT users.DisplayName, users.Location\n#SQL-like: Show users.DisplayName, users.Location WHERE tags.TagName = 'hypothesis-testing'\n#SQL: SELECT T1.DisplayName, T1.Location FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId INNER JOIN tags AS T3 ON T2.Id = T3.ExcerptPostId WHERE T3.TagName = 'hypothesis-testing'\n```"
    ],
    "679": [
        "```\n#reason: The question requires displaying \"which post\" with the \"highest score\". The highest score is determined by MAX(Score), and we need to include the post's id and title's name.\n#columns: posts.Id, posts.Title\n#values: None\n#SELECT: SELECT id and title's name refer to posts.Id, posts.Title\n#SQL-like: Show posts.Id, posts.Title, ORDER BY Score DESC LIMIT 1\n#SQL: SELECT Id, Title FROM posts ORDER BY Score DESC LIMIT 1\n```"
    ],
    "554": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the user who has obtained the most number of badges, so the SQL SELECT will count the badges per user and find the maximum.\n#columns: badges.UserId, users.DisplayName\n#values: most number of badges refers to MAX(COUNT(Id))\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE the user has the maximum number of badges, GROUP BY badges.UserId, ORDER BY COUNT(badges.Id) DESC LIMIT 1\n#SQL: SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId GROUP BY T2.UserId ORDER BY COUNT(T2.Id) DESC LIMIT 1\n```"
    ],
    "273": [
        "```\n#reason: The question wants to calculate the percentage of the element chlorine in carcinogenic molecules, so the SQL SELECT will involve counting the occurrences of chlorine in the element column and dividing it by the total number of carcinogenic molecules.\n#columns: atom.element, molecule.label, molecule.molecule_id\n#values: 'chlorine' refers to atom.element = 'cl', 'carcinogenic' refers to molecule.label = '+'\n#SELECT: percentage of element chlorine in carcinogenic molecules refer to DIVIDE(SUM(element = 'cl'), COUNT(molecule_id)) as percentage\n#SQL-like: Show DIVIDE(SUM(element = 'cl'), COUNT(molecule_id)), WHERE label = '+'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.element = 'cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'\n```"
    ],
    "1380": [
        "```\n#reason: The question wants to calculate the total amount of money spent for food, so the SQL SELECT SUM(spent) and the filtering condition is category = 'Food'.\n#columns: budget.category, budget.spent\n#values: spent for food refers to category = 'Food' \n#SELECT: SELECT SUM(budget.spent) \n#SQL-like: Show SUM(budget.spent), WHERE budget.category = 'Food'\n#SQL: SELECT SUM(spent) FROM budget WHERE category = 'Food'\n```"
    ],
    "84": [
        "```\n#reason: The question wants to identify the two most common first names among school administrators and indicate the district they administer, so the SQL SELECT will group by the administrator's first name and count occurrences, then limit the results to the top two.\n#columns: schools.AdmFName1, schools.District\n#values: None, as there are no specific filtering conditions in the question.\n#SELECT: SELECT the two most common first names refer to schools.AdmFName1 and indicate the district refer to schools.District\n#SQL-like: Show schools.AdmFName1, schools.District GROUP BY schools.AdmFName1 ORDER BY COUNT(schools.AdmFName1) DESC LIMIT 2\n#SQL: SELECT schools.AdmFName1, schools.District FROM schools GROUP BY schools.AdmFName1 ORDER BY COUNT(schools.AdmFName1) DESC LIMIT 2\n```"
    ],
    "1479": [
        "```\n#reason: The question wants to identify the year with the highest gas consumption paid in CZK. The year is derived from the first four characters of the Date values in the yearmonth table, and the consumption is summed to find the maximum.\n#columns: yearmonth.Date, yearmonth.Consumption\n#values: 'paid in CZK' refers to customers.Currency = 'CZK'\n#SELECT: SELECT substr(yearmonth.Date, 1, 4) refer to yearmonth.Date, SUM(yearmonth.Consumption) refer to yearmonth.Consumption\n#SQL-like: Show substr(yearmonth.Date, 1, 4), SUM(yearmonth.Consumption), WHERE customers.Currency = 'CZK', GROUP BY substr(yearmonth.Date, 1, 4), ORDER BY SUM(yearmonth.Consumption) DESC LIMIT 1\n#SQL: SELECT substr(yearmonth.Date, 1, 4) FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE customers.Currency = 'CZK' GROUP BY substr(yearmonth.Date, 1, 4) ORDER BY SUM(yearmonth.Consumption) DESC LIMIT 1\n```"
    ],
    "771": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the name of superheroes with flight power, so the SQL SELECT will retrieve superhero_name from the superhero table and filter by power_name from the superpower table.\n#columns: superhero.superhero_name, superpower.power_name\n#values: flight power refers to superpower.power_name = 'Flight'\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE superpower.power_name = 'Flight'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Flight'\n```"
    ],
    "1259": [
        "```\n#reason: The question wants to list the diseases of patients born after January 1, 1985, who have a normal Rhuematoid Factor, so the SQL SELECT will include the Diagnosis column and apply filters for the birthdate and Rhuematoid Factor.\n#columns: Patient.Diagnosis, Patient.Birthday, Laboratory.RA\n#values: born after 1985-1-1 refer to strftime('%Y', Patient.Birthday) >= '1985', normal Rhuematoid Factor refer to Laboratory.RA IN ('-', '+-')\n#SELECT: SELECT Patient.Diagnosis refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis, WHERE strftime('%Y', Patient.Birthday) >= '1985' AND Laboratory.RA IN ('-', '+-')\n#SQL: SELECT Patient.Diagnosis FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', Patient.Birthday) >= '1985' AND Laboratory.RA IN ('-', '+-')\n```"
    ],
    "798": [
        "```\n#reason: The question wants to display the publisher for specific superheroes, so the SQL SELECT will retrieve the publisher_name based on the superhero_name filters.\n#columns: publisher.publisher_name, superhero.superhero_name\n#values: 'Hawkman' refer to superhero.superhero_name = 'Hawkman', 'Karate Kid' refer to superhero.superhero_name = 'Karate Kid', 'Speedy' refer to superhero.superhero_name = 'Speedy'\n#SELECT: SELECT publisher.publisher_name refer to publisher.publisher_name\n#SQL-like: Show publisher.publisher_name WHERE superhero.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')\n#SQL: SELECT T1.publisher_name FROM publisher AS T1 INNER JOIN superhero AS T2 ON T1.id = T2.publisher_id WHERE T2.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy')\n```"
    ],
    "108": [
        "```\n#reason: The question requires displaying \"the first amount of transaction\" for the \"client who applied the biggest loan\". The biggest loan refers to MAX(loan.amount) and the first transaction refers to MIN(trans.date).\n#columns: loan.amount, trans.amount, trans.date\n#values: biggest loan refers to loan.amount = (SELECT MAX(amount) FROM loan), first transaction refers to trans.date = (SELECT MIN(date) FROM trans WHERE trans.account_id = (SELECT account_id FROM loan WHERE amount = (SELECT MAX(amount) FROM loan)))\n#SELECT: SELECT trans.amount refer to trans.amount\n#SQL-like: Show trans.amount, WHERE trans.date is the earliest for the client with the biggest loan\n#SQL: SELECT trans.amount FROM trans WHERE trans.account_id = (SELECT account_id FROM loan WHERE amount = (SELECT MAX(amount) FROM loan)) AND trans.date = (SELECT MIN(date) FROM trans WHERE account_id = (SELECT account_id FROM loan WHERE amount = (SELECT MAX(amount) FROM loan)))\n```"
    ],
    "769": [
        "```\n#reason: The question wants to identify which superhero has the highest durability, so the SQL SELECT will include the superhero's name and the maximum durability value filtered by the publisher's name.\n#columns: superhero.superhero_name, hero_attribute.attribute_value, publisher.publisher_name\n#values: 'published by Dark Horse Comics' refer to publisher.publisher_name = 'Dark Horse Comics', 'most durability' refer to attribute.attribute_name = 'Durability'\n#SELECT: SELECT superhero.superhero_name, MAX(hero_attribute.attribute_value) refer to superhero.superhero_name, hero_attribute.attribute_value.\n#SQL-like: Show superhero.superhero_name, MAX(hero_attribute.attribute_value) WHERE publisher.publisher_name = 'Dark Horse Comics' GROUP BY superhero.superhero_name ORDER BY hero_attribute.attribute_value DESC LIMIT 1\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN publisher AS T3 ON T1.publisher_id = T3.id WHERE T3.publisher_name = 'Dark Horse Comics' AND T2.attribute_id = (SELECT id FROM attribute WHERE attribute_name = 'Durability') ORDER BY T2.attribute_value DESC LIMIT 1\n```"
    ],
    "557": [
        "```\n#reason: The question wants to calculate the percentage of posts owned by elder users among those with a score of over 5, so the SQL SELECT will count the posts owned by users older than 65 and divide it by the total number of posts with a score greater than 5, then multiply by 100.\n#columns: posts.Id, users.Age\n#values: score of over 5 refers to posts.Score > 5, elder user refers to users.Age > 65\n#SELECT: SELECT CAST(SUM(CASE WHEN users.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(posts.Id) \n#SQL-like: Show CAST(SUM(CASE WHEN users.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(posts.Id) WHERE posts.Score > 5\n#SQL: SELECT CAST(SUM(CASE WHEN T2.Age > 65 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T1.Score > 5\n```"
    ],
    "582": [
        "```\n#reason: The question wants to list the title of posts which were edited by Vebjorn Ljosa, so the SQL SELECT will retrieve the post titles where the last editor's display name matches Vebjorn Ljosa.\n#columns: posts.Title, posts.LastEditorUserId, users.DisplayName\n#values: \"edited by Vebjorn Ljosa\" refer to users.DisplayName = 'Vebjorn Ljosa'\n#SELECT: SELECT posts.Title refer to posts.Title\n#SQL-like: Show posts.Title WHERE users.DisplayName = 'Vebjorn Ljosa'\n#SQL: SELECT T1.Title FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Vebjorn Ljosa'\n```"
    ],
    "658": [
        "```\n#reason: The question wants to display the titles of the top 5 posts with the highest popularity, so the SQL SELECT will retrieve the titles ordered by view count in descending order and limit the results to 5.\n#columns: posts.Title, posts.ViewCount\n#values: None\n#SELECT: SELECT Title refer to posts.Title\n#SQL-like: Show Title, ORDER BY ViewCount DESC LIMIT 5\n#SQL: SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5\n```"
    ],
    "234": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to know the count of bonds involving a specific atom in a specific molecule, so the SQL SELECT COUNT(bond.bond_id) and the conditions are set for molecule_id and the involved atom.\n#columns: bond.bond_id\n#values: molecule TR009 refers to bond.molecule_id = 'TR009' and involved atom 12 refers to (connected.atom_id = 'TR009_12' OR connected.atom_id2 = 'TR009_12')\n#SELECT: SELECT COUNT(bond.bond_id) refer to bond.bond_id\n#SQL-like: COUNT(bond.bond_id), WHERE bond.molecule_id = 'TR009' AND (connected.atom_id = 'TR009_12' OR connected.atom_id2 = 'TR009_12')\n#SQL: SELECT COUNT(T1.bond_id) FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.molecule_id = 'TR009' AND (T2.atom_id = 'TR009_12' OR T2.atom_id2 = 'TR009_12')\n```"
    ],
    "589": [
        "```\n#reason: The question wants to identify the user ID with the highest reputation, so the SQL SELECT will fetch the user ID corresponding to the maximum reputation.\n#columns: users.Id, users.Reputation\n#values: highest reputation refers to Max(Reputation)\n#SELECT: SELECT user ID refer to users.Id\n#SQL-like: Show users.Id, ORDER BY users.Reputation DESC LIMIT 1\n#SQL: SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1\n```"
    ],
    "1112": [
        "```\n#reason: The question wants to display the \"chance creation crossing class\" for \"Hull City\" on \"2010-02-22\", so the SQL SELECT will retrieve the chance creation crossing class from the Team_Attributes table where the team's long name matches \"Hull City\" and the date matches \"2010-02-22 00:00:00\".\n#columns: Team_Attributes.chanceCreationCrossingClass, Team.team_long_name, Team_Attributes.date\n#values: 'Hull City' refers to Team.team_long_name = 'Hull City', '2010-02-22' refers to Team_Attributes.date = '2010-02-22 00:00:00'\n#SELECT: SELECT chanceCreationCrossingClass refer to Team_Attributes.chanceCreationCrossingClass\n#SQL-like: Show Team_Attributes.chanceCreationCrossingClass, WHERE Team.team_long_name = 'Hull City' AND Team_Attributes.date = '2010-02-22 00:00:00'\n#SQL: SELECT T1.chanceCreationCrossingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'Hull City' AND T2.date = '2010-02-22 00:00:00'\n```"
    ],
    "765": [
        "```\n#reason: The question wants to determine the count of heroes that possess the stealth power, so the SQL SELECT will count the number of heroes associated with the stealth power.\n#columns: hero_power.hero_id\n#values: power_name = 'Stealth' refers to superpower.power_name = 'Stealth'\n#SELECT: How many heroes refer to COUNT(hero_power.hero_id)\n#SQL-like: Show COUNT(hero_power.hero_id), WHERE superpower.power_name = 'Stealth'\n#SQL: SELECT COUNT(T1.hero_id) FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T2.power_name = 'Stealth'\n```"
    ],
    "623": [
        "```\n#reason: The question wants to count the number of elders who obtained the \"Supporter\" badge, so the SQL SELECT will count the users who are elders and have the \"Supporter\" badge.\n#columns: badges.Name, users.Age\n#values: \"Supporter\" refers to badges.Name = 'Supporter', elders refer to users.Age > 65\n#SELECT: COUNT(users.Id) refer to users.Id\n#SQL-like: Show COUNT(users.Id) WHERE badges.Name = 'Supporter' AND users.Age > 65\n#SQL: SELECT COUNT(T1.Id) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Supporter' AND T1.Age > 65\n```"
    ],
    "846": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the reference names of the drivers who are eliminated in the first qualifying period of the race number 20. This involves filtering by race ID and ensuring that the time in the first qualifying period is present, while also limiting the result to the five drivers with the maximum qualifying times. \n#columns: qualifying.driverId, drivers.driverRef\n#values: 'race number 20' refers to qualifying.raceId = 20, 'drivers who are eliminated in the first qualifying period' refers to qualifying.q1 IS NOT NULL\n#SELECT: SELECT the reference names of the drivers refer to drivers.driverRef\n#SQL-like: Show drivers.driverRef, WHERE qualifying.raceId = 20 AND qualifying.q1 IS NOT NULL ORDER BY qualifying.q1 DESC LIMIT 5\n#SQL: SELECT T2.driverRef FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 20 AND T1.q1 IS NOT NULL ORDER BY T1.q1 DESC LIMIT 5\n```"
    ],
    "332": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of molecules that have single bonds, so the SQL SELECT will count the bond entries with a specific bond type and filter by molecule IDs.\n#columns: bond.bond_type, bond.molecule_id\n#values: single bond refers to bond.bond_type = '-', molecules between TR004 to TR010 refers to bond.molecule_id BETWEEN 'TR004' AND 'TR010'\n#SELECT: SELECT COUNT(bond.bond_type) refer to COUNT(bond.bond_type)\n#SQL-like: Show COUNT(bond.bond_type), WHERE bond.bond_type = '-' AND bond.molecule_id BETWEEN 'TR004' AND 'TR010'\n#SQL: SELECT COUNT(bond.bond_type) FROM bond WHERE bond.bond_type = '-' AND bond.molecule_id BETWEEN 'TR004' AND 'TR010'\n```"
    ],
    "1161": [
        "```\n#reason: The question wants to calculate the average anti-cardiolipin antibody (IgG) concentration for in-patients aged 50 and above, so the SQL SELECT will compute AVG(aCL IgG) while filtering for in-patients and the specified age condition.\n#columns: Patient.Birthday, Examination.`aCL IgG`, Patient.Admission\n#values: in-patient refers to Admission = '+' and age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'\n#SELECT: SELECT AVG(`aCL IgG`) refer to AVG(Examination.`aCL IgG`)\n#SQL-like: Show AVG(Examination.`aCL IgG`), WHERE Patient.Admission = '+' AND SUBTRACT(year(current_timestamp), year(Patient.Birthday)) >= '50'\n#SQL: SELECT AVG(T1.`aCL IgG`) FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.Admission = '+' AND (strftime('%Y', 'now') - strftime('%Y', T2.Birthday)) >= 50\n```"
    ],
    "855": [
        "```\n#reason: The question wants to find the URL where information about the races held on Sepang International Circuit can be found, so the SQL SELECT will retrieve the url from the races table where the circuit name matches 'Sepang International Circuit'.\n#columns: races.url\n#values: 'Sepang International Circuit' refer to circuits.name = 'Sepang International Circuit'\n#SELECT: the information refer to races.url\n#SQL-like: Show races.url WHERE circuits.name = 'Sepang International Circuit'\n#SQL: SELECT T1.url FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Sepang International Circuit'\n```"
    ],
    "1136": [
        "```\n#reason: Analyze how to generate SQL based on the question. the question wants to know how many players had the highest potential score for crossing that preferred to use their left feet while attacking, so the SQL SELECT will count players filtered by the conditions of the highest crossing score and preferred foot.\n#columns: Player_Attributes.crossing, Player_Attributes.preferred_foot, Player_Attributes.id\n#values: highest potential score for crossing refer to crossing = (SELECT MAX(crossing) FROM Player_Attributes), preferred to use their left foots while attacking refer to preferred_foot = 'left'\n#SELECT: how many players refer to COUNT(id)\n#SQL-like: Show COUNT(id), WHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes) AND preferred_foot = 'left'\n#SQL: SELECT COUNT(id) FROM Player_Attributes WHERE crossing = (SELECT MAX(crossing) FROM Player_Attributes) AND preferred_foot = 'left'\n```"
    ],
    "34": [
        "```\n#reason: The question wants to determine the eligible free rate for students aged between 5 and 17 at a specific school run by Kacey Gibson, so the SQL SELECT will calculate the free rate based on the provided columns and filters.\n#columns: frpm.`Free Meal Count (Ages 5-17)`, frpm.`Enrollment (Ages 5-17)`\n#values: school run by Kacey Gibson refers to schools.AdmFName1 = 'Kacey' AND schools.AdmLName1 = 'Gibson'\n#SELECT: free rate for students between ages 5 and 17 refer to CAST(frpm.`Free Meal Count (Ages 5-17)` AS REAL) / CAST(frpm.`Enrollment (Ages 5-17)` AS REAL)\n#SQL-like: Show CAST(frpm.`Free Meal Count (Ages 5-17)` AS REAL) / CAST(frpm.`Enrollment (Ages 5-17)` AS REAL), WHERE schools.AdmFName1 = 'Kacey' AND schools.AdmLName1 = 'Gibson'\n#SQL: SELECT CAST(frpm.`Free Meal Count (Ages 5-17)` AS REAL) / CAST(frpm.`Enrollment (Ages 5-17)` AS REAL) FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.AdmFName1 = 'Kacey' AND schools.AdmLName1 = 'Gibson'\n```"
    ],
    "660": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires displaying the \"owner user id\" of the \"most valuable post\". The \"most valuable post\" is defined by MAX(FavoriteCount).\n#columns: posts.OwnerUserId, posts.FavoriteCount\n#values: most valuable post refers to MAX(FavoriteCount)\n#SELECT: owner user id refers to posts.OwnerUserId\n#SQL-like: Show posts.OwnerUserId, ORDER BY posts.FavoriteCount DESC LIMIT 1\n#SQL: SELECT T1.OwnerUserId FROM posts AS T1 ORDER BY T1.FavoriteCount DESC LIMIT 1\n```"
    ],
    "175": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires counting the number of accounts that have an owner disposition and request for a statement to be generated upon a transaction. The 'owner disposition' refers to the 'OWNER' type in the disp table, and the 'request for a statement to be generated' is indicated by the frequency 'POPLATEK PO OBRATU'.\n#columns: account.account_id, disp.type, account.frequency\n#values: frequency = 'POPLATEK PO OBRATU' refers to account.frequency = 'POPLATEK PO OBRATU', owner disposition refers to disp.type = 'OWNER'\n#SELECT: How many accounts refers to COUNT(account.account_id)\n#SQL-like: Show COUNT(account.account_id) WHERE disp.type = 'OWNER' AND account.frequency = 'POPLATEK PO OBRATU'\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.type = 'OWNER' AND T1.frequency = 'POPLATEK PO OBRATU'\n```"
    ],
    "106": [
        "```\n#reason: The question asks for the biggest amount of transaction made by a client whose card was opened on a specific date. Therefore, the SQL SELECT statement will need to find the maximum transaction amount linked to that particular client.\n#columns: trans.amount, card.issued, client.client_id\n#values: 'opened in 1996/10/21' refers to 'card.issued = \"1996-10-21\"'\n#SELECT: SELECT max(trans.amount) refer to trans.amount\n#SQL-like: Show max(trans.amount) WHERE card.issued = \"1996-10-21\"\n#SQL: SELECT MAX(trans.amount) FROM trans INNER JOIN card ON trans.account_id = (SELECT account_id FROM disp WHERE disp.client_id = (SELECT client.client_id FROM client INNER JOIN disp ON client.client_id = disp.client_id WHERE disp.disp_id = card.disp_id)) WHERE card.issued = \"1996-10-21\"\n```"
    ],
    "1163": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the age of the youngest patient when they initially arrived at the hospital, so the SQL SELECT will calculate the age by subtracting the year of the patient's birthday from the year of their first date at the hospital and will filter for the youngest patient.\n#columns: Patient.`First Date`, Patient.Birthday\n#values: the youngest patient refers to MIN(Patient.Birthday)\n#SELECT: SELECT SUBTRACT(YEAR(`First Date`), YEAR(Birthday)) refer to Patient.`First Date`, Patient.Birthday\n#SQL-like: Show SUBTRACT(YEAR(`First Date`), YEAR(Birthday)) ORDER BY Birthday LIMIT 1\n#SQL: SELECT YEAR(`First Date`) - YEAR(Birthday) FROM Patient ORDER BY Birthday ASC LIMIT 1\n```"
    ],
    "186": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of male clients who request for weekly statements, so the SQL SELECT will sum the male clients who requested weekly statements and divide it by the total count of clients who requested those statements, multiplying by 100 for percentage.\n#columns: client.gender, account.frequency\n#values: 'male clients' refer to client.gender = 'M', 'weekly statements' refer to account.frequency = 'POPLATEK TYDNE'\n#SELECT: SELECT percentage of male clients who requested weekly statements refer to COUNT(CASE WHEN client.gender = 'M' THEN 1 END) / COUNT(client.gender) * 100\n#SQL-like: Show COUNT(CASE WHEN client.gender = 'M' THEN 1 END) / COUNT(client.gender) * 100, WHERE account.frequency = 'POPLATEK TYDNE'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.gender = 'M' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.gender) FROM client AS T1 INNER JOIN account AS T2 ON T1.client_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE'\n```"
    ],
    "1257": [
        "```\n#reason: The question wants to count the number of patients whose creatinine level is abnormal and who are not yet 70 years old. This requires filtering based on the creatinine level and calculating age using the birthdate.\n#columns: Patient.ID, Laboratory.CRE, Patient.Birthday\n#values: creatinine level is abnormal refers to Laboratory.CRE >= 1.5, aren't 70 yet refers to SUBTRACT((YEAR(CURDATE()), YEAR(Patient.Birthday))) < 70\n#SELECT: how many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Laboratory.CRE >= 1.5 AND (strftime('%Y', 'now') - strftime('%Y', Patient.Birthday)) < 70\n#SQL: SELECT COUNT(P1.ID) FROM Patient AS P1 INNER JOIN Laboratory AS L1 ON P1.ID = L1.ID WHERE L1.CRE >= 1.5 AND (strftime('%Y', 'now') - strftime('%Y', P1.Birthday)) < 70\n```"
    ],
    "1399": [
        "```\n#reason: The question wants to determine if a specific member attended a specific event, so the SQL SELECT will check for attendance records matching the member's name and the event's name.\n#columns: attendance.link_to_member, attendance.link_to_event, member.first_name, member.last_name, event.event_name\n#values: 'Maya Mclean' refers to member.first_name = 'Maya' AND member.last_name = 'Mclean', 'Women's Soccer' refers to event.event_name = 'Women's Soccer'\n#SELECT: SELECT attendance.link_to_member, attendance.link_to_event FROM attendance INNER JOIN member ON attendance.link_to_member = member.member_id INNER JOIN event ON attendance.link_to_event = event.event_id WHERE member.first_name = 'Maya' AND member.last_name = 'Mclean' AND event.event_name = 'Women's Soccer'\n#SQL-like: Show attendance.link_to_member, attendance.link_to_event WHERE member.first_name = 'Maya' AND member.last_name = 'Mclean' AND event.event_name = 'Women's Soccer'\n#SQL: SELECT attendance.link_to_member, attendance.link_to_event FROM attendance INNER JOIN member ON attendance.link_to_member = member.member_id INNER JOIN event ON attendance.link_to_event = event.event_id WHERE member.first_name = 'Maya' AND member.last_name = 'Mclean' AND event.event_name = 'Women's Soccer'\n```"
    ],
    "624": [
        "```\n#reason: The question requires displaying the \"name of user\" with a specific \"ID of 30\". The \"name of user\" refers to DisplayName, and the condition \"ID of 30\" means Id = 30.\n#columns: users.DisplayName\n#values: ID of 30 refers to users.Id = 30\n#SELECT: name of user refers to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE users.Id = 30\n#SQL: SELECT T1.DisplayName FROM users AS T1 WHERE T1.Id = 30\n```"
    ],
    "1513": [
        "```\n#reason: The question wants to identify the country of the gas station that had the first paid customer on a specific date, so the SQL SELECT will involve filtering by the date and finding the minimum transaction date for that day.\n#columns: gasstations.Country, transactions_1k.Date\n#values: 'first paid customer on 2012/8/25' refer to transactions_1k.Date = '2012-08-25'\n#SELECT: SELECT gasstations.Country refer to gasstations.Country\n#SQL-like: Show gasstations.Country, WHERE transactions_1k.Date = '2012-08-25', ORDER BY transactions_1k.Date ASC LIMIT 1\n#SQL: SELECT T1.Country FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Date = '2012-08-25' ORDER BY T2.Date ASC LIMIT 1\n```"
    ],
    "932": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the years in which Lewis Hamilton participated in a Formula 1 race, so the SQL SELECT will focus on the distinct years from the races table where Lewis Hamilton is identified as a driver.\n#columns: DISTINCT races.year\n#values: 'Lewis Hamilton' refers to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SELECT: SELECT DISTINCT races.year\n#SQL-like: Show DISTINCT races.year, WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SQL: SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\n```"
    ],
    "1363": [
        "```\n#reason: The question wants to list all the departments under the College of Humanities and Social Sciences, so the SQL SELECT will target the department column from the major table where the college column matches 'College of Humanities and Social Sciences'.\n#columns: major.department\n#values: 'College of Humanities and Social Sciences' refer to major.college = 'College of Humanities and Social Sciences'\n#SELECT: SELECT major.department\n#SQL-like: Show major.department WHERE major.college = 'College of Humanities and Social Sciences'\n#SQL: SELECT department FROM major WHERE college = 'College of Humanities and Social Sciences'\n```"
    ],
    "1458": [
        "```\n#reason: The question wants to calculate the difference in the percentage of members in New Jersey and Vermont, so the SQL SELECT will compute the percentage of members in each state and then subtract them.\n#columns: member.position, member.zip, zip_code.state\n#values: 'New Jersey' refer to zip_code.state = 'New Jersey', 'Vermont' refer to zip_code.state = 'Vermont'\n#SELECT: SELECT SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) ) refer to member.position and zip_code.state.\n#SQL-like: Show SUBTRACT( DIVIDE( SUM(state = 'New Jersey'), COUNT(position = 'Member')), DIVIDE( SUM(state = 'Vermont'), COUNT(position = 'Member')) )\n#SQL: SELECT CAST(SUM(CASE WHEN T2.state = 'New Jersey' THEN 1 ELSE 0 END) AS REAL) / COUNT(CASE WHEN T1.position = 'Member' THEN 1 ELSE NULL END) - CAST(SUM(CASE WHEN T2.state = 'Vermont' THEN 1 ELSE 0 END) AS REAL) / COUNT(CASE WHEN T1.position = 'Member' THEN 1 ELSE NULL END) FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code\n```"
    ],
    "157": [
        "```\n#reason: The question wants to count the number of committed crimes in 1995 in the district of the account with the id 532, so the SQL SELECT COUNT(district.A15) and GROUP BY district.district_id will be used to summarize the permissions.\n#columns: district.A15, account.account_id, account.district_id, district.district_id\n#values: 'district of the account with the id 532' refer to account.account_id = 532 and account.district_id = district.district_id\n#SELECT: SELECT COUNT(district.A15) refer to district.A15\n#SQL-like: Show COUNT(district.A15) WHERE account.account_id = 532\n#SQL: SELECT COUNT(T2.A15) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.account_id = 532\n```"
    ],
    "1211": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to provide the ID and age of patients with lactate dehydrogenase levels above the normal range and within a specified range, so the SQL SELECT statement will include the relevant patient ID and the calculated age.\n#columns: Laboratory.ID, Patient.Birthday\n#values: lactate dehydrogenase (LDH) between 100-300 index above the normal range refers to 'LDH BETWEEN 600 AND 800'\n#SELECT: SELECT ID, SUBTRACT(year(current_timestamp), year(Birthday)) AS age refer to Laboratory.ID and the calculation of age from Patient.Birthday.\n#SQL-like: Show Laboratory.ID, SUBTRACT(year(current_timestamp), year(Birthday)), WHERE Laboratory.LDH BETWEEN 600 AND 800\n#SQL: SELECT T1.ID, (strftime('%Y', 'now') - strftime('%Y', T2.Birthday)) AS age FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.LDH BETWEEN 600 AND 800\n```"
    ],
    "753": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the names of the superheroes with a height from 170 to 190 who have no eye color. \"height from 170 to 190\" refers to height_cm BETWEEN 170 AND 190, and \"no eye color\" refers to colour = 'No Colour'.\n#columns: superhero.superhero_name, colour.colour\n#values: height from 170 to 190 refers to superhero.height_cm BETWEEN 170 AND 190, no eye color refers to colour.colour = 'No Colour'\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE superhero.height_cm BETWEEN 170 AND 190 AND colour.colour = 'No Colour'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.height_cm BETWEEN 170 AND 190 AND T2.colour = 'No Colour'\n```"
    ],
    "1035": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to filter teams based on their build-up play speed, so the SQL SELECT will retrieve the team_fifa_api_id of those teams.\n#columns: Team_Attributes.team_fifa_api_id, Team_Attributes.buildUpPlaySpeed\n#values: more than 50 but less than 60 build-up play speed refers to Team_Attributes.buildUpPlaySpeed > 50 AND Team_Attributes.buildUpPlaySpeed < 60\n#SELECT: SELECT team_fifa_api_id refer to Team_Attributes.team_fifa_api_id\n#SQL-like: Show Team_Attributes.team_fifa_api_id WHERE Team_Attributes.buildUpPlaySpeed > 50 AND Team_Attributes.buildUpPlaySpeed < 60\n#SQL: SELECT team_fifa_api_id FROM Team_Attributes WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60\n```"
    ],
    "1271": [
        "```\n#reason: The question wants to count the number of distinct patients with a normal anti-SSA who came to the hospital before 2000, so the SQL SELECT will count distinct Patient.ID where SSA is in ('-', '+-') and First Date is before 2000.\n#columns: Patient.ID, Patient.`First Date`, Laboratory.SSA\n#values: normal anti-SSA refers to Laboratory.SSA IN ('-', '+-'), came to the hospital before 2000 refers to YEAR(Patient.`First Date`) < 2000\n#SELECT: How many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.SSA IN ('-', '+-') AND YEAR(Patient.`First Date`) < 2000\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSA IN ('-', '+-') AND strftime('%Y', T1.`First Date`) < '2000'\n```"
    ],
    "370": [
        "```\n#reason: The question wants to count the number of borderless cards illustrated in Russian, so the SQL SELECT COUNT(*) from cards where borderColor = 'borderless' and language = 'Russian'.\n#columns: cards.borderColor, foreign_data.language\n#values: 'borderless' refers to cards.borderColor = 'borderless', 'Russian' refers to foreign_data.language = 'Russian'\n#SELECT: How many borderless cards refer to COUNT(*)\n#SQL-like: Show COUNT(*) WHERE cards.borderColor = 'borderless' AND foreign_data.language = 'Russian'\n#SQL: SELECT COUNT(*) FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.borderColor = 'borderless' AND foreign_data.language = 'Russian'\n```"
    ],
    "404": [
        "```\n#reason: The question wants to indicate the name of all the languages into which the set is translated, so the SQL SELECT will retrieve the set name and the corresponding languages based on the base set size.\n#columns: sets.name, set_translations.language\n#values: baseSetSize = 309 refers to sets.baseSetSize = 309\n#SELECT: SELECT sets.name, set_translations.language\n#SQL-like: Show sets.name, set_translations.language WHERE sets.baseSetSize = 309\n#SQL: SELECT T1.name, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309\n```"
    ],
    "128": [
        "```\n#reason: The question requires to display the top nine districts by the number of female account holders, so the SQL SELECT will count account holders grouped by districts and filter by female gender.\n#columns: district.A2, COUNT(client.client_id)\n#values: female account holders refer to client.gender = 'F'\n#SELECT: top nine districts refer to district.A2, and the number of female account holders refers to COUNT(client.client_id)\n#SQL-like: Show district.A2, COUNT(client.client_id) WHERE client.gender = 'F' GROUP BY district.A2 ORDER BY COUNT(client.client_id) DESC LIMIT 9\n#SQL: SELECT district.A2, COUNT(client.client_id) FROM client INNER JOIN account ON client.client_id = account.account_id INNER JOIN district ON client.district_id = district.district_id WHERE client.gender = 'F' GROUP BY district.A2 ORDER BY COUNT(client.client_id) DESC LIMIT 9\n```"
    ],
    "59": [
        "```\n#reason: The question want to find \"the website\" for \"the schools\" under the administrations of \"Mike Larson\" and \"Dante Alvarez\". The filtering conditions are based on the administrators' first and last names.\n#columns: schools.Website\n#values: 'administration is Mike Larson' refer to schools.AdmFName1 = 'Mike' AND schools.AdmLName1 = 'Larson', 'administration is Dante Alvarez' refer to schools.AdmFName1 = 'Dante' AND schools.AdmLName1 = 'Alvarez'\n#SELECT: SELECT website refer to schools.Website\n#SQL-like: Show schools.Website WHERE (schools.AdmFName1 = 'Mike' AND schools.AdmLName1 = 'Larson') OR (schools.AdmFName1 = 'Dante' AND schools.AdmLName1 = 'Alvarez')\n#SQL: SELECT schools.Website FROM schools WHERE (schools.AdmFName1 = 'Mike' AND schools.AdmLName1 = 'Larson') OR (schools.AdmFName1 = 'Dante' AND schools.AdmLName1 = 'Alvarez')\n```"
    ],
    "1405": [
        "```\n#reason: The question wants to calculate the amount budgeted for the 'April Speaker' event and list the budgeted categories in ascending order. The SQL SELECT will include the summation of the amount for the specified event and group by the budget category.\n#columns: budget.category, budget.amount\n#values: 'April Speaker' refer to event.event_name = 'April Speaker'\n#SELECT: SELECT SUM(budget.amount) as total_budgeted, budget.category refer to budget.category\n#SQL-like: SHOW SUM(budget.amount), budget.category WHERE event.event_name = 'April Speaker' GROUP BY budget.category ORDER BY budget.amount ASC\n#SQL: SELECT SUM(budget.amount) AS total_budgeted, budget.category FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.event_name = 'April Speaker' GROUP BY budget.category ORDER BY budget.amount ASC\n```"
    ],
    "329": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine which carcinogenic molecule has the highest number of atoms, so the SQL SELECT will focus on counting the atoms related to carcinogenic molecules and filtering based on the label.\n#columns: molecule.molecule_id, atom.atom_id\n#values: label = '+' refer to molecule.label = '+'\n#SELECT: SELECT molecule.molecule_id refer to molecule.molecule_id\n#SQL-like: Show molecule.molecule_id, GROUP BY molecule.molecule_id, ORDER BY COUNT(atom.molecule_id) DESC LIMIT 1\n#SQL: SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' GROUP BY T1.molecule_id ORDER BY COUNT(T2.molecule_id) DESC LIMIT 1\n```"
    ],
    "811": [
        "```\n#reason: The question wants to display the alignment and superpowers of the superhero named Atom IV, so the SQL SELECT will retrieve the alignment and power_name associated with the superhero's name.\n#columns: alignment.alignment, superpower.power_name\n#values: superhero named Atom IV refer to superhero.superhero_name = 'Atom IV'\n#SELECT: alignment refers to alignment.alignment, superpowers refers to superpower.power_name\n#SQL-like: Show alignment.alignment, superpower.power_name WHERE superhero.superhero_name = 'Atom IV'\n#SQL: SELECT T1.alignment, T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T3 ON T1.id = T3.hero_id INNER JOIN superpower AS T2 ON T3.power_id = T2.id INNER JOIN alignment AS T4 ON T1.alignment_id = T4.id WHERE T1.superhero_name = 'Atom IV'\n```"
    ],
    "33": [
        "```\n#reason: The question wants to display the websites address of the schools with a free meal count of 1,900-2,000 to students aged 5-17, so the SQL SELECT will include the website and school name with the filtering condition on the free meal count.\n#columns: schools.Website, schools.School\n#values: free meal count of 1,900-2,000 refers to 'Free Meal Count (Ages 5-17) BETWEEN 1900 AND 2000'\n#SELECT: SELECT schools.Website, schools.School\n#SQL-like: Show schools.Website, schools.School, WHERE Free Meal Count (Ages 5-17) BETWEEN 1900 AND 2000\n#SQL: SELECT schools.Website, schools.School FROM schools WHERE \"Free Meal Count (Ages 5-17)\" BETWEEN 1900 AND 2000\n```"
    ],
    "824": [
        "```\n#reason: The question wants to identify superheroes who can control wind and list their names in alphabetical order, so the SQL SELECT will retrieve superhero names where the power is 'Wind Control' and order them alphabetically.\n#columns: superhero.superhero_name\n#values: 'can control wind' refer to superpower.power_name = 'Wind Control'\n#SELECT: SELECT superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE superpower.power_name = 'Wind Control' ORDER BY superhero.superhero_name ASC\n#SQL: SELECT superhero.superhero_name FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Wind Control' ORDER BY superhero.superhero_name ASC\n```"
    ],
    "1033": [
        "```\n#reason: The question wants to calculate the average height of players born between 1990 and 1995, so the SQL SELECT will include the average height calculated by dividing the sum of heights by the count of player IDs, with the filtering condition specifying the birth date range.\n#columns: Player.birthday, Player.height, Player.id\n#values: players born between 1990 and 1995 refers to Player.birthday >= '1990-01-01 00:00:00' AND Player.birthday < '1996-01-01 00:00:00'\n#SELECT: average height refer to AVG(height)\n#SQL-like: Show AVG(height), WHERE Player.birthday >= '1990-01-01 00:00:00' AND Player.birthday < '1996-01-01 00:00:00'\n#SQL: SELECT CAST(SUM(height) AS REAL) / COUNT(id) FROM Player WHERE birthday >= '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00'\n```"
    ],
    "145": [
        "```\n#reason: The question wants to identify account holder identification numbers whose transactions on the credit card are less than the average amount in 1998, specifically for credit card withdrawals. Therefore, the SQL SELECT will filter transactions based on the operation type and the year, and compare the transaction amounts to the average.\n#columns: trans.account_id, trans.amount\n#values: 'amount is less than the average' refers to trans.amount < (SELECT AVG(trans.amount) FROM trans WHERE strftime('%Y', trans.date) = '1998') AND 'in 1998' refers to strftime('%Y', trans.date) = '1998' AND 'operation = VYBER KARTOU' refers to trans.operation = 'VYBER KARTOU'\n#SELECT: SELECT account holder identification numbers refer to trans.account_id\n#SQL-like: Show trans.account_id WHERE trans.amount < (SELECT AVG(trans.amount) FROM trans WHERE strftime('%Y', trans.date) = '1998') AND strftime('%Y', trans.date) = '1998' AND trans.operation = 'VYBER KARTOU'\n#SQL: SELECT T1.account_id FROM trans AS T1 WHERE T1.amount < (SELECT AVG(T2.amount) FROM trans AS T2 WHERE strftime('%Y', T2.date) = '1998') AND strftime('%Y', T1.date) = '1998' AND T1.operation = 'VYBER KARTOU'\n```"
    ],
    "1521": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of transactions that happened in CZE during a specific time frame on a specific date, so the SQL SELECT will count the transactions filtered by the date, time, and country.\n#columns: transactions_1k.TransactionID, gasstations.Country\n#values: 'Czech Republic' refers to gasstations.Country = 'CZE', '2012/8/26' refers to transactions_1k.Date = '2012-08-26', 'during 8:00-9:00' refers to transactions_1k.Time BETWEEN '08:00:00' AND '09:00:00'\n#SELECT: SELECT COUNT(transactions_1k.TransactionID) refer to transactions_1k.TransactionID\n#SQL-like: Show COUNT(transactions_1k.TransactionID), WHERE transactions_1k.Date = '2012-08-26' AND transactions_1k.Time BETWEEN '08:00:00' AND '09:00:00' AND gasstations.Country = 'CZE'\n#SQL: SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'\n```"
    ],
    "97": [
        "```\n#reason: The question wants to list the id number of clients who choose the statement of issuance after transaction categorized as 'DISPONENT', so the SQL SELECT will filter clients based on the disp.type and account.frequency.\n#columns: disp.client_id, account.frequency\n#values: 'statement of issuance after transaction' refers to disp.type = 'DISPONENT' AND 'POPLATEK PO OBRATU' refers to account.frequency = 'POPLATEK PO OBRATU'\n#SELECT: SELECT id number of client refer to disp.client_id\n#SQL-like: Show disp.client_id WHERE disp.type = 'DISPONENT' AND account.frequency = 'POPLATEK PO OBRATU'\n#SQL: SELECT T1.client_id FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.type = 'DISPONENT' AND T2.frequency = 'POPLATEK PO OBRATU'\n```"
    ],
    "469": [
        "```\n#reason: The question wants to determine if the card set \"Angel of Mercy\" appears on Magic: The Gathering Online, so the SQL SELECT checks if the mtgoCode is NOT NULL for the specified card name.\n#columns: cards.name, sets.mtgoCode\n#values: 'Angel of Mercy' refers to cards.name = 'Angel of Mercy'\n#SELECT: SELECT cards.name, sets.mtgoCode\n#SQL-like: Show cards.name, sets.mtgoCode WHERE cards.name = 'Angel of Mercy' AND sets.mtgoCode IS NOT NULL\n#SQL: SELECT T1.name, T2.mtgoCode FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.name = 'Angel of Mercy' AND T2.mtgoCode IS NOT NULL\n```"
    ],
    "368": [
        "```\n#reason: The question wants to calculate the percentage of borderless cards, so the SQL SELECT will count the cards with borderColor equal to 'borderless' and divide it by the total count of cards, multiplying by 100.\n#columns: cards.id, cards.borderColor\n#values: borderless card refers to 'borderColor = 'borderless''\n#SELECT: percentage of borderless cards refer to (Count(id) where borderColor = 'borderless') * 100 / Count(id)\n#SQL-like: Show (Count(id) where borderColor = 'borderless') * 100 / Count(id)\n#SQL: SELECT CAST(COUNT(CASE WHEN borderColor = 'borderless' THEN id END) AS REAL) * 100 / COUNT(id) FROM cards\n```"
    ],
    "601": [
        "```\n#reason: The question wants to display the score and the link type ID for a specific post ID. The filtering condition is that the post ID must be 395.\n#columns: posts.Score, postLinks.LinkTypeId\n#values: post ID 395 refers to posts.Id = 395\n#SELECT: score and link type ID refer to posts.Score, postLinks.LinkTypeId\n#SQL-like: Show posts.Score, postLinks.LinkTypeId WHERE posts.Id = 395\n#SQL: SELECT T1.Score, T2.LinkTypeId FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId WHERE T1.Id = 395\n```"
    ],
    "860": [
        "```\n#reason: The question wants to display the nationality of the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, so the SQL SELECT will retrieve the nationality from the drivers table and filter using the qualifying time and raceId.\n#columns: drivers.nationality, qualifying.q2, qualifying.raceId\n#values: race No. 355 refers to qualifying.raceId = 355, Q2 time of 0:01:40 refers to qualifying.q2 = '0:01:40'\n#SELECT: nationality refers to drivers.nationality\n#SQL-like: Show drivers.nationality WHERE qualifying.q2 = '0:01:40' AND qualifying.raceId = 355\n#SQL: SELECT T1.nationality FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.q2 = '0:01:40' AND T2.raceId = 355\n```"
    ],
    "807": [
        "```\n#reason: The question wants to identify the superpowers of the superhero with the full name 'Helen Parr', so the SQL SELECT will fetch the superpower names associated with that superhero.\n#columns: superpower.power_name\n#values: 'Helen Parr' refer to superhero.full_name = 'Helen Parr'\n#SELECT: superpowers refer to superpower.power_name\n#SQL-like: Show superpower.power_name, WHERE superhero.full_name = 'Helen Parr'\n#SQL: SELECT T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id WHERE T1.full_name = 'Helen Parr'\n```"
    ],
    "1118": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the names of players who are 35 years old and above, so the SQL SELECT will filter based on their birthday being more than 34 years ago from the current date.\n#columns: Player.player_name\n#values: 35 years old and above refers to datetime(CURRENT_TIMESTAMP,'localtime') - datetime(Player.birthday) > 34\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name WHERE datetime(CURRENT_TIMESTAMP,'localtime') - datetime(Player.birthday) > 34\n#SQL: SELECT Player.player_name FROM Player WHERE datetime(CURRENT_TIMESTAMP,'localtime') - datetime(Player.birthday) > 34\n```"
    ],
    "1389": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"which event has the lowest cost\", so the SQL SELECT will retrieve the event name and order by the cost in ascending order to get the event with the minimum cost.\n#columns: event.event_name, expense.cost\n#values: lowest cost refers to ORDER BY expense.cost ASC LIMIT 1\n#SELECT: SELECT event_name refer to event.event_name\n#SQL-like: Show event.event_name, ORDER BY expense.cost ASC LIMIT 1\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN expense AS T2 ON T1.event_id = T2.link_to_event ORDER BY T2.cost ASC LIMIT 1\n```"
    ],
    "499": [
        "```\n#reason: The question wants to count the number of translations of the name of the set \"Tenth Edition\", so the SQL SELECT will count the translations where the set name is 'Tenth Edition'.\n#columns: set_translations.translation\n#values: set \"Tenth Edition\" refers to sets.name = 'Tenth Edition'\n#SELECT: How many translations refer to COUNT(set_translations.translation)\n#SQL-like: Show COUNT(set_translations.translation), WHERE sets.name = 'Tenth Edition' AND set_translations.translation IS NOT NULL\n#SQL: SELECT COUNT(T1.translation) FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Tenth Edition' AND T1.translation IS NOT NULL\n```"
    ],
    "780": [
        "```\n#reason: The question wants to list the powers of a specific superhero named Hunter Zolomon, so the SQL SELECT will retrieve the power names associated with that superhero.\n#columns: superpower.power_name\n#values: 'Hunter Zolomon' refers to superhero.full_name = 'Hunter Zolomon'\n#SELECT: SELECT power_name refer to superpower.power_name\n#SQL-like: Show superpower.power_name, WHERE superhero.full_name = 'Hunter Zolomon'\n#SQL: SELECT T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id WHERE T1.full_name = 'Hunter Zolomon'\n```"
    ],
    "96": [
        "```\n#reason: The question wants to know how many customers choose statement of weekly issuance and are classified as Owner, so the SQL SELECT COUNT(disp.client_id) and COUNT(disp.client_id) will be used to count the number of clients that meet these criteria.\n#columns: disp.client_id, disp.type, account.frequency\n#values: 'weekly issuance' refer to account.frequency = 'POPLATEK TYDNE', 'Owner' refer to disp.type = 'OWNER'\n#SELECT: COUNT(disp.client_id) refer to COUNT(disp.client_id)\n#SQL-like: Show COUNT(disp.client_id), WHERE account.frequency = 'POPLATEK TYDNE' AND disp.type = 'OWNER'\n#SQL: SELECT COUNT(T1.client_id) FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.type = 'OWNER'\n```"
    ],
    "1061": [
        "```\n#reason: The question wants to count the number of players whose first names are Adam and weigh more than 170, so the SQL SELECT COUNT(Player.id) and COUNT(Player.id) will be used with the appropriate filtering conditions.\n#columns: Player.player_name, Player.weight\n#values: 'first names are Adam' refer to Player.player_name LIKE 'Adam%' and 'weigh more than 170' refer to Player.weight > 170\n#SELECT: SELECT COUNT(Player.id) refer to COUNT(Player.id)\n#SQL-like: Show COUNT(Player.id), WHERE Player.player_name LIKE 'Adam%' AND Player.weight > 170\n#SQL: SELECT COUNT(T1.id) FROM Player AS T1 WHERE T1.player_name LIKE 'Adam%' AND T1.weight > 170\n```"
    ],
    "640": [
        "```\n#reason: The question wants to calculate the difference in view count from posts posted by users with the display names \"Mornington\" and \"Amos\", so the SQL SELECT will involve summing view counts for these users and then subtracting them.\n#columns: posts.ViewCount, users.DisplayName\n#values: 'posted by Mornington' refer to users.DisplayName = 'Mornington', 'posted by Amos' refer to users.DisplayName = 'Amos'\n#SELECT: difference in view count referr to SUBTRACT(SUM(ViewCount where DisplayName = 'Mornington'), SUM(ViewCount where DisplayName = 'Amos'))\n#SQL-like: Show SUBTRACT(SUM(ViewCount where users.DisplayName = 'Mornington'), SUM(ViewCount where users.DisplayName = 'Amos'))\n#SQL: SELECT SUM(CASE WHEN U.DisplayName = 'Mornington' THEN P.ViewCount ELSE 0 END) - SUM(CASE WHEN U.DisplayName = 'Amos' THEN P.ViewCount ELSE 0 END) FROM posts AS P INNER JOIN users AS U ON P.OwnerUserId = U.Id\n```"
    ],
    "1524": [
        "```\n#reason: The question wants to find the nationality of the customer who spent 548.4 on a specific date, so the SQL SELECT will retrieve the nationality based on the transaction amount and date.\n#columns: customers.Country\n#values: 'spent 548.4' refer to transactions_1k.Price = 548.4 AND '2012/8/24' refer to transactions_1k.Date = '2012-08-24'\n#SELECT: SELECT nationality refer to customers.Country\n#SQL-like: Show customers.Country WHERE transactions_1k.Price = 548.4 AND transactions_1k.Date = '2012-08-24'\n#SQL: SELECT T2.Country FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Price = 548.4 AND T1.Date = '2012-08-24'\n```"
    ],
    "838": [
        "```\n#reason: The question requires displaying \"the full name of the superhero\". The filtering condition is \"superhero named Alien\".\n#columns: superhero.full_name\n#values: 'named Alien' refer to superhero.superhero_name = 'Alien'\n#SELECT: the full name of the superhero refers to superhero.full_name\n#SQL-like: Show superhero.full_name, WHERE superhero.superhero_name = 'Alien'\n#SQL: SELECT T1.full_name FROM superhero AS T1 WHERE T1.superhero_name = 'Alien'\n```"
    ],
    "710": [
        "```\n#reason: The question wants to find out how many comments have a score of 0 in posts that have exactly 1 comment, so the SQL SELECT will count the comments where the score is 0 and the post has a comment count of 1.\n#columns: posts.CommentCount, comments.Score\n#values: 'posts with 1 comment' refer to posts.CommentCount = 1, 'comments have 0 score' refer to comments.Score = 0\n#SELECT: SELECT COUNT(comments.Score) FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.CommentCount = 1 AND comments.Score = 0\n#SQL-like: Show COUNT(comments.Score), WHERE posts.CommentCount = 1 AND comments.Score = 0\n#SQL: SELECT COUNT(comments.Score) FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.CommentCount = 1 AND comments.Score = 0\n```"
    ],
    "627": [
        "```\n#reason: The question wants to determine the count of users who are classified as adults, defined by the age range of 19 to 65 years old.\n#columns: users.Id, users.Age\n#values: adult refers to Age BETWEEN 19 AND 65\n#SELECT: how many users refers to COUNT(Id)\n#SQL-like: Show COUNT(Id), WHERE Age BETWEEN 19 AND 65\n#SQL: SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65\n```"
    ],
    "272": [
        "```\n#reason: The question wants to list two molecule IDs of non-carcinogenic molecules that have a triple bond and contain carbon, so the SQL SELECT will filter based on the specified conditions.\n#columns: molecule.molecule_id\n#values: carbon refers to atom.element = 'c', triple bond refers to bond.bond_type = '#', label = '-' means molecules are non-carcinogenic refers to molecule.label = '-'\n#SELECT: SELECT DISTINCT molecule.molecule_id refer to molecule.molecule_id\n#SQL-like: Show DISTINCT molecule.molecule_id, WHERE atom.element = 'c' AND bond.bond_type = '#' AND molecule.label = '-'\n#SQL: SELECT DISTINCT T3.molecule_id FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id INNER JOIN bond AS T4 ON T2.bond_id = T4.bond_id INNER JOIN molecule AS T3 ON T4.molecule_id = T3.molecule_id WHERE T1.element = 'c' AND T4.bond_type = '#' AND T3.label = '-' LIMIT 2\n```"
    ],
    "1048": [
        "```\n#reason: The question wants to find the overall rating of the football player Gabriel Tamas in the year 2011, so the SQL SELECT will filter by the player's name and the year from the date.\n#columns: Player_Attributes.overall_rating, Player.player_name\n#values: 'football player Gabriel Tamas' refer to Player.player_name = 'Gabriel Tamas', 'in year 2011' refer to strftime('%Y', Player_Attributes.date) = '2011'\n#SELECT: overall rating refer to Player_Attributes.overall_rating\n#SQL-like: Show Player_Attributes.overall_rating, WHERE Player.player_name = 'Gabriel Tamas' AND strftime('%Y', Player_Attributes.date) = '2011'\n#SQL: SELECT T1.overall_rating FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Gabriel Tamas' AND strftime('%Y', T1.date) = '2011'\n```"
    ],
    "1212": [
        "```\n#reason: The question wants to determine the treatment status (inpatient or outpatient) of patients with alkaliphophatase (ALP) within the normal range, so the SQL SELECT will include the admission status and filter for ALP values.\n#columns: Laboratory.ALP, Patient.Admission\n#values: ALP within normal range refers to Laboratory.ALP < 300, inpatient refers to Patient.Admission = '+', outpatient refers to Patient.Admission = '-'\n#SELECT: SELECT content (format: 'were treated as inpatient or outpatient' refers to Patient.Admission)\n#SQL-like: Show Patient.Admission WHERE Laboratory.ALP < 300\n#SQL: SELECT Patient.Admission FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Laboratory.ALP < 300\n```"
    ],
    "37": [
        "```\n#reason: The question wants to find the complete address of the school with the lowest excellence rate, which is calculated as NumGE1500 / NumTstTakr. The complete address includes Street, City, Zip, and State.\n#columns: schools.Street, schools.City, schools.Zip, schools.State, satscores.NumGE1500, satscores.NumTstTakr\n#values: lowest excellence rate refers to (CAST(satscores.NumGE1500 AS REAL) / CAST(satscores.NumTstTakr AS REAL)) = (SELECT MIN(CAST(satscores.NumGE1500 AS REAL) / CAST(satscores.NumTstTakr AS REAL)) FROM satscores)\n#SELECT: SELECT content refers to schools.Street, schools.City, schools.Zip, schools.State\n#SQL-like: Show schools.Street, schools.City, schools.Zip, schools.State WHERE (CAST(satscores.NumGE1500 AS REAL) / CAST(satscores.NumTstTakr AS REAL)) = (SELECT MIN(CAST(satscores.NumGE1500 AS REAL) / CAST(satscores.NumTstTakr AS REAL)) FROM satscores)\n#SQL: SELECT T1.Street, T1.City, T1.Zip, T1.State FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE (CAST(T2.NumGE1500 AS REAL) / CAST(T2.NumTstTakr AS REAL)) = (SELECT MIN(CAST(NumGE1500 AS REAL) / CAST(NumTstTakr AS REAL)) FROM satscores)\n```"
    ],
    "286": [
        "```\n#reason: The question wants to calculate the percentage of compounds that form a triple bond, so the SQL SELECT will count the number of bonds with bond_type '#' and divide it by the total number of bonds to get the percentage.\n#columns: bond.bond_type\n#values: bond_type = '#' refer to bond.bond_type = '#'\n#SELECT: percent of compounds refer to CAST(COUNT(bond.bond_type) WHERE bond.bond_type = '#') AS REAL * 100 / COUNT(bond.bond_type)\n#SQL-like: Show CAST(COUNT(bond.bond_type) WHERE bond.bond_type = '#') AS REAL * 100 / COUNT(bond.bond_type)\n#SQL: SELECT CAST(COUNT(*) AS REAL) * 100 / (SELECT COUNT(*) FROM bond) FROM bond WHERE bond.bond_type = '#'\n```"
    ],
    "1114": [
        "```\n#reason: The question wants to calculate the average overall rating for Marko Arnautovic over a specified date range, so the SQL SELECT will compute AVG(overall_rating) for the player with the specified name and within the given date range.\n#columns: Player_Attributes.overall_rating, Player.player_name, Player_Attributes.date\n#values: 'Marko Arnautovic' refers to Player.player_name = 'Marko Arnautovic', 'from 2007/2/22 to 2016/4/21' refers to substr(Player_Attributes.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'\n#SELECT: average overall rating refers to avg(overall_rating)\n#SQL-like: Show avg(Player_Attributes.overall_rating), WHERE Player.player_name = 'Marko Arnautovic' AND substr(Player_Attributes.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'\n#SQL: SELECT AVG(CAST(T1.overall_rating AS REAL)) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Marko Arnautovic' AND substr(T1.date, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'\n```"
    ],
    "1121": [
        "```\n#reason: The question wants to calculate the total home team goals scored by players whose age is 30 years old and below, so the SQL SELECT will sum the home team goals where the player's age is calculated based on their birthday.\n#columns: Match.home_team_goal, Player.birthday\n#values: age are 30 years old and below refers to SUBTRACT(strftime('%Y', 'now'), strftime('%Y', Player.birthday)) <= 30\n#SELECT: total home team goal refer to SUM(Match.home_team_goal)\n#SQL-like: Show SUM(Match.home_team_goal), WHERE SUBTRACT(strftime('%Y', 'now'), strftime('%Y', Player.birthday)) <= 30\n#SQL: SELECT SUM(Match.home_team_goal) FROM Match INNER JOIN Player ON Match.home_player_1 = Player.player_api_id OR Match.home_player_2 = Player.player_api_id OR Match.home_player_3 = Player.player_api_id OR Match.home_player_4 = Player.player_api_id OR Match.home_player_5 = Player.player_api_id OR Match.home_player_6 = Player.player_api_id OR Match.home_player_7 = Player.player_api_id OR Match.home_player_8 = Player.player_api_id OR Match.home_player_9 = Player.player_api_id OR Match.home_player_10 = Player.player_api_id OR Match.home_player_11 = Player.player_api_id WHERE (strftime('%Y', 'now') - strftime('%Y', Player.birthday)) <= 30\n```"
    ],
    "791": [
        "```\n#reason: The question wants to calculate the average height for each superhero, so the SQL SELECT needs to calculate that average using SUM(height_cm) divided by the count of all heroes.\n#columns: superhero.height_cm, superhero.id\n#values: None\n#SELECT: average height refer to SUM(height_cm) / COUNT(id)\n#SQL-like: Show SUM(superhero.height_cm) / COUNT(superhero.id)\n#SQL: SELECT CAST(SUM(height_cm) AS REAL) / COUNT(id) FROM superhero\n```"
    ],
    "229": [
        "```\n#reason: The question wants to find the type of bond that molecule TR000 has when involved in any bonds, so the SQL SELECT will retrieve bond_type from the bond table where the molecule_id matches TR000.\n#columns: bond.bond_type, bond.molecule_id\n#values: molecule TR000 refer to bond.molecule_id = 'TR000'\n#SELECT: type of bond refer to bond.bond_type\n#SQL-like: Show bond.bond_type WHERE bond.molecule_id = 'TR000'\n#SQL: SELECT T1.bond_type FROM bond AS T1 WHERE T1.molecule_id = 'TR000'\n```"
    ],
    "471": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the expansion type of the set \"Hauptset Zehnte Edition\", so the SQL SELECT type from sets table where the translation matches the provided value in set_translations.\n#columns: sets.type, set_translations.translation\n#values: 'Hauptset Zehnte Edition' refer to set_translations.translation = 'Hauptset Zehnte Edition'\n#SELECT: SELECT sets.type refer to sets.type\n#SQL-like: Show sets.type, WHERE set_translations.translation = 'Hauptset Zehnte Edition'\n#SQL: SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'\n```"
    ],
    "279": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the label for a specific bond ID, so the SQL SELECT will retrieve the label from the molecule table using a join with the bond table based on the bond_id.\n#columns: molecule.label, bond.bond_id\n#values: 'bond ID TR001_10_11' refer to bond.bond_id = 'TR001_10_11'\n#SELECT: label refer to molecule.label\n#SQL-like: Show molecule.label WHERE bond.bond_id = 'TR001_10_11'\n#SQL: SELECT T1.label FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_id = 'TR001_10_11'\n```"
    ],
    "325": [
        "```\n#reason: The question wants to find the count of carcinogenic molecules consisting of nitrogen, so the SQL SELECT will count the unique molecule IDs where the element is nitrogen and the label indicates carcinogenicity.\n#columns: molecule.molecule_id, atom.element, molecule.label\n#values: nitrogen refers to atom.element = 'n', label = '+' refers to molecule.label = '+'\n#SELECT: SELECT COUNT(DISTINCT molecule.molecule_id) refer to molecule.molecule_id\n#SQL-like: Show COUNT(DISTINCT molecule.molecule_id), WHERE atom.element = 'n' AND molecule.label = '+'\n#SQL: SELECT COUNT(DISTINCT molecule.molecule_id) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.element = 'n' AND molecule.label = '+'\n```"
    ],
    "88": [
        "```\n#reason: The question wants to identify the administrator's email address for the school with the highest number of test takers who received SAT scores of at least 1500, so the SQL SELECT will include the email address and the school name while filtering based on the maximum number of test takers with scores of at least 1500.\n#columns: schools.AdmEmail1, schools.School, satscores.NumTstTakr, satscores.NumGE1500\n#values: highest number of test takers who received SAT scores of at least 1500 refers to satscores.NumTstTakr = (SELECT MAX(satscores.NumTstTakr) FROM satscores WHERE satscores.NumGE1500 > 0)\n#SELECT: administrator's email address refer to schools.AdmEmail1, name of the school refer to schools.School\n#SQL-like: Show schools.AdmEmail1, schools.School WHERE satscores.NumTstTakr = (SELECT MAX(satscores.NumTstTakr) FROM satscores WHERE satscores.NumGE1500 > 0)\n#SQL: SELECT T1.AdmEmail1, T1.School FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.NumTstTakr = (SELECT MAX(T3.NumTstTakr) FROM satscores AS T3 WHERE T3.NumGE1500 > 0)\n```"
    ],
    "1209": [
        "```\n#reason: The question wants to provide the diagnosis of patients with ALT glutamic pyruvic transaminase beyond the normal range, so the SQL SELECT will include the diagnosis and order by date of birth in ascending order.\n#columns: Patient.Diagnosis, Patient.Birthday\n#values: ALT glutamic pyruvic transaminase beyond the normal range refers to Laboratory.GPT > 60\n#SELECT: SELECT Patient.Diagnosis refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis WHERE Laboratory.GPT > 60 ORDER BY Patient.Birthday ASC\n#SQL: SELECT P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GPT > 60 ORDER BY P.Birthday ASC\n```"
    ],
    "1032": [
        "```\n#reason: The question wants to identify the league with the highest number of matches played and the total count of those matches, so the SQL SELECT will group by league_id and count the matches, ordering by the count in descending order to find the maximum.\n#columns: League.name, COUNT(Match.id)\n#values: highest matches of all time refers to MAX(COUNT(Match.league_id))\n#SELECT: SELECT League.name, COUNT(Match.id) refer to League.name and COUNT(Match.id)\n#SQL-like: Show League.name, COUNT(Match.id), GROUP BY League.id, ORDER BY COUNT(Match.id) DESC LIMIT 1\n#SQL: SELECT League.name, COUNT(Match.id) FROM Match INNER JOIN League ON Match.league_id = League.id GROUP BY League.id ORDER BY COUNT(Match.id) DESC LIMIT 1\n```"
    ],
    "1091": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question asks for the count of matches held in April, 2009 in the Belgium Jupiler League, so the SQL SELECT will count matches and apply filters for the league name and date.\n#columns: Match.id, Match.date, League.name\n#values: 'in April, 2009' refers to SUBSTR(Match.date, 1, 7) = '2009-04' and 'Belgium Jupiler League' refers to League.name = 'Belgium Jupiler League'\n#SELECT: SELECT COUNT(Match.id) refer to Match.id\n#SQL-like: Show COUNT(Match.id), WHERE SUBSTR(Match.date, 1, 7) = '2009-04' AND League.name = 'Belgium Jupiler League'\n#SQL: SELECT COUNT(T1.id) FROM Match AS T1 INNER JOIN League AS T2 ON T1.league_id = T2.id WHERE SUBSTR(T1.date, 1, 7) = '2009-04' AND T2.name = 'Belgium Jupiler League';\n```"
    ],
    "81": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to find the city of the school with the lowest latitude in California, so the SQL SELECT will include the city, school name, and lowest grade.)\n#columns: schools.City, schools.School, schools.LowGrade\n#values: 'state of California' refers to schools.State = 'CA', 'lowest latitude coordinates' refers to ORDER BY schools.Latitude ASC LIMIT 1\n#SELECT: SELECT city, school name, lowest grade refer to schools.City, schools.School, schools.LowGrade\n#SQL-like: Show schools.City, schools.School, schools.LowGrade WHERE schools.State = 'CA' ORDER BY schools.Latitude ASC LIMIT 1\n#SQL: SELECT schools.City, schools.School, schools.LowGrade FROM schools WHERE schools.State = 'CA' ORDER BY schools.Latitude ASC LIMIT 1\n```"
    ],
    "87": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve valid e-mail addresses of the administrator of schools located in San Bernardino County, in the City of San Bernardino City Unified, which opened between 1/1/2009 and 12/31/2010, with school types being public Intermediate/Middle Schools and Unified Schools. \"San Bernardino County\" refers to schools.County = 'San Bernardino', \"City of San Bernardino City Unified\" refers to schools.District = 'San Bernardino City Unified', schools opened between \"1/1/2009 to 12/31/2010\" refers to schools.OpenDate BETWEEN '2009-01-01' AND '2010-12-31', \"public Intermediate/Middle Schools\" refers to schools.SOCType = 'Intermediate/Middle Schools (Public)', and \"Unified Schools\" refers to schools.DOCType = 'Unified School District'.\n#columns: schools.AdmEmail1, schools.AdmEmail2, schools.AdmEmail3\n#values: 'San Bernardino County' refers to schools.County = 'San Bernardino', 'City of San Bernardino City Unified' refers to schools.District = 'San Bernardino City Unified', 'between 1/1/2009 to 12/31/2010' refers to schools.OpenDate BETWEEN '2009-01-01' AND '2010-12-31', 'Intermediate/Middle Schools' refers to schools.SOCType = 'Intermediate/Middle Schools (Public)', 'Unified Schools' refers to schools.DOCType = 'Unified School District'\n#SELECT: 'valid e-mail addresses' refers to schools.AdmEmail1, schools.AdmEmail2, schools.AdmEmail3\n#SQL-like: Show schools.AdmEmail1, schools.AdmEmail2, schools.AdmEmail3 WHERE schools.County = 'San Bernardino' AND schools.District = 'San Bernardino City Unified' AND schools.OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND (schools.SOCType = 'Intermediate/Middle Schools (Public)' OR schools.DOCType = 'Unified School District')\n#SQL: SELECT T1.AdmEmail1, T1.AdmEmail2, T1.AdmEmail3 FROM schools AS T1 WHERE T1.County = 'San Bernardino' AND T1.District = 'San Bernardino City Unified' AND T1.OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND (T1.SOCType = 'Intermediate/Middle Schools (Public)' OR T1.DOCType = 'Unified School District')\n```"
    ],
    "617": [
        "```\n#reason: The question wants to retrieve the detailed content of the comment for a specific post created at a given time, so the SQL SELECT will focus on the comment's Text where the CreationDate matches the specified date and time.\n#columns: comments.Text, comments.CreationDate\n#values: created on 7/19/2010 7:37:33 PM refers to comments.CreationDate = '2010-07-19 19:37:33.0'\n#SELECT: detailed content of the comment refers to comments.Text\n#SQL-like: Show comments.Text WHERE comments.CreationDate = '2010-07-19 19:37:33.0'\n#SQL: SELECT T1.Text FROM comments AS T1 WHERE T1.CreationDate = '2010-07-19 19:37:33.0'\n```"
    ],
    "517": [
        "```\n#reason: The question wants to count the number of rare enchantment Abundance cards that have a legal play format status, so the SQL SELECT will count the cards that meet all the specified filtering conditions.\n#columns: cards.rarity, cards.types, cards.name, legalities.status\n#values: rare refers to rarity = 'rare', enchantment card refers to types = 'Enchantment', Abundance cards refers to name = 'Abundance', format status are all legal refers to status = 'Legal'\n#SELECT: COUNT(*) refer to count of cards that meet the criteria\n#SQL-like: Show COUNT(*), WHERE rarity = 'rare' AND types = 'Enchantment' AND name = 'Abundance' AND legalities.status = 'Legal'\n#SQL: SELECT COUNT(*) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.rarity = 'rare' AND cards.types = 'Enchantment' AND cards.name = 'Abundance' AND legalities.status = 'Legal'\n```"
    ],
    "1331": [
        "```\n#reason: The question want to find out the amount of funds received by the Vice President, so the SQL SELECT will sum the funds from the income table where the member's position is 'Vice President'.\n#columns: income.amount, member.position\n#values: 'Vice President' refer to member.position = 'Vice President'\n#SELECT: SELECT SUM(income.amount) refer to income.amount.\n#SQL-like: Show SUM(income.amount) WHERE member.position = 'Vice President'\n#SQL: SELECT SUM(income.amount) FROM income INNER JOIN member ON income.link_to_member = member.member_id WHERE member.position = 'Vice President'\n```"
    ],
    "1326": [
        "```\n#reason: The question wants to find the number of members who have majored in Environmental Engineering, so the SQL SELECT counts the members linked to that major.\n#columns: member.member_id, major.major_name\n#values: 'Environmental Engineering' refers to major.major_name = 'Environmental Engineering'\n#SELECT: SELECT COUNT(member.member_id) refer to COUNT(member.member_id)\n#SQL-like: Show COUNT(member.member_id), WHERE major.major_name = 'Environmental Engineering'\n#SQL: SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Environmental Engineering'\n```"
    ],
    "1151": [
        "```\n#reason: The question wants to calculate the percentage of patients born between 1930 and 1940 who were inpatients, so the SQL SELECT COUNT and CAST will be required to calculate the percentage using the COUNT of inpatients and the total patients in that range.\n#columns: Patient.Birthday, Patient.Admission\n#values: patient born between Year 1930 to 1940 refers to year(Patient.Birthday) BETWEEN '1930-01-01' AND '1940-12-31', inpatient refers to Patient.Admission = '+'\n#SELECT: how many percent refer to CAST(COUNT(CASE WHEN Patient.Admission = '+' THEN 1 END) AS REAL) * 100 / COUNT(Patient.ID)\n#SQL-like: Show CAST(COUNT(CASE WHEN Patient.Admission = '+' THEN 1 END) AS REAL) * 100 / COUNT(Patient.ID), WHERE year(Patient.Birthday) BETWEEN '1930-01-01' AND '1940-12-31'\n#SQL: SELECT CAST(COUNT(CASE WHEN Admission = '+' THEN 1 END) AS REAL) * 100 / COUNT(ID) FROM Patient WHERE Birthday BETWEEN '1930-01-01' AND '1940-12-31'\n```"
    ],
    "1325": [
        "```\n#reason: The question wants to display the \"most expensive item\" that was spent in support of club events, which refers to MAX(cost). \n#columns: expense.expense_description, expense.cost\n#values: the most expensive refers to MAX(cost)\n#SELECT: most expensive item refers to expense.expense_description\n#SQL-like: Show expense.expense_description, ORDER BY expense.cost DESC LIMIT 1\n#SQL: SELECT expense.expense_description FROM expense ORDER BY expense.cost DESC LIMIT 1\n```"
    ],
    "1075": [
        "```\n#reason: The question wants to list all the football players with the highest balance score and a potential score of 61, so the SQL SELECT will filter for potential = 61 and find the maximum balance score.\n#columns: Player.player_name, Player_Attributes.balance, Player_Attributes.potential\n#values: potential score of 61 refers to Player_Attributes.potential = 61\n#SELECT: SELECT all football players with the highest balance score refer to Player.player_name, Player_Attributes.balance\n#SQL-like: Show Player.player_name, Player_Attributes.balance WHERE Player_Attributes.potential = 61 AND Player_Attributes.balance = (SELECT MAX(Player_Attributes.balance) FROM Player_Attributes WHERE Player_Attributes.potential = 61)\n#SQL: SELECT T1.player_name, T2.balance FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.potential = 61 AND T2.balance = (SELECT MAX(balance) FROM Player_Attributes WHERE potential = 61)\n```"
    ],
    "422": [
        "```\n#reason: The question wants to find out the language of the card specified by the multiverse number, so the SQL SELECT will retrieve the language column from the foreign_data table where the multiverseid matches the given value.\n#columns: foreign_data.language\n#values: multiverse number 149934 refers to foreign_data.multiverseid = 149934\n#SELECT: language refers to foreign_data.language\n#SQL-like: Show foreign_data.language WHERE foreign_data.multiverseid = 149934\n#SQL: SELECT language FROM foreign_data WHERE multiverseid = 149934\n```"
    ],
    "360": [
        "```\n#reason: The question wants to display the available languages for the set that contains the card 'Angel of Mercy', so the SQL SELECT will need to join the 'cards', 'sets', and 'set_translations' tables. \n#columns: set_translations.language, cards.name, sets.id\n#values: 'Angel of Mercy' refer to cards.name = 'Angel of Mercy'\n#SELECT: languages refers to set_translations.language\n#SQL-like: Show set_translations.language, WHERE cards.name = 'Angel of Mercy'\n#SQL: SELECT ST.language FROM cards AS C INNER JOIN sets AS S ON C.setCode = S.code INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE C.name = 'Angel of Mercy'\n```"
    ],
    "1316": [
        "```\n#reason: The question wants to list the phone numbers of the students from the Student_Club that have attended the event \"Women's Soccer\". Hence, the SQL SELECT will target the phone numbers of members who attended the specific event.\n#columns: member.phone, attendance.link_to_member, attendance.link_to_event, event.event_name\n#values: 'Women's Soccer' refers to event.event_name = 'Women's Soccer'\n#SELECT: SELECT member.phone refer to member.phone\n#SQL-like: Show member.phone WHERE attendance.link_to_event = event.event_id AND event.event_name = 'Women's Soccer'\n#SQL: SELECT member.phone FROM member INNER JOIN attendance ON member.member_id = attendance.link_to_member INNER JOIN event ON attendance.link_to_event = event.event_id WHERE event.event_name = 'Women's Soccer'\n```"
    ],
    "281": [
        "```\n#reason: The question wants to tally the toxicology element of the 4th atom of each molecule that was carcinogenic, so the SQL SELECT will count the elements of the 4th atom from carcinogenic molecules.\n#columns: atom.element\n#values: label = '+' refer to molecule.label = '+', 4th atom of each molecule refers to substr(atom.atom_id, 7, 1) = '4'\n#SELECT: Tally the toxicology element refer to COUNT(atom.element)\n#SQL-like: Show COUNT(atom.element), WHERE molecule.label = '+' AND substr(atom.atom_id, 7, 1) = '4'\n#SQL: SELECT COUNT(T1.element) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+' AND substr(T1.atom_id, 7, 1) = '4'\n```"
    ],
    "670": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the date when the youngest user made their first post, so the SQL SELECT will retrieve the minimum creation date of posts for the youngest user based on age.\n#columns: users.Age, posts.CreaionDate\n#values: youngest user refers to MIN(users.Age) and first post refers to MIN(posts.CreaionDate)\n#SELECT: SELECT posts.CreaionDate WHERE users.Age = (SELECT MIN(Age) FROM users) ORDER BY posts.CreaionDate LIMIT 1\n#SQL-like: Show posts.CreaionDate WHERE users.Age is the minimum, ORDER BY posts.CreaionDate LIMIT 1\n#SQL: SELECT posts.CreaionDate FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.Age = (SELECT MIN(Age) FROM users) ORDER BY posts.CreaionDate LIMIT 1\n```"
    ],
    "1027": [
        "```\n#reason: The question wants to indicate the full names of the top 10 players with the highest number of penalties, so the SQL SELECT will retrieve player_name and order by penalties in descending order, limiting the results to 10.\n#columns: Player.player_name, Player_Attributes.penalties\n#values: None\n#SELECT: SELECT Player.player_name refer to Player.player_name, ordered by Player_Attributes.penalties\n#SQL-like: Show Player.player_name, ORDER BY Player_Attributes.penalties DESC LIMIT 10\n#SQL: SELECT Player.player_name FROM Player INNER JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id ORDER BY Player_Attributes.penalties DESC LIMIT 10\n```"
    ],
    "83": [
        "```\n#reason: The question wants to find the number of schools offering a magnet program that serve a grade span of Kindergarten to 8th grade and also offers Multiple Provision Types. Additionally, it requires listing the number of cities that offer this grade span and the count of schools in each city. \n#columns: schools.City, schools.School, schools.Magnet, frpm.`NSLP Provision Status`, schools.GSoffered\n#values: 'K-8' refers to schools.GSoffered = 'K-8', 'Offers a magnet program' means schools.Magnet = 1, 'Multiple Provision Types' refers to frpm.`NSLP Provision Status` = 'Multiple Provision Types'\n#SELECT: SELECT COUNT(schools.School) for the total number of schools and COUNT(DISTINCT schools.City) for the number of cities offering the grade span.\n#SQL-like: Show COUNT(schools.School) WHERE schools.GSoffered = 'K-8' AND schools.Magnet = 1 AND frpm.`NSLP Provision Status` = 'Multiple Provision Types'; Show COUNT(DISTINCT schools.City) WHERE schools.GSoffered = 'K-8' AND schools.Magnet = 1\n#SQL: SELECT COUNT(schools.School), COUNT(DISTINCT schools.City) FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.GSoffered = 'K-8' AND schools.Magnet = 1 AND frpm.`NSLP Provision Status` = 'Multiple Provision Types'\n```"
    ],
    "755": [
        "```\n#reason: The question wants to list down at least five full names of Demi-God superheroes, so the SQL SELECT will retrieve the full_name from the superhero table where the race is 'Demi-God'.\n#columns: superhero.full_name\n#values: Demi-God superheroes refer to race = 'Demi-God'\n#SELECT: SELECT full_name refer to superhero.full_name\n#SQL-like: Show superhero.full_name, WHERE race = 'Demi-God'\n#SQL: SELECT full_name FROM superhero WHERE race_id = (SELECT id FROM race WHERE race = 'Demi-God') LIMIT 5\n```"
    ],
    "1269": [
        "```\n#reason: The question wants to list the IDs of the patients who had the examination done after 1997/1/1 and had a normal anti-scl70, so the SQL SELECT will filter based on the examination date and the anti-scl70 result.\n#columns: Patient.ID, Examination.`Examination Date`, Laboratory.SC170\n#values: examination done after 1997/1/1 refer to `Examination Date` > '1997-01-01', normal anti-scl70 refer to Laboratory.SC170 IN ('negative', '0')\n#SELECT: SELECT Patient.ID\n#SQL-like: Show Patient.ID WHERE Examination.`Examination Date` > '1997-01-01' AND Laboratory.SC170 IN ('negative', '0')\n#SQL: SELECT P.ID FROM Patient AS P INNER JOIN Examination AS E ON P.ID = E.ID INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE E.`Examination Date` > '1997-01-01' AND L.SC170 IN ('negative', '0')\n```"
    ],
    "71": [
        "```\n#reason: The question wants to retrieve the district code for schools that do not offer a magnet program in Fresno, so the SQL SELECT will filter for the city of Fresno and where magnet is equal to 0.\n#columns: schools.District Code, schools.City, schools.Magnet\n#values: 'not offer a magnet program' refer to schools.Magnet = 0, 'in the city of Fresno' refer to schools.City = 'Fresno'\n#SELECT: SELECT schools.District Code refer to schools.District Code\n#SQL-like: Show schools.District Code WHERE schools.City = 'Fresno' AND schools.Magnet = 0\n#SQL: SELECT schools.`District Code` FROM schools WHERE schools.City = 'Fresno' AND schools.Magnet = 0\n```"
    ],
    "275": [
        "```\n#reason: The question wants to display the molecule IDs where the bond type is a double bond, so the SQL SELECT will show the bond.molecule_id column for the condition bond.bond_type = '='.\n#columns: bond.molecule_id\n#values: double bond refers to bond_type = '='\n#SELECT: molecule ID refer to bond.molecule_id\n#SQL-like: Show bond.molecule_id, WHERE bond.bond_type = '='\n#SQL: SELECT molecule_id FROM bond WHERE bond_type = '='\n```"
    ],
    "1012": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to find \"the position of the circuits\" during \"Lewis Hamilton's fastest lap\", so the SQL SELECT will retrieve the position and consider the condition for the fastest lap time.)\n#columns: lapTimes.position, circuits.name\n#values: \"Lewis Hamilton\" refers to a specific driver, thus filtering by \"drivers.driverRef = 'hamilton'\". \"fastest lap\" refers to \"lapTimes.time\" which needs to be the minimum (MIN).\n#SELECT: SELECT lapTimes.position, circuits.name\n#SQL-like: Show lapTimes.position and circuits.name WHERE lapTimes.time is minimum for Lewis Hamilton\n#SQL: SELECT T1.position, T2.name FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T3.driverRef = 'hamilton' AND T1.time = (SELECT MIN(time) FROM lapTimes AS T4 WHERE T4.driverId = T3.driverId)\n```"
    ],
    "612": [
        "```\n#reason: The question wants to display the \"name of badge\" that the user whose display name is \"Pierre\" obtained, so the SQL SELECT will fetch the badge name where the user display name matches \"Pierre\".\n#columns: badges.Name, users.DisplayName\n#values: 'Pierre' refer to users.DisplayName = 'Pierre'\n#SELECT: SELECT badges.Name refer to badges.Name\n#SQL-like: Show badges.Name, WHERE users.DisplayName = 'Pierre'\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Pierre'\n```"
    ],
    "941": [
        "```\n#reason: The question wants to find the total points Lewis Hamilton got in all the Formula 1 races he participated, so the SQL SELECT will sum the points from the results table where the driver is Lewis Hamilton.\n#columns: results.points, drivers.driverId\n#values: 'Lewis Hamilton' refer to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SELECT: SELECT SUM(results.points) refer to results.points\n#SQL-like: Show SUM(results.points), WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SQL: SELECT SUM(results.points) FROM results INNER JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n```"
    ],
    "921": [
        "```\n#reason: The question requires displaying \"more information\" about the Formula 1 races that used the Silverstone Circuit, so the SQL SELECT will retrieve the URL of the races associated with the Silverstone Circuit.\n#columns: races.url\n#values: Silverstone Circuit refers to circuits.name = 'Silverstone Circuit'\n#SELECT: more information refers to races.url\n#SQL-like: Show races.url WHERE circuits.name = 'Silverstone Circuit'\n#SQL: SELECT T1.url FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Silverstone Circuit'\n```"
    ],
    "1004": [
        "```\n#reason: The question wants to find out the number of wins achieved by the oldest racer and indicate their full name. The oldest racer is defined as having the minimum date of birth (dob), while their full name is derived from the concatenation of forename and surname.\n#columns: drivers.forename, drivers.surname, driverStandings.wins\n#values: oldest racer refers to MIN(dob) from drivers\n#SELECT: SELECT driverStandings.wins, drivers.forename || ' ' || drivers.surname\n#SQL-like: Show driverStandings.wins, drivers.forename || ' ' || drivers.surname, WHERE drivers.dob = (SELECT MIN(dob) FROM drivers)\n#SQL: SELECT T1.wins, T2.forename || ' ' || T2.surname FROM driverStandings AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.dob = (SELECT MIN(dob) FROM drivers)\n```"
    ],
    "754": [
        "```\n#reason: The question wants to display the \"superpower\" of a specific hero, so the SQL SELECT will retrieve the superpower associated with hero ID 56.\n#columns: superpower.power_name\n#values: hero ID 56 refers to hero_power.hero_id = 56\n#SELECT: superpower refers to superpower.power_name\n#SQL-like: Show superpower.power_name, WHERE hero_power.hero_id = 56\n#SQL: SELECT T2.power_name FROM hero_power AS T1 INNER JOIN superpower AS T2 ON T1.power_id = T2.id WHERE T1.hero_id = 56\n```"
    ],
    "787": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the race and alignment of Cameron Hicks, so the SQL SELECT will target the race and alignment columns while filtering based on the superhero_name being 'Cameron Hicks'.\n#columns: race.race, alignment.alignment\n#values: 'Cameron Hicks' refer to superhero.superhero_name = 'Cameron Hicks'\n#SELECT: SELECT race and alignment refer to race.race, alignment.alignment.\n#SQL-like: Show race.race, alignment.alignment WHERE superhero.superhero_name = 'Cameron Hicks'\n#SQL: SELECT T3.race, T2.alignment FROM superhero AS T1 INNER JOIN race AS T3 ON T1.race_id = T3.id INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id WHERE T1.superhero_name = 'Cameron Hicks'\n```"
    ],
    "1060": [
        "```\n#reason: The question requires displaying \"How many players\". \"born after 1990\" is a filtering condition that translates to extracting the year from birthday and comparing it to 1990.\n#columns: Player.id, Player.birthday\n#values: born after 1990 refers to strftime('%Y', birthday) > '1990'\n#SELECT: How many players refer to COUNT(id)\n#SQL-like: Show COUNT(Player.id), WHERE strftime('%Y', birthday) > '1990'\n#SQL: SELECT COUNT(id) FROM Player WHERE strftime('%Y', birthday) > '1990'\n```"
    ],
    "1240": [
        "```\n#reason: The question wants to find the average hematocrit level lower than the normal range from laboratory examinations in 1991, so the SQL SELECT will compute AVG(HCT) where the conditions about the date and hematocrit level are specified.\n#columns: Laboratory.HCT, Laboratory.Date\n#values: 'laboratory examinations in 1991' refer to Laboratory.Date LIKE '1991%', 'hematocrit level that is lower than the normal range' refer to Laboratory.HCT < 29\n#SELECT: SELECT average hematocrit level refer to AVG(Laboratory.HCT)\n#SQL-like: Show AVG(Laboratory.HCT) WHERE Laboratory.Date LIKE '1991%' AND Laboratory.HCT < 29\n#SQL: SELECT AVG(HCT) FROM Laboratory WHERE Date LIKE '1991%' AND HCT < 29\n```"
    ],
    "929": [
        "```\n#reason: The question wants to list the Formula_1 races that Lewis Hamilton participated, so the SQL SELECT will retrieve the race names filtered by Lewis Hamilton's participation.\n#columns: races.name, results.driverId, drivers.driverId, results.raceId\n#values: 'Lewis Hamilton' refer to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SELECT: SELECT DISTINCT races.name refer to races.name\n#SQL-like: Show DISTINCT races.name, WHERE results.driverId IN (SELECT drivers.driverId FROM drivers WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton')\n#SQL: SELECT DISTINCT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton'\n```"
    ],
    "232": [
        "```\n#reason: The question wants to list the top three molecules that have single bonds between two atoms and are not carcinogenic, so the SQL SELECT will return molecule_id and order by molecule_id.\n#columns: molecule.molecule_id, bond.bond_type, molecule.label\n#values: not carcinogenic refers to molecule.label = '-', single type bond refers to bond.bond_type = '-'\n#SELECT: SELECT molecule_id refer to molecule.molecule_id\n#SQL-like: Show molecule.molecule_id, WHERE bond.bond_type = '-' AND molecule.label = '-' ORDER BY molecule.molecule_id LIMIT 3\n#SQL: SELECT T1.molecule_id FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-' AND T1.label = '-' ORDER BY T1.molecule_id LIMIT 3\n```"
    ],
    "533": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to count the number of users who last accessed the website after a specific date, so the SQL SELECT will count the users based on the LastAccessDate condition)\n#columns: users.LastAccessDate\n#values: last accessed after 2014/9/1 refers to LastAccessDate > '2014-09-01'\n#SELECT: How many users refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE LastAccessDate > '2014-09-01'\n#SQL: SELECT COUNT(*) FROM users WHERE LastAccessDate > '2014-09-01'\n```"
    ],
    "716": [
        "```\n#reason: The question wants to calculate the percentage of users with 0 up votes among comments with scores between 5 to 10, so the SQL SELECT counts the users with 0 up votes and scores in the specified range and divides it by the total count of users in that range.\n#columns: comments.UserId, users.UpVotes, comments.Score\n#values: scores between 5 to 10 refer to comments.Score BETWEEN 5 and 10\n#SELECT: percentage of users with 0 up votes among comments with scores between 5 to 10 refer to DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10), COUNT(UserId where Score BETWEEN 5 and 10)) * 100\n#SQL-like: Show DIVIDE(COUNT(UserId where UpVotes = 0 and Score BETWEEN 5 and 10), COUNT(UserId where Score BETWEEN 5 and 10)) * 100\n#SQL: SELECT CAST(COUNT(CASE WHEN U.UpVotes = 0 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(CASE WHEN C.Score BETWEEN 5 AND 10 THEN 1 ELSE NULL END) FROM comments AS C INNER JOIN users AS U ON C.UserId = U.Id WHERE C.Score BETWEEN 5 AND 10\n```"
    ],
    "292": [
        "```\n#reason: The question wants to identify the atoms that belong to the molecule with ID between TR010 to TR050 that contain the element carbon, so the SQL SELECT will filter for the element 'c' and the molecule_id between 'TR010' and 'TR050'.\n#columns: atom.atom_id, atom.element, atom.molecule_id\n#values: carbon refers to atom.element = 'c', between TR010 to TR050 refers to substr(atom.molecule_id, 3, 3) >= '10' AND substr(atom.molecule_id, 3, 3) <= '50'\n#SELECT: SELECT atom.atom_id, atom.element, atom.molecule_id refer to atom.atom_id, atom.element, atom.molecule_id\n#SQL-like: Show atom.atom_id, atom.element, atom.molecule_id WHERE atom.element = 'c' AND substr(atom.molecule_id, 3, 3) >= '10' AND substr(atom.molecule_id, 3, 3) <= '50'\n#SQL: SELECT atom.atom_id, atom.element, atom.molecule_id FROM atom WHERE atom.element = 'c' AND substr(atom.molecule_id, 3, 3) >= '10' AND substr(atom.molecule_id, 3, 3) <= '50'\n```"
    ],
    "387": [
        "```\n#reason: The question wants to display \"the cards\" and \"the colour\" for the set OGW. \"set OGW\" is a filtering condition.\n#columns: cards.name, cards.colors\n#values: set OGW refers to cards.setCode = 'OGW'\n#SELECT: SELECT cards.name, cards.colors\n#SQL-like: Show cards.name, cards.colors WHERE cards.setCode = 'OGW'\n#SQL: SELECT cards.name, cards.colors FROM cards WHERE cards.setCode = 'OGW'\n```"
    ],
    "880": [
        "```\n#reason: The question wants to calculate the percentage difference in fastest lap speed between the 853rd race and the next race (854th) for driver Paul di Resta. The SQL will select the lap speeds of both races and compute the percentage difference.\n#columns: results.fastestLapSpeed, results.raceId, drivers.forename, drivers.surname \n#values: 'Paul di Resta' refers to drivers.forename = 'Paul' AND drivers.surname = 'di Resta', 'race number 853' refers to results.raceId = 853, 'race number 854' refers to results.raceId = 854\n#SELECT: percent faster refers to DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), fastestLapSpeed(raceId = 854)), fastestLapSpeed(raceId = 853)) * 100\n#SQL-like: Show DIVIDE(SUBTRACT(SELECT fastestLapSpeed WHERE raceId = 853, SELECT fastestLapSpeed WHERE raceId = 854), SELECT fastestLapSpeed WHERE raceId = 853) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN T1.raceId = 853 THEN T1.fastestLapSpeed ELSE 0 END) - SUM(CASE WHEN T1.raceId = 854 THEN T1.fastestLapSpeed ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T1.raceId = 853 THEN T1.fastestLapSpeed ELSE 0 END) FROM results AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T2.forename = 'Paul' AND T2.surname = 'di Resta'\n```"
    ],
    "825": [
        "```\n#reason: The question wants to identify the gender of the superhero who has the ability of Phoenix Force, so the SQL SELECT will retrieve the gender based on the power name.\n#columns: superhero.gender_id, superpower.power_name\n#values: ability of Phoenix Force refers to superpower.power_name = 'Phoenix Force'\n#SELECT: SELECT superhero.gender_id refer to superhero.gender_id\n#SQL-like: Show superhero.gender_id WHERE superpower.power_name = 'Phoenix Force'\n#SQL: SELECT T1.gender_id FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Phoenix Force'\n```"
    ],
    "999": [
        "```\n#reason: The question wants to find the name of the race that recorded the fastest lap speed by a racer, so the SQL SELECT will fetch the race name where the fastest lap time is minimum.\n#columns: races.name, results.fastestLapTime, results.fastestLapSpeed, results.raceId\n#values: fastest lap time refers to MIN(results.fastestLapTime)\n#SELECT: SELECT races.name refer to races.name\n#SQL-like: Show races.name, WHERE results.fastestLapTime is the minimum, ORDER BY results.fastestLapTime ASC LIMIT 1\n#SQL: SELECT T1.name FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId ORDER BY T2.fastestLapTime ASC LIMIT 1\n```"
    ],
    "1411": [
        "```\n#reason: The question wants to identify the types of expenses incurred by Sacha Harrison, so the SQL SELECT will focus on the expense_description and will filter by the individual's full name, derived from their first and last names.\n#columns: expense.expense_description\n#values: Sacha Harrison refers to expense.link_to_member = (SELECT member_id FROM member WHERE first_name = 'Sacha' AND last_name = 'Harrison')\n#SELECT: SELECT expense_description refer to expense.expense_description\n#SQL-like: Show expense.expense_description, WHERE expense.link_to_member = (SELECT member_id FROM member WHERE first_name = 'Sacha' AND last_name = 'Harrison')\n#SQL: SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Sacha' AND T2.last_name = 'Harrison'\n```"
    ],
    "42": [
        "```\n#reason: The question wants to find \"the type of education offered\" in the \"school who scored the highest average in Math,\" so the SQL SELECT will include the type of education and filter to the school with the maximum average math score.\n#columns: schools.EdOpsName, satscores.AvgScrMath\n#values: highest average in Math refers to MAX(satscores.AvgScrMath)\n#SELECT: SELECT schools.EdOpsName refer to schools.EdOpsName\n#SQL-like: Show schools.EdOpsName, WHERE satscores.AvgScrMath = (SELECT MAX(satscores.AvgScrMath) FROM satscores)\n#SQL: SELECT T1.EdOpsName FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T2.AvgScrMath = (SELECT MAX(AvgScrMath) FROM satscores)\n```"
    ],
    "1249": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to list the disease names of the patients that have a proteinuria level higher than normal, so the SQL SELECT will reference the Disease column and the U-PRO column for filtering)\n#columns: Patient.Diagnosis, Laboratory.`U-PRO`\n#values: proteinuria level higher than normal refers to `U-PRO` >= 30\n#SELECT: SELECT disease names refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis, WHERE Laboratory.`U-PRO` >= 30\n#SQL: SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` >= 30\n```"
    ],
    "1177": [
        "```\n#reason: The question want to determine if the total cholesterol status for the patient with id 2927464 on 1995-9-4 was at the normal level, so the SQL SELECT checks the condition for total cholesterol against the provided normal range.\n#columns: Laboratory.`T-CHO`, Laboratory.ID, Laboratory.Date\n#values: patient id 2927464 refers to Laboratory.ID = 2927464, on 1995-9-4 refers to Laboratory.Date = '1995-09-04'\n#SELECT: SELECT content (format: 'total cholesterol' refers to Laboratory.`T-CHO`)\n#SQL-like: Show Laboratory.`T-CHO`, WHERE Laboratory.ID = 2927464 AND Laboratory.Date = '1995-09-04'\n#SQL: SELECT T1.`T-CHO` FROM Laboratory AS T1 WHERE T1.ID = 2927464 AND T1.Date = '1995-09-04'\n```"
    ],
    "1352": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count all club members from the \"Business\" major who wear a medium size t-shirt, so the SQL SELECT COUNT(member.member_id) and WHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium'.\n#columns: member.member_id, major.major_name, member.t_shirt_size\n#values: 'Business' refers to major.major_name = 'Business', 'wear medium size t-shirt' refers to member.t_shirt_size = 'Medium'\n#SELECT: SELECT COUNT(member.member_id) refer to COUNT(member.member_id)\n#SQL-like: Show COUNT(member.member_id), WHERE major.major_name = 'Business' AND member.t_shirt_size = 'Medium'\n#SQL: SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business' AND T1.t_shirt_size = 'Medium'\n```"
    ],
    "1210": [
        "```\n#reason: The question wants to calculate the average index of the lactate dehydrogenase (LDH) for all patients with LDH within the normal range, so the SQL SELECT will compute AVG(LDH) where LDH < 500.\n#columns: Laboratory.LDH\n#values: LDH within the normal range refers to Laboratory.LDH < 500\n#SELECT: average index refers to AVG(Laboratory.LDH)\n#SQL-like: Show AVG(Laboratory.LDH) WHERE Laboratory.LDH < 500\n#SQL: SELECT AVG(LDH) FROM Laboratory WHERE LDH < 500\n```"
    ],
    "1388": [
        "```\n#reason: The question wants to identify the student with the highest income, so the SQL SELECT should return the full name of the student (first_name and last_name) and the source of the income while applying the MAX function to the income amount.\n#columns: member.first_name, member.last_name, income.source\n#values: 'highest income' refers to income.amount = (SELECT MAX(income.amount) FROM income)\n#SELECT: SELECT full name and income source refer to member.first_name, member.last_name, income.source\n#SQL-like: Show member.first_name, member.last_name, income.source WHERE income.amount = (SELECT MAX(income.amount) FROM income)\n#SQL: SELECT T1.first_name, T1.last_name, T2.source FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount = (SELECT MAX(amount) FROM income)\n```"
    ],
    "775": [
        "```\n#reason: The question wants to calculate the percentage of blue female superheroes among all female superheroes, so the SQL SELECT will count the number of blue female superheroes and divide it by the total number of female superheroes then multiply by 100.\n#columns: colour.colour, gender.gender, superhero.gender_id, superhero.skin_colour_id\n#values: 'blue' refers to colour.colour = 'Blue', 'female' refers to gender.gender = 'Female'\n#SELECT: percentage of blue female superheroes among all female superheroes refer to (CAST(SUM(T1.skin_colour_id = T2.id AND T3.gender = 'Female') AS REAL) * 100 / COUNT(T3.gender)) \n#SQL-like: Show (CAST(SUM(T1.skin_colour_id = T2.id AND T3.gender = 'Female') AS REAL) * 100 / COUNT(T3.gender)), WHERE T2.colour = 'Blue' AND T3.gender = 'Female'\n#SQL: SELECT CAST(SUM(T1.skin_colour_id = T2.id AND T3.gender = 'Female') AS REAL) * 100 / COUNT(T3.gender) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.colour = 'Blue' AND T3.gender = 'Female'\n```"
    ],
    "181": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to provide the IDs of the 3 female clients with the largest loans, so the SQL SELECT will involve filtering by gender and ordering by loan amount.\n#columns: client.client_id, loan.amount\n#values: female refers to client.gender = 'F'\n#SELECT: SELECT IDs of the 3 female clients with the largest loans refer to client.client_id\n#SQL-like: Show client.client_id, WHERE client.gender = 'F' ORDER BY loan.amount DESC LIMIT 3\n#SQL: SELECT T1.client_id FROM client AS T1 INNER JOIN loan AS T2 ON T1.client_id = T2.account_id WHERE T1.gender = 'F' ORDER BY T2.amount DESC LIMIT 3\n```"
    ],
    "270": [
        "```\n#reason: The question wants to determine whether the molecules with element Calcium are mostly carcinogenic or non-carcinogenic, so the SQL SELECT will count the occurrences of each label and compare them.\n#columns: molecule.label\n#values: calcium refers to atom.element = 'ca'\n#SELECT: SELECT molecule.label refer to molecule.label\n#SQL-like: Show COUNT(molecule.label), WHERE atom.element = 'ca' GROUP BY molecule.label\n#SQL: SELECT molecule.label, COUNT(molecule.label) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.element = 'ca' GROUP BY molecule.label\n```"
    ],
    "996": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to know the annual average number of races, so the SQL SELECT will count the races in the specified date range and divide by the number of years.\n#columns: races.raceId\n#values: 'races held during the first 10 years of the 21st century' refer to 'races.date BETWEEN \"2000-01-01\" AND \"2010-12-31\"'\n#SELECT: SELECT CAST(COUNT(races.raceId) AS REAL) / 10 refer to the annual average number of races\n#SQL-like: Show CAST(COUNT(races.raceId) AS REAL) / 10, WHERE races.date BETWEEN '2000-01-01' AND '2010-12-31'\n#SQL: SELECT CAST(COUNT(raceId) AS REAL) / 10 FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31'\n```"
    ],
    "1466": [
        "```\n#reason: The question wants to display the full name of the club member with the position of 'Secretary' and the college they belong to, so the SQL SELECT combines member.first_name and member.last_name for the full name and uses major.college for the college details filtering by member.position = 'Secretary'.\n#columns: member.first_name, member.last_name, major.college\n#values: 'Secretary' refer to member.position = 'Secretary'\n#SELECT: SELECT member.first_name || ' ' || member.last_name AS full_name, major.college\n#SQL-like: Show member.first_name || ' ' || member.last_name, major.college, WHERE member.position = 'Secretary'\n#SQL: SELECT member.first_name || ' ' || member.last_name AS full_name, major.college FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE member.position = 'Secretary'\n```"
    ],
    "813": [
        "```\n#reason: The question wants to calculate the average attribute value of all neutral superheroes, so the SQL SELECT will compute AVG(attribute_value) from hero_attribute where alignment_id = 3.\n#columns: hero_attribute.attribute_value, superhero.alignment_id\n#values: neutral superheroes refers to alignment_id = 3\n#SELECT: average attribute value refers to AVG(hero_attribute.attribute_value)\n#SQL-like: Show AVG(hero_attribute.attribute_value), WHERE superhero.alignment_id = 3\n#SQL: SELECT AVG(T1.attribute_value) FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.alignment_id = 3\n```"
    ],
    "168": [
        "```\n#reason: The question wants to find the percentage of clients who opened their accounts in districts with an average salary over 10000 that are women, so the SQL SELECT will count the number of female clients and divide it by the total number of clients in those districts, then multiply by 100 for the percentage.\n#columns: client.gender, district.A11\n#values: average salary over 10000 refers to district.A11 > 10000\n#SELECT: percentage of female clients refer to (CAST(SUM(CASE WHEN client.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*))\n#SQL-like: Show (CAST(SUM(CASE WHEN client.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)), WHERE client.district_id IN (SELECT district_id FROM district WHERE A11 > 10000)\n#SQL: SELECT (CAST(SUM(CASE WHEN client.gender = 'F' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*)) FROM client WHERE district_id IN (SELECT district_id FROM district WHERE A11 > 10000)\n```"
    ],
    "526": [
        "```\n#reason: The question wants to find out how many cards are designed by a specific artist and are available only in a specific format, so the SQL SELECT query will count the unique cards filtered by artist and availability.\n#columns: cards.artist, cards.availability, cards.id\n#values: 'card designed by Matthew D. Wilson' refer to cards.artist = 'Matthew D. Wilson', 'available only in the paper' refer to cards.availability = 'paper'\n#SELECT: SELECT COUNT(cards.id) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id) WHERE cards.artist = 'Matthew D. Wilson' AND cards.availability = 'paper'\n#SQL: SELECT COUNT(T1.id) FROM cards AS T1 WHERE T1.artist = 'Matthew D. Wilson' AND T1.availability = 'paper'\n```"
    ],
    "1014": [
        "```\n#reason: The question wants to display the lap records for circuits in Italy. \"lap record\" means the fastest time recorded, and \"circuits in Italy\" refers to filtering by country = 'Italy'.\n#columns: lapTimes.time, circuits.name\n#values: 'circuits in Italy' refer to 'circuits.country = 'Italy''\n#SELECT: SELECT lapTimes.time, circuits.name refer to lapTimes.time, circuits.name.\n#SQL-like: Show lapTimes.time, circuits.name WHERE circuits.country = 'Italy'\n#SQL: SELECT T1.time, T2.name FROM lapTimes AS T1 INNER JOIN circuits AS T2 ON T1.raceId = T2.circuitId WHERE T2.country = 'Italy'\n```"
    ],
    "423": [
        "```\n#reason: The question wants to provide the ids of the top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order, so the SQL SELECT will filter for non-null values in both cardKingdomFoilId and cardKingdomId, and then order by cardKingdomFoilId.\n#columns: cards.cardKingdomFoilId, cards.cardKingdomId\n#values: powerful refers to cardKingdomFoilId is not null AND cardKingdomId is not null\n#SELECT: SELECT cards.cardKingdomFoilId, cards.cardKingdomId\n#SQL-like: Show cards.cardKingdomFoilId, cards.cardKingdomId WHERE cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL ORDER BY cards.cardKingdomFoilId LIMIT 3\n#SQL: SELECT cards.cardKingdomFoilId, cards.cardKingdomId FROM cards WHERE cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL ORDER BY cards.cardKingdomFoilId LIMIT 3\n```"
    ],
    "297": [
        "```\n#reason: The question wants to identify atoms that contain the element carbon and are part of non-carcinogenic compounds, so the SQL SELECT will filter atoms based on the element and the label of the molecule.\n#columns: atom.atom_id, molecule.label\n#values: carbon refers to element = 'c', non-carcinogenic refers to label = '-'\n#SELECT: SELECT atom.atom_id, molecule.label refer to atom.atom_id, molecule.label\n#SQL-like: Show atom.atom_id, molecule.label, WHERE atom.element = 'c' AND molecule.label = '-'\n#SQL: SELECT T1.atom_id, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'c' AND T2.label = '-'\n```"
    ],
    "504": [
        "```\n#reason: The question wants to count the number of cards in the set 'World Championship Decks 2004' with a converted mana cost of '3', so the SQL SELECT will count the cards and filter by the set name and converted mana cost.\n#columns: cards.id, sets.name, cards.convertedManaCost\n#values: 'World Championship Decks 2004' refer to sets.name = 'World Championship Decks 2004', '3' refer to cards.convertedManaCost = 3\n#SELECT: SELECT COUNT(cards.id) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id), WHERE sets.name = 'World Championship Decks 2004' AND cards.convertedManaCost = 3\n#SQL: SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'World Championship Decks 2004' AND T1.convertedManaCost = 3\n```"
    ],
    "92": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the number of districts with an average female salary between 6000 and 10000, so the SQL SELECT COUNT(district.district_id) and applies filtering conditions for average salary.\n#columns: district.A11, client.gender, client.district_id\n#values: female average salary is more than 6000 but less than 10000 refer to client.gender = 'F' AND district.A11 > 6000 AND district.A11 < 10000\n#SELECT: the no. of districts refer to COUNT(district.district_id)\n#SQL-like: Show COUNT(district.district_id), WHERE client.gender = 'F' AND district.A11 > 6000 AND district.A11 < 10000\n#SQL: SELECT COUNT(DISTINCT district.district_id) FROM district INNER JOIN client ON district.district_id = client.district_id WHERE client.gender = 'F' AND district.A11 > 6000 AND district.A11 < 10000\n```"
    ],
    "608": [
        "```\n#reason: The question wants to display the \"detailed content of the comment\" based on the condition \"created on 7/19/2010 7:16:14 PM\".\n#columns: comments.Text\n#values: created on 7/19/2010 7:16:14 PM refers to comments.CreationDate = '2010-07-19 19:16:14.0'\n#SELECT: SELECT detailed content of the comment refers to comments.Text\n#SQL-like: Show comments.Text WHERE comments.CreationDate = '2010-07-19 19:16:14.0'\n#SQL: SELECT T1.Text FROM comments AS T1 WHERE T1.CreationDate = '2010-07-19 19:16:14.0'\n```"
    ],
    "1241": [
        "```\n#reason: The question wants to compare the count of patients with abnormal platelet levels who have a lower than normal range against those with a higher than normal range. Thus, the SQL SELECT should calculate the number of patients with PLT < 100 and subtract the number of patients with PLT > 400.\n#columns: COUNT(Laboratory.PLT), COUNT(Laboratory.PLT)\n#values: abnormal platelet level refers to Laboratory.PLT <= 100 OR Laboratory.PLT >= 400; platelet level lower than normal range refers to Laboratory.PLT < 100; platelet level higher than normal range refers to Laboratory.PLT > 400.\n#SELECT: number of patients with lower than normal range refers to COUNT(Laboratory.PLT < 100), number of patients with higher than normal range refers to COUNT(Laboratory.PLT > 400)\n#SQL-like: Show COUNT(Laboratory.PLT < 100), COUNT(Laboratory.PLT > 400)\n#SQL: SELECT (SELECT COUNT(*) FROM Laboratory WHERE PLT < 100) - (SELECT COUNT(*) FROM Laboratory WHERE PLT > 400)\n```"
    ],
    "112": [
        "```\n#reason: The question wants to identify the district where a specific female client opened her account, so the SQL SELECT will retrieve the district name based on the client's gender and birth date.\n#columns: district.A2, client.gender, account.district_id\n#values: 'female client' refers to client.gender = 'F', 'born in 1976/1/29' refers to client.birth_date = '1976-01-29'\n#SELECT: SELECT district.A2 refer to district name\n#SQL-like: Show district.A2 WHERE client.gender = 'F' AND client.birth_date = '1976-01-29'\n#SQL: SELECT T2.A2 FROM client AS T1 INNER JOIN account AS T2 ON T1.client_id = T2.client_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.gender = 'F' AND T1.birth_date = '1976-01-29'\n```"
    ],
    "95": [
        "```\n#reason: The question wants to list out the account numbers of clients who are the youngest and have the highest average salary, so the SQL SELECT will filter clients based on their birth dates and average salary.\n#columns: account.account_id, client.client_id, district.A11\n#values: 'youngest clients' refer to 'client.birth_date = (SELECT MIN(birth_date) FROM client)', 'highest average salary' refer to 'district.A11 = (SELECT MAX(A11) FROM district)'\n#SELECT: SELECT account.account_id, client.client_id refer to account.account_id, client.client_id\n#SQL-like: Show account.account_id, client.client_id WHERE client.birth_date = (SELECT MIN(birth_date) FROM client) AND district.A11 = (SELECT MAX(A11) FROM district)\n#SQL: SELECT account.account_id, client.client_id FROM account INNER JOIN disp ON account.account_id = disp.account_id INNER JOIN client ON disp.client_id = client.client_id INNER JOIN district ON client.district_id = district.district_id WHERE client.birth_date = (SELECT MIN(birth_date) FROM client) AND district.A11 = (SELECT MAX(A11) FROM district)\n```"
    ],
    "376": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the card layout of cards that have the keyword \"Flying\", so the SQL SELECT will retrieve the card layout from the cards table where the keywords include \"Flying\".\n#columns: cards.layout\n#values: 'keyword is Flying' refer to cards.keywords LIKE '%Flying%'\n#SELECT: SELECT cards.layout refer to cards.layout\n#SQL-like: Show cards.layout, WHERE cards.keywords LIKE '%Flying%'\n#SQL: SELECT cards.layout FROM cards WHERE cards.keywords LIKE '%Flying%'\n```"
    ],
    "452": [
        "```\n#reason: The question wants to list the names of the cards that have a text box, so the SQL SELECT will retrieve the card names where isTextless is 0.\n#columns: cards.name\n#values: have a text box refers to cards.isTextless = 0\n#SELECT: SELECT content refers to cards.name\n#SQL-like: Show cards.name WHERE cards.isTextless = 0\n#SQL: SELECT name FROM cards WHERE isTextless = 0\n```"
    ],
    "1024": [
        "```\n#reason: The question wants to display the \"top 5 players who perform better in crossing actions\", so the SQL SELECT will retrieve the player IDs ordered by their crossing score in descending order and limited to the top 5.\n#columns: Player.id, Player_Attributes.crossing\n#values: None\n#SELECT: player id refer to Player.id\n#SQL-like: Show Player.id, ORDER BY Player_Attributes.crossing DESC LIMIT 5\n#SQL: SELECT Player.id FROM Player INNER JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id ORDER BY Player_Attributes.crossing DESC LIMIT 5\n```"
    ],
    "1369": [
        "```\n#reason: The question wants to find \"which event has the highest budget amount\", so the SQL SELECT will fetch the event_name and filter by the maximum budget amount.\n#columns: event.event_name, budget.amount\n#values: highest budget amount refers to MAX(budget.amount)\n#SELECT: SELECT event_name refer to event.event_name\n#SQL-like: Show event.event_name, ORDER BY budget.amount DESC LIMIT 1\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event ORDER BY T2.amount DESC LIMIT 1\n```"
    ],
    "141": [
        "```\n#reason: The question wants to find the districts that have transactions greater than US$10,000 in the year 1997. This involves filtering transactions by amount and year while aggregating them by district. \n#columns: district.A2, trans.amount, trans.date, trans.account_id\n#values: transactions greater than US$10,000 refer to trans.amount > 10000, in 1997 refers to \"strftime('%Y', trans.date) = '1997'\"\n#SELECT: SELECT districts refer to district.A2. \n#SQL-like: Show district.A2 WHERE trans.amount > 10000 AND strftime('%Y', trans.date) = '1997'\n#SQL: SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN trans AS T2 ON T1.district_id = T2.account_id WHERE T2.amount > 10000 AND strftime('%Y', T2.date) = '1997'\n```"
    ],
    "396": [
        "```\n#reason: The question wants to determine the count of cards with specific criteria: \"1993 frame version\", \"available on paper\", and \"sensitive content warning\". So the SQL SELECT will count the cards that match these conditions.\n#columns: cards.id, cards.frameVersion, cards.availability, cards.hasContentWarning\n#values: '1993' refers to cards.frameVersion = '1993', 'paper' refers to cards.availability = 'paper', 'sensitive content warning' refers to cards.hasContentWarning = 1\n#SELECT: SELECT COUNT(cards.id) refer to cards.id\n#SQL-like: Show COUNT(cards.id), WHERE cards.frameVersion = '1993' AND cards.availability = 'paper' AND cards.hasContentWarning = 1\n#SQL: SELECT COUNT(cards.id) FROM cards WHERE cards.frameVersion = '1993' AND cards.availability = 'paper' AND cards.hasContentWarning = 1\n```"
    ],
    "843": [
        "```\n#reason: The question wants to list the hero ID of superheroes who have intelligence as their power, so the SQL SELECT will focus on the superhero.id column, filtered by the condition that the power_name is 'Intelligence'.\n#columns: superhero.id\n#values: power_name = 'Intelligence' refers to superpower.power_name = 'Intelligence'\n#SELECT: SELECT hero ID refers to superhero.id\n#SQL-like: Show superhero.id WHERE superpower.power_name = 'Intelligence'\n#SQL: SELECT DISTINCT T1.id FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Intelligence'\n```"
    ],
    "1238": [
        "```\n#reason: The question requires finding the oldest patient diagnosed with SLE who has a normal hemoglobin level, so the SQL SELECT will display ID and sex of that patient.\n#columns: Patient.ID, Patient.SEX, Laboratory.HGB, Patient.Birthday\n#values: diagnosed with SLE refers to Patient.Diagnosis = 'SLE', normal hemoglobin level refers to Laboratory.HGB > 10 AND Laboratory.HGB < 17\n#SELECT: ID and sex refer to Patient.ID, Patient.SEX\n#SQL-like: Show Patient.ID, Patient.SEX WHERE Patient.Diagnosis = 'SLE' AND Laboratory.HGB > 10 AND Laboratory.HGB < 17 ORDER BY Patient.Birthday LIMIT 1\n#SQL: SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.HGB > 10 AND T2.HGB < 17 ORDER BY T1.Birthday ASC LIMIT 1\n```"
    ],
    "163": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the district with the most accounts that have loan contracts finished with no problems, so the SQL SELECT will count the accounts grouped by district.\n#columns: district.district_id, district.A2, account.account_id\n#values: status = 'A' refers to loan.status = 'A'\n#SELECT: SELECT district.district_id, district.A2, COUNT(account.account_id) refer to district.district_id, district.A2, COUNT(account.account_id)\n#SQL-like: Show district.district_id, district.A2, COUNT(account.account_id), WHERE loan.status = 'A', GROUP BY district.district_id, district.A2, ORDER BY COUNT(account.account_id) DESC LIMIT 1\n#SQL: SELECT T.district_id, T.A2, COUNT(T.account_id) FROM (SELECT account.account_id, district.district_id, district.A2 FROM account INNER JOIN loan ON account.account_id = loan.account_id INNER JOIN district ON account.district_id = district.district_id WHERE loan.status = 'A') T GROUP BY T.district_id, T.A2 ORDER BY COUNT(T.account_id) DESC LIMIT 1\n```"
    ],
    "1514": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to know the currency that the customer paid, so the SQL SELECT statement will retrieve the currency based on the time and date of the transaction.\n#columns: customers.Currency, transactions_1k.Time, transactions_1k.Date\n#values: '16:25:00' refers to transactions_1k.Time = '16:25:00', '2012/8/24' refers to transactions_1k.Date = '2012-08-24'\n#SELECT: currency refer to customers.Currency\n#SQL-like: Show customers.Currency WHERE transactions_1k.Time = '16:25:00' AND transactions_1k.Date = '2012-08-24'\n#SQL: SELECT T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Time = '16:25:00' AND T2.Date = '2012-08-24'\n```"
    ],
    "1419": [
        "```\n#reason: The question wants to find the category of the event that took place on a specific date, so the SQL SELECT will retrieve the event category based on the event date.\n#columns: event.type\n#values: 'taken place in 2020-03-24T12:00:00' refer to event.event_date = '2020-03-24T12:00:00'\n#SELECT: SELECT type refer to event.type\n#SQL-like: Show event.type, WHERE event.event_date = '2020-03-24T12:00:00'\n#SQL: SELECT type FROM event WHERE event_date = '2020-03-24T12:00:00'\n```"
    ],
    "1199": [
        "```\n#reason: The question want to determine the number of patients who underwent testing in 1997 and had protein levels outside the normal range, so the SQL SELECT will count the distinct patient IDs with conditions on the examination date and total protein levels.\n#columns: Laboratory.ID, Laboratory.TP, Laboratory.Date\n#values: 'underwent testing in 1997' refer to strftime('%Y', Laboratory.Date) = '1997', 'protein levels outside the normal range' refer to Laboratory.TP <= 6 OR Laboratory.TP >= 8.5\n#SELECT: SELECT COUNT(DISTINCT Laboratory.ID) refer to counting distinct patients who have laboratory tests with abnormal protein levels\n#SQL-like: Show COUNT(DISTINCT Laboratory.ID), WHERE strftime('%Y', Laboratory.Date) = '1997' AND (Laboratory.TP <= 6 OR Laboratory.TP >= 8.5)\n#SQL: SELECT COUNT(DISTINCT Laboratory.ID) FROM Laboratory WHERE strftime('%Y', Laboratory.Date) = '1997' AND (Laboratory.TP <= 6 OR Laboratory.TP >= 8.5)\n```"
    ],
    "1045": [
        "```\n#reason: The question wants to find out the \"attacking work rate\" of the football player Franco Zennaro, so the SQL SELECT will retrieve the attacking work rate from the Player_Attributes table where the player's name matches Franco Zennaro.\n#columns: Player_Attributes.attacking_work_rate, Player.player_name\n#values: 'Franco Zennaro' refer to Player.player_name = 'Franco Zennaro'\n#SELECT: SELECT Player_Attributes.attacking_work_rate refer to Player_Attributes.attacking_work_rate\n#SQL-like: Show Player_Attributes.attacking_work_rate, WHERE Player.player_name = 'Franco Zennaro'\n#SQL: SELECT T1.attacking_work_rate FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Franco Zennaro'\n```"
    ],
    "263": [
        "```\n#reason: The question wants to calculate the percentage of the element chlorine among the atoms in single bond molecules, so the SQL SELECT will count the chlorine atoms and divide by the total number of atoms in single bond molecules.\n#columns: atom.element, bond.bond_type, atom.atom_id\n#values: 'element chlorine' refers to atom.element = 'cl', 'single bond' refers to bond.bond_type = '-'\n#SELECT: SELECT DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent refer to atom.element.\n#SQL-like: Show DIVIDE(SUM(CASE WHEN atom.element = 'cl' THEN 1 ELSE 0 END), COUNT(atom.atom_id)) as percent WHERE bond.bond_type = '-'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.element = 'cl' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.atom_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-'\n```"
    ],
    "475": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the cards in the set Coldsnap with a black border color, so the SQL SELECT will count cards based on set name and border color.\n#columns: cards.borderColor, sets.name\n#values: 'set Coldsnap' refer to sets.name = 'Coldsnap', 'black border color' refer to cards.borderColor = 'black'\n#SELECT: SELECT COUNT(cards.borderColor) refer to COUNT(cards.borderColor)\n#SQL-like: Show COUNT(cards.borderColor), WHERE sets.name = 'Coldsnap' AND cards.borderColor = 'black'\n#SQL: SELECT COUNT(cards.borderColor) FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.borderColor = 'black'\n```"
    ],
    "21": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to count the number of schools in Los Angeles with specific meal counts, so the SQL SELECT will count the schools based on the given conditions)\n#columns: frpm.`County Name`, frpm.`Free Meal Count (K-12)`, frpm.`FRPM Count (K-12)`\n#values: 'Los Angeles' refer to frpm.`County Name` = 'Los Angeles', 'more than 500 free meals' refer to frpm.`Free Meal Count (K-12)` > 500, 'less than 700 free or reduced price meals for K-12' refer to frpm.`FRPM Count (K-12)` < 700\n#SELECT: SELECT COUNT(frpm.`County Name`) refer to frpm.`County Name`\n#SQL-like: Show COUNT(frpm.`County Name`), WHERE frpm.`County Name` = 'Los Angeles' AND frpm.`Free Meal Count (K-12)` > 500 AND frpm.`FRPM Count (K-12)` < 700\n#SQL: SELECT COUNT(frpm.`County Name`) FROM frpm WHERE frpm.`County Name` = 'Los Angeles' AND frpm.`Free Meal Count (K-12)` > 500 AND frpm.`FRPM Count (K-12)` < 700\n```"
    ],
    "1029": [
        "```\n#reason: The question wants to find the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed, so the SQL SELECT will filter teams based on buildUpPlaySpeed and order by it to get the top 4.\n#columns: Team_Attributes.buildUpPlaySpeed\n#values: None\n#SELECT: speed in which attacks are put together refers to Team_Attributes.buildUpPlaySpeed\n#SQL-like: Show Team_Attributes.buildUpPlaySpeed ORDER BY Team_Attributes.buildUpPlaySpeed DESC LIMIT 4\n#SQL: SELECT Team_Attributes.buildUpPlaySpeed FROM Team_Attributes ORDER BY Team_Attributes.buildUpPlaySpeed DESC LIMIT 4\n```"
    ],
    "150": [
        "```\n#reason: The question wants to count the number of accounts in North Bohemia that have made transactions with the partner's bank being AB, so the SQL SELECT will count the distinct accounts from the account and transaction tables where the region is North Bohemia and the bank is AB.\n#columns: DISTINCT account.account_id\n#values: North Bohemia refers to district.A3 = 'north Bohemia', bank being AB refers to trans.bank = 'AB'\n#SELECT: SELECT COUNT(DISTINCT account.account_id) \n#SQL-like: Show COUNT(DISTINCT account.account_id), WHERE district.A3 = 'north Bohemia' AND trans.bank = 'AB'\n#SQL: SELECT COUNT(DISTINCT account.account_id) FROM account INNER JOIN district ON account.district_id = district.district_id INNER JOIN trans ON account.account_id = trans.account_id WHERE district.A3 = 'north Bohemia' AND trans.bank = 'AB'\n```"
    ],
    "1457": [
        "```\n#reason: The question wants to display the full name and contact number of members who had to spend more than average on each expense. The average spending is defined as cost > AVG(cost). Full name refers to first_name and last_name, while contact number refers to phone.\n#columns: member.first_name, member.last_name, member.phone, expense.cost\n#values: 'had spent more than average on each expense' refers to expense.cost > (SELECT AVG(cost) FROM expense)\n#SELECT: SELECT full name refer to member.first_name, member.last_name, contact number refer to member.phone\n#SQL-like: Show member.first_name, member.last_name, member.phone WHERE expense.cost > (SELECT AVG(cost) FROM expense)\n#SQL: SELECT T1.first_name, T1.last_name, T1.phone FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.cost > (SELECT AVG(cost) FROM expense)\n```"
    ],
    "513": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the set with the highest total number of cards among those whose expansion type is Commander, so the SQL SELECT will focus on the set id where the type is 'commander' and the totalSetSize is the maximum.\n#columns: sets.id, sets.totalSetSize\n#values: expansion type is Commander refers to sets.type = 'commander'; highest total number of cards refers to totalSetSize = (SELECT MAX(totalSetSize) FROM sets WHERE type = 'commander')\n#SELECT: SELECT id refer to sets.id\n#SQL-like: Show sets.id, where sets.type = 'commander' AND sets.totalSetSize = (SELECT MAX(totalSetSize) FROM sets WHERE type = 'commander')\n#SQL: SELECT id FROM sets WHERE type = 'commander' AND totalSetSize = (SELECT MAX(totalSetSize) FROM sets WHERE type = 'commander')\n```"
    ],
    "532": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"display names of all the users\" whose \"accounts were created in the year 2011\". The filtering condition is \"year(CreationDate) = 2011\".\n#columns: users.DisplayName, users.CreationDate\n#values: 'account created in the year 2011' refer to year(users.CreationDate) = 2011\n#SELECT: SELECT display names refer to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE year(users.CreationDate) = 2011\n#SQL: SELECT DisplayName FROM users WHERE strftime('%Y', CreationDate) = '2011'\n```"
    ],
    "955": [
        "```\n#reason: The question wants to calculate the average time in seconds of champions for each year before 1975, so the SQL SELECT will compute the average of the finishing times where the year is less than 1975 and the time is not null.\n#columns: results.time, races.year\n#values: before year 1975 refers to races.year < 1975, finished the game refers to results.time IS NOT NULL\n#SELECT: SELECT AVG(CAST(SUBSTR(results.time, INSTR(results.time, ':') - 2, 2) AS REAL) * 3600 + CAST(SUBSTR(results.time, INSTR(results.time, ':') + 1, 2) AS REAL) * 60 + CAST(SUBSTR(results.time, INSTR(results.time, ':', INSTR(results.time, ':') + 1) + 1) AS REAL)) ) refer to results.time\n#SQL-like: Show AVG(CAST(SUBSTR(results.time, INSTR(results.time, ':') - 2, 2) AS REAL) * 3600 + CAST(SUBSTR(results.time, INSTR(results.time, ':') + 1, 2) AS REAL) * 60 + CAST(SUBSTR(results.time, INSTR(results.time, ':', INSTR(results.time, ':') + 1) + 1) AS REAL)), WHERE races.year < 1975 AND results.time IS NOT NULL\n#SQL: SELECT AVG(CAST(SUBSTR(results.time, INSTR(results.time, ':') - 2, 2) AS REAL) * 3600 + CAST(SUBSTR(results.time, INSTR(results.time, ':') + 1, 2) AS REAL) * 60 + CAST(SUBSTR(results.time, INSTR(results.time, ':', INSTR(results.time, ':') + 1) + 1) AS REAL)) ) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.year < 1975 AND results.time IS NOT NULL\n```"
    ],
    "392": [
        "```\n#reason: The question wants to pick 3 cards with rarity of uncommon and list their names according to ascending order of their ruling date, so the SQL SELECT will filter cards by rarity and join to get ruling dates, ordering the results accordingly.\n#columns: cards.name, rulings.date\n#values: rarity is uncommon refer to rarity = 'uncommon'\n#SELECT: SELECT cards.name refer to cards.name\n#SQL-like: Show cards.name, WHERE rarity = 'uncommon', ORDER BY rulings.date ASC LIMIT 3\n#SQL: SELECT cards.name FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.rarity = 'uncommon' ORDER BY rulings.date ASC LIMIT 3\n```"
    ],
    "575": [
        "```\n#reason: The question wants to display the \"badge name\" that a specific user obtained, so the SQL SELECT will extract the badge name associated with the user identified by their DisplayName.\n#columns: badges.Name, users.DisplayName\n#values: 'SilentGhost' refers to users.DisplayName = 'SilentGhost'\n#SELECT: badge name refers to badges.Name\n#SQL-like: Show badges.Name, WHERE users.DisplayName = 'SilentGhost'\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'SilentGhost'\n```"
    ],
    "714": [
        "```\n#reason: The question wants to list the comments made by the user with the username of Harvey Motulsky, so the SQL SELECT will retrieve the comments from the comments table where the user's display name matches 'Harvey Motulsky'.\n#columns: comments.Text, users.DisplayName\n#values: username of Harvey Motulsky refers to users.DisplayName = 'Harvey Motulsky'\n#SELECT: comments refer to comments.Text\n#SQL-like: Show comments.Text WHERE users.DisplayName = 'Harvey Motulsky'\n#SQL: SELECT T1.Text FROM comments AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harvey Motulsky'\n```"
    ],
    "317": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of carcinogenic molecules that contain the Chlorine element, so the SQL SELECT will count the number of carcinogenic molecules with the element 'cl' and divide it by the total number of molecules.\n#columns: molecule.label, atom.element, molecule.molecule_id\n#values: label = '+' refer to molecule.label = '+', chlorine element refers to atom.element = 'cl'\n#SELECT: percentage of carcinogenic molecules which contain the Chlorine element refer to CAST(SUM(IIF(label = '+' AND element = 'cl', 1, 0)) AS REAL) * 100 / COUNT(molecule_id)\n#SQL-like: Show CAST(SUM(IIF(label = '+' AND element = 'cl', 1, 0)) AS REAL) * 100 / COUNT(molecule_id)\n#SQL: SELECT CAST(SUM(IIF(molecule.label = '+' AND atom.element = 'cl', 1, 0)) AS REAL) * 100 / COUNT(molecule.molecule_id) FROM molecule INNER JOIN atom ON molecule.molecule_id = atom.molecule_id\n```"
    ],
    "1187": [
        "```\n#reason: The question wants to count how many patients had a GPT level greater than 30 and an ALB level less than 4 while being examined between specific dates, so the SQL SELECT needs to count the unique IDs of patients and apply the appropriate filters.\n#columns: Laboratory.ID, Laboratory.GPT, Laboratory.ALB, Laboratory.Date\n#values: examined between 1987/7/6 and 1996/1/31 refers to Laboratory.Date BETWEEN '1987-07-06' AND '1996-01-31', GPT level greater than 30 refers to Laboratory.GPT > 30, ALB level less than 4 refers to Laboratory.ALB < 4\n#SELECT: How many patients refer to COUNT(DISTINCT Laboratory.ID)\n#SQL-like: Show COUNT(DISTINCT Laboratory.ID), WHERE Laboratory.Date BETWEEN '1987-07-06' AND '1996-01-31' AND Laboratory.GPT > 30 AND Laboratory.ALB < 4\n#SQL: SELECT COUNT(DISTINCT T.ID) FROM Laboratory AS T WHERE T.Date BETWEEN '1987-07-06' AND '1996-01-31' AND T.GPT > 30 AND T.ALB < 4\n```"
    ],
    "230": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the elements of the toxicology and the label of a specific molecule, so the SQL SELECT will focus on those columns while filtering by the molecule ID.\n#columns: atom.element, molecule.label\n#values: TR060 refers to molecule.molecule_id = 'TR060'\n#SELECT: SELECT elements of the toxicology refer to atom.element and label refer to molecule.label\n#SQL-like: Show atom.element, molecule.label WHERE molecule.molecule_id = 'TR060'\n#SQL: SELECT T1.element, T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.molecule_id = 'TR060'\n```"
    ],
    "5": [
        "```\n#reason: The question wants to count the number of schools that have an average score in Math greater than 400 in the SAT test and are exclusively virtual, so the SQL SELECT will count the distinct schools that satisfy the conditions.\n#columns: schools.Virtual, satscores.AvgScrMath\n#values: exclusively virtual refers to schools.Virtual = 'F'; average score in Math greater than 400 refers to satscores.AvgScrMath > 400.\n#SELECT: SELECT COUNT(DISTINCT schools.Virtual) refer to COUNT(DISTINCT schools.Virtual)\n#SQL-like: Show COUNT(DISTINCT schools.Virtual), WHERE schools.Virtual = 'F' AND satscores.AvgScrMath > 400\n#SQL: SELECT COUNT(DISTINCT T1.Virtual) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.Virtual = 'F' AND T2.AvgScrMath > 400\n```"
    ],
    "52": [
        "```\n#reason: The question wants to find the total number of schools whose total SAT scores are greater or equal to 1500 and whose mailing city is Lakeport, so the SQL SELECT will count the schools that meet these conditions.\n#columns: satscores.AvgScrRead, satscores.AvgScrMath, satscores.AvgScrWrite, schools.MailCity, schools.CDSCode\n#values: mailing city is Lakeport refer to schools.MailCity = 'Lakeport', total SAT scores greater than or equal to 1500 refers to (satscores.AvgScrRead + satscores.AvgScrMath + satscores.AvgScrWrite) >= 1500\n#SELECT: total number of schools refer to COUNT(schools.CDSCode)\n#SQL-like: Show COUNT(schools.CDSCode), WHERE (satscores.AvgScrRead + satscores.AvgScrMath + satscores.AvgScrWrite) >= 1500 AND schools.MailCity = 'Lakeport'\n#SQL: SELECT COUNT(schools.CDSCode) FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE (satscores.AvgScrRead + satscores.AvgScrMath + satscores.AvgScrWrite) >= 1500 AND schools.MailCity = 'Lakeport'\n```"
    ],
    "1086": [
        "```\n#reason: The question wants to identify the \"heading accuracy\" of a specific player, \"Ariel Borysiuk\", which is the filtering condition.\n#columns: Player_Attributes.heading_accuracy, Player.player_name\n#values: 'Ariel Borysiuk' refers to Player.player_name = 'Ariel Borysiuk'\n#SELECT: heading accuracy refers to Player_Attributes.heading_accuracy\n#SQL-like: Show Player_Attributes.heading_accuracy, WHERE Player.player_name = 'Ariel Borysiuk'\n#SQL: SELECT T1.heading_accuracy FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Ariel Borysiuk'\n```"
    ],
    "997": [
        "```\n#reason: The question wants to determine the citizenship that the vast majority of drivers hold, so the SQL SELECT will find the nationality with the highest count.\n#columns: drivers.nationality\n#values: majority of drivers refer to MAX(COUNT(nationality))\n#SELECT: SELECT nationality refer to drivers.nationality\n#SQL-like: Show nationality, GROUP BY nationality, ORDER BY COUNT(nationality) DESC LIMIT 1\n#SQL: SELECT nationality FROM drivers GROUP BY nationality ORDER BY COUNT(nationality) DESC LIMIT 1\n```"
    ],
    "160": [
        "```\n#reason: The question wants to count the number of accounts with a loan amount under 200000, so the SQL SELECT will count the accounts filtered by frequency and loan amount.\n#columns: account.account_id, loan.amount\n#values: frequency = 'POPLATEK TYDNE' refers to account.frequency = 'POPLATEK TYDNE', loan of under 200000 refers to loan.amount < 200000\n#SELECT: SELECT COUNT(account.account_id) refer to COUNT(account.account_id)\n#SQL-like: Show COUNT(account.account_id), WHERE account.frequency = 'POPLATEK TYDNE' AND loan.amount < 200000\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T1.frequency = 'POPLATEK TYDNE' AND T2.amount < 200000\n```"
    ],
    "922": [
        "```\n#reason: The question wants to display the \"time\" of the race that took place on the \"Abu Dhabi Circuit\" in the year 2010. The filtering condition is based on the year and the circuit name.\n#columns: races.time, circuits.name, seasons.year\n#values: '2010' refers to seasons.year = 2010, 'Abu Dhabi Circuit' refers to circuits.name = 'Bahrain International Circuit'\n#SELECT: SELECT time refer to races.time\n#SQL-like: Show races.time WHERE seasons.year = 2010 AND circuits.name = 'Bahrain International Circuit'\n#SQL: SELECT T1.time FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId INNER JOIN seasons AS T3 ON T1.year = T3.year WHERE T3.year = 2010 AND T2.name = 'Bahrain International Circuit'\n```"
    ],
    "1046": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the freedom of movement in the 1st two thirds of the pitch for the ADO Den Haag team, so the SQL SELECT will retrieve the buildUpPlayPositioningClass from the Team_Attributes table where the team_long_name matches 'ADO Den Haag'.\n#columns: Team_Attributes.buildUpPlayPositioningClass, Team.team_long_name\n#values: 'ADO Den Haag' refers to Team.team_long_name = 'ADO Den Haag'\n#SELECT: SELECT buildUpPlayPositioningClass refer to Team_Attributes.buildUpPlayPositioningClass\n#SQL-like: Show Team_Attributes.buildUpPlayPositioningClass, WHERE Team.team_long_name = 'ADO Den Haag'\n#SQL: SELECT T1.buildUpPlayPositioningClass FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.team_long_name = 'ADO Den Haag'\n```"
    ],
    "734": [
        "```\n#reason: The question wants to display the publisher's name of a specific superhero, which is identified by the superhero name 'Blue Beetle II'.\n#columns: publisher.publisher_name, superhero.publisher_id\n#values: 'Blue Beetle II' refers to superhero.superhero_name = 'Blue Beetle II'\n#SELECT: publisher's name refers to publisher.publisher_name\n#SQL-like: Show publisher.publisher_name WHERE superhero.superhero_name = 'Blue Beetle II'\n#SQL: SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'\n```"
    ],
    "456": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all types for the card \"Molimo, Maro-Sorcerer\", so the SQL SELECT will include the subtypes and supertypes of the card where the name matches.\n#columns: cards.subtypes, cards.supertypes\n#values: 'card \"Molimo, Maro-Sorcerer\"' refer to cards.name = 'Molimo, Maro-Sorcerer'\n#SELECT: SELECT subtypes, supertypes refer to cards.subtypes, cards.supertypes\n#SQL-like: Show subtypes, supertypes WHERE name = 'Molimo, Maro-Sorcerer'\n#SQL: SELECT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'\n```"
    ],
    "1023": [
        "```\n#reason: The question wants to count players with an overall rating between 60 and 65 who have a low defensive work rate, so the SQL SELECT will count those players.\n#columns: Player_Attributes.overall_rating, Player_Attributes.defensive_work_rate, Player.id\n#values: overall_rating >= 60 AND overall_rating < 65 refer to Player_Attributes.overall_rating >= 60 AND Player_Attributes.overall_rating < 65, defensive_work_rate = 'low' refers to Player_Attributes.defensive_work_rate = 'low'\n#SELECT: SELECT COUNT(Player.id) refer to COUNT(Player.id)\n#SQL-like: Show COUNT(Player.id), WHERE Player_Attributes.overall_rating >= 60 AND Player_Attributes.overall_rating < 65 AND Player_Attributes.defensive_work_rate = 'low'\n#SQL: SELECT COUNT(T1.id) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating >= 60 AND T2.overall_rating < 65 AND T2.defensive_work_rate = 'low'\n```"
    ],
    "127": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list account IDs with monthly issuance of statements, so the SQL SELECT will target the account_id from the account table where the frequency is 'POPLATEK MESICNE'.\n#columns: account.account_id\n#values: 'monthly issuance of statements' refers to account.frequency = 'POPLATEK MESICNE'.\n#SELECT: SELECT account_id refer to account.account_id.\n#SQL-like: Show account.account_id WHERE account.frequency = 'POPLATEK MESICNE'\n#SQL: SELECT account.account_id FROM account WHERE account.frequency = 'POPLATEK MESICNE'\n```"
    ],
    "174": [
        "```\n#reason: The question asks for the \"year\" of birth for a specific \"account owner number\". The account owner number is mapped to the client record, and the birth date will be extracted to compute the year.\n#columns: client.birth_date\n#values: 'account owner number 130' refers to client.client_id = 130\n#SELECT: SELECT strftime('%Y', client.birth_date) refer to client.birth_date\n#SQL-like: Show strftime('%Y', client.birth_date), WHERE client.client_id = 130\n#SQL: SELECT strftime('%Y', T1.birth_date) FROM client AS T1 WHERE T1.client_id = 130\n```"
    ],
    "842": [
        "```\n#reason: The question wants to calculate the average height of all neutral superheroes, so the SQL SELECT will compute the average of the height column where the alignment is 'N/A'.\n#columns: superhero.height_cm, superhero.alignment_id\n#values: neutral superheroes refer to superhero.alignment_id = (SELECT id FROM alignment WHERE alignment = 'N/A')\n#SELECT: SELECT AVG(height_cm) refer to superhero.height_cm\n#SQL-like: Show AVG(superhero.height_cm) WHERE superhero.alignment_id = (SELECT id FROM alignment WHERE alignment = 'N/A')\n#SQL: SELECT AVG(height_cm) FROM superhero WHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'N/A')\n```"
    ],
    "1384": [
        "```\n#reason: The question wants to count the total income generated by Grant Gilmour, so the SQL SELECT will count the income amount where the member's first name is 'Grant' and last name is 'Gilmour'.\n#columns: income.amount\n#values: income generated refer to member.first_name = 'Grant' AND member.last_name = 'Gilmour'\n#SELECT: COUNT(income.amount) refer to income.amount\n#SQL-like: Show COUNT(income.amount), WHERE member.first_name = 'Grant' AND member.last_name = 'Gilmour'\n#SQL: SELECT COUNT(T1.amount) FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Grant' AND T2.last_name = 'Gilmour'\n```"
    ],
    "207": [
        "```\n#reason: The question wants to display the elements that are involved in a double type bond, so the SQL SELECT will focus on the bond type as a filtering condition and retrieve the elements connected by those bonds.\n#columns: atom.element\n#values: double type bond refers to bond.bond_type = '='\n#SELECT: SELECT elements refer to atom.element\n#SQL-like: Show atom.element, WHERE bond.bond_type = '='\n#SQL: SELECT atom.element FROM atom INNER JOIN bond ON atom.molecule_id = bond.molecule_id WHERE bond.bond_type = '='\n```"
    ],
    "1160": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of female patients whose total protein is not within the normal range, so the SQL SELECT counts the number of female patients who have total protein outside the specified range and divides it by the total count of female patients.\n#columns: Patient.SEX, Laboratory.TP, Patient.ID\n#values: female refers to sex = 'F'; total protein not within the normal range refers to Laboratory.TP < 6.0 OR Laboratory.TP > 8.5\n#SELECT: percentage of female patients with total protein not within the normal range refers to (COUNT(Patient.ID) WHERE Patient.SEX = 'F' AND (Laboratory.TP < 6.0 OR Laboratory.TP > 8.5) / COUNT(Patient.ID WHERE Patient.SEX = 'F')) * 100\n#SQL-like: Show (COUNT(Patient.ID) WHERE Patient.SEX = 'F' AND (Laboratory.TP < 6.0 OR Laboratory.TP > 8.5)) * 100 / COUNT(Patient.ID WHERE Patient.SEX = 'F')\n#SQL: SELECT CAST(COUNT(CASE WHEN T2.SEX = 'F' AND (T1.TP < 6.0 OR T1.TP > 8.5) THEN T2.ID END) AS REAL) * 100 / COUNT(CASE WHEN T2.SEX = 'F' THEN T2.ID END) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID\n```"
    ],
    "542": [
        "```\n#reason: The question wants to calculate the total number of comments of all the posts owned by the user with the display name 'csgillespie', so the SQL SELECT will sum the CommentCount from posts where the OwnerDisplayName matches 'csgillespie'.\n#columns: posts.CommentCount, posts.OwnerDisplayName\n#values: 'csgillespie' refers to posts.OwnerDisplayName = 'csgillespie'\n#SELECT: total number of comments refers to SUM(CommentCount)\n#SQL-like: Show SUM(posts.CommentCount), WHERE posts.OwnerDisplayName = 'csgillespie'\n#SQL: SELECT SUM(CommentCount) FROM posts WHERE OwnerDisplayName = 'csgillespie'\n```"
    ],
    "120": [
        "```\n#reason: The question wants to identify account holders from 'east Bohemia' between the years 1995 and 2000, so the SQL SELECT will include account ID and frequency of statement issuance for those accounts.\n#columns: account.account_id, account.frequency\n#values: 'from east Bohemia' refers to district.A3 = 'east Bohemia', 'from Year 1995 to 2000' refers to account.date BETWEEN '1995-01-01' AND '2000-12-31'\n#SELECT: account ID refers to account.account_id, frequency refers to account.frequency\n#SQL-like: Show account.account_id, account.frequency WHERE account.date BETWEEN '1995-01-01' AND '2000-12-31' AND district.A3 = 'east Bohemia'\n#SQL: SELECT T1.account_id, T1.frequency FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.date BETWEEN '1995-01-01' AND '2000-12-31' AND T2.A3 = 'east Bohemia'\n```"
    ],
    "648": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to provide the users' display names and available website URLs of the post with a favorite count of more than 150, so the SQL SELECT will include the relevant columns from the users and posts tables.\n#columns: users.DisplayName, users.WebsiteUrl\n#values: favorite count of more than 150 refers to posts.FavoriteCount > 150\n#SELECT: SELECT users.DisplayName, users.WebsiteUrl\n#SQL-like: Show users.DisplayName, users.WebsiteUrl, WHERE posts.FavoriteCount > 150\n#SQL: SELECT users.DisplayName, users.WebsiteUrl FROM users INNER JOIN posts ON users.Id = posts.OwnerUserId WHERE posts.FavoriteCount > 150\n```"
    ],
    "231": [
        "```\n#reason: The question wants to identify the bond type that accounted for the majority of the bonds in molecule TR010 and to determine if this molecule is carcinogenic, so the SQL SELECT will count the bond types and find the maximum, while also checking the carcinogenic status of the molecule.\n#columns: bond.bond_type, molecule.label\n#values: TR010 is the molecule id refer to bond.molecule_id = 'TR010'\n#SELECT: SELECT bond.bond_type, molecule.label refer to MAX(COUNT(bond.bond_type)) and molecule.label\n#SQL-like: Show bond.bond_type, molecule.label, WHERE bond.molecule_id = 'TR010' GROUP BY bond.bond_type ORDER BY COUNT(bond.bond_type) DESC LIMIT 1\n#SQL: SELECT T1.bond_type, T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR010' GROUP BY T1.bond_type ORDER BY COUNT(T1.bond_type) DESC LIMIT 1\n```"
    ],
    "1094": [
        "```\n#reason: The question wants to determine how much higher in percentage Ariel Borysiuk's overall rating is compared to Paulin Puel's overall rating, so the SQL SELECT will calculate the difference in their overall ratings, divide it by Paulin Puel's overall rating, and multiply by 100 to get the percentage.\n#columns: Player_Attributes.overall_rating\n#values: 'Ariel Borysiuk' refers to Player.player_name = 'Ariel Borysiuk', 'Paulin Puel' refers to Player.player_name = 'Paulin Puel'\n#SELECT: MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100) \n#SQL-like: Show MULTIPLY(DIVIDE(SUBTRACT(overall_rating WHERE player_name = 'Ariel Borysiuk', overall_rating WHERE player_name = 'Paulin Puel'), overall_rating WHERE player_name = 'Paulin Puel'), 100)\n#SQL: SELECT CAST((SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Ariel Borysiuk') ) - (SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Paulin Puel')) AS REAL) * 100 / (SELECT overall_rating FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Paulin Puel'))\n```"
    ],
    "801": [
        "```\n#reason: The question wants to find the ratio between male superheroes and female superheroes, so the SQL SELECT will divide the sum of male superheroes by the sum of female superheroes.\n#columns: superhero.gender_id\n#values: male superheroes refers to gender_id = 1, female superheroes refers to gender_id = 2\n#SELECT: SELECT DIVIDE(SUM(gender_id = 1), SUM(gender_id = 2)) refer to superhero.gender_id\n#SQL-like: Show DIVIDE(SUM(gender_id = 1), SUM(gender_id = 2))\n#SQL: SELECT CAST(SUM(CASE WHEN gender_id = 1 THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN gender_id = 2 THEN 1 ELSE 0 END) FROM superhero\n```"
    ],
    "682": [
        "```\n#reason: The question wants to identify the most valuable post in 2010, so the SQL SELECT will retrieve the post id and the owner's display name, filtering for the year 2010 and ordering by the maximum favorite count.\n#columns: posts.Id, posts.OwnerDisplayName\n#values: 'in 2010' refer to strftime('%Y', posts.CreationDate) = '2010'\n#SELECT: SELECT posts.Id, posts.OwnerDisplayName\n#SQL-like: Show posts.Id, posts.OwnerDisplayName, WHERE strftime('%Y', posts.CreationDate) = '2010', ORDER BY posts.FavoriteCount DESC LIMIT 1\n#SQL: SELECT posts.Id, posts.OwnerDisplayName FROM posts WHERE strftime('%Y', posts.CreationDate) = '2010' ORDER BY posts.FavoriteCount DESC LIMIT 1\n```"
    ],
    "1421": [
        "```\n#reason: The question wants to calculate the percentage of members who are majoring in Business, so the SQL SELECT counts the members with the major Business and divides it by the total count of members.\n#columns: member.position, major.major_name, member.member_id\n#values: 'majoring in Business' refer to major.major_name = 'Business'\n#SELECT: SELECT DIVIDE(SUM(position = 'Member' AND major_name = 'Business'), COUNT(member_id)) * 100 refer to member.position, major.major_name, member.member_id\n#SQL-like: Show DIVIDE(SUM(position = 'Member' AND major_name = 'Business'), COUNT(member_id)) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN T1.position = 'Member' AND T2.major_name = 'Business' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id\n```"
    ],
    "1265": [
        "```\n#reason: The question wants to count the distinct patients having a normal level of anti-ribonuclear protein and have been admitted to the hospital, so the SQL SELECT will count DISTINCT Patient.ID where RNP is either '-' or '+-' and Admission is '+'.\n#columns: Patient.ID, Laboratory.RNP, Patient.Admission\n#values: 'normal level of anti-ribonuclear protein' refer to Laboratory.RNP IN ('-', '+-'), 'admitted to the hospital' refer to Patient.Admission = '+'\n#SELECT: COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.RNP IN ('-', '+-') AND Patient.Admission = '+'\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP IN ('-', '+-') AND T1.Admission = '+'\n```"
    ],
    "993": [
        "```\n#reason: The question wants to display the \"location\", \"country\", and \"coordinates\" of the Hungaroring circuit, so the SQL SELECT will include these columns and filter by the circuit name.\n#columns: circuits.location, circuits.country, circuits.lat, circuits.lng\n#values: 'Hungaroring' refer to circuits.name = 'Hungaroring'\n#SELECT: SELECT location, country, (lat, lng) refer to circuits.location, circuits.country, circuits.lat, circuits.lng\n#SQL-like: Show circuits.location, circuits.country, (circuits.lat, circuits.lng), WHERE circuits.name = 'Hungaroring'\n#SQL: SELECT circuits.location, circuits.country, circuits.lat, circuits.lng FROM circuits WHERE circuits.name = 'Hungaroring'\n```"
    ],
    "381": [
        "```\n#reason: The question wants to list down the name of artists for cards in Chinese Simplified, so the SQL SELECT will target the artists' names filtered by the language.\n#columns: cards.artist\n#values: 'Chinese Simplified' refer to foreign_data.language = 'Chinese Simplified'.\n#SELECT: SELECT cards.artist refer to cards.artist.\n#SQL-like: Show cards.artist WHERE foreign_data.language = 'Chinese Simplified'\n#SQL: SELECT cards.artist FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'Chinese Simplified'\n```"
    ],
    "408": [
        "```\n#reason: The question wants to determine how many cards have unknown power and contain information about a triggered ability, so the SQL SELECT will count the cards where power is null or equal to '*' and the text contains 'triggered ability'.\n#columns: cards.power, cards.text\n#values: unknown power refers to cards.power IS NULL OR cards.power = '*', contain info about the triggered ability refers to cards.text LIKE '%triggered ability%'\n#SELECT: SELECT COUNT(*) refer to the count of cards\n#SQL-like: Show COUNT(*), WHERE cards.power IS NULL OR cards.power = '*' AND cards.text LIKE '%triggered ability%'\n#SQL: SELECT COUNT(*) FROM cards WHERE power IS NULL OR power = '*' AND text LIKE '%triggered ability%'\n```"
    ],
    "1245": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count how many examinations were done after 1997/1/1 that have an inactivated partial prothrombin time result. So the SQL SELECT will count the number of examinations where the `Examination Date` is greater than '1997-01-01' and the APTT is less than 45.\n#columns: Examination.`Examination Date`, Laboratory.APTT\n#values: examinations done after 1997/1/1 refer to `Examination Date` > '1997-01-01', normal activated partial prothrombin time refers to Laboratory.APTT < 45\n#SELECT: how many examinations refer to COUNT(*) \n#SQL-like: Show COUNT(*), WHERE `Examination Date` > '1997-01-01' AND Laboratory.APTT < 45\n#SQL: SELECT COUNT(*) FROM Examination AS E INNER JOIN Laboratory AS L ON E.ID = L.ID WHERE E.`Examination Date` > '1997-01-01' AND L.APTT < 45\n```"
    ],
    "527": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the rulings for the card named and designed by Kev Walker, so the SQL SELECT will target the rulings text and filter by the artist's name while ordering by date in descending order.\n#columns: rulings.text, rulings.date\n#values: 'artist is Kev Walker' refer to artist = 'Kev Walker'\n#SELECT: SELECT rulings.text refer to rulings.text\n#SQL-like: Show rulings.text WHERE artist = 'Kev Walker' ORDER BY rulings.date DESC\n#SQL: SELECT T1.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.artist = 'Kev Walker' ORDER BY T1.date DESC\n```"
    ],
    "1099": [
        "```\n#reason: The question wants to determine the preferred foot of Abdou Diallo, so the SQL SELECT will filter by the player's name and retrieve the preferred foot.\n#columns: Player_Attributes.preferred_foot\n#values: 'Abdou Diallo' refer to Player.player_name = 'Abdou Diallo'\n#SELECT: SELECT Player_Attributes.preferred_foot refer to Player_Attributes.preferred_foot\n#SQL-like: Show Player_Attributes.preferred_foot WHERE Player.player_name = 'Abdou Diallo'\n#SQL: SELECT T1.preferred_foot FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Abdou Diallo'\n```"
    ],
    "1106": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the defensive work rate for Kevin Berigaud on 2013/2/22, so the SQL SELECT will pull the relevant data from the Player and Player_Attributes tables with the appropriate filtering conditions.\n#columns: Player.player_name, Player_Attributes.defensive_work_rate, Player_Attributes.date\n#values: 'Kevin Berigaud' refer to Player.player_name = 'Kevin Berigaud', 'on 2013/2/22' refer to Player_Attributes.date = '2013-02-22 00:00:00'\n#SELECT: SELECT Player_Attributes.defensive_work_rate refer to Player_Attributes.defensive_work_rate\n#SQL-like: Show Player_Attributes.defensive_work_rate WHERE Player.player_name = 'Kevin Berigaud' AND Player_Attributes.date = '2013-02-22 00:00:00'\n#SQL: SELECT T1.defensive_work_rate FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Kevin Berigaud' AND T2.date = '2013-02-22 00:00:00'\n```"
    ],
    "868": [
        "```\n#reason: The question wants to determine the location coordinates of the Malaysian Grand Prix, so the SQL SELECT will retrieve the latitude and longitude of the circuit where the race is held.\n#columns: circuits.lat, circuits.lng\n#values: 'Malaysian Grand Prix' refer to races.name = 'Malaysian Grand Prix'\n#SELECT: SELECT circuits.lat, circuits.lng refer to circuits.lat, circuits.lng\n#SQL-like: Show circuits.lat, circuits.lng WHERE races.name = 'Malaysian Grand Prix'\n#SQL: SELECT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Malaysian Grand Prix'\n```"
    ],
    "1505": [
        "```\n#reason: The question requires counting the number of customers with specific currency and consumption conditions. Specifically, customers who paid in Euro and have a monthly consumption over 1000.\n#columns: customers.Currency, yearmonth.Consumption, yearmonth.CustomerID\n#values: 'pays in euro' refer to customers.Currency = 'EUR', 'monthly consumption of over 1000' refer to yearmonth.Consumption > 1000\n#SELECT: how many customers refer to COUNT(DISTINCT yearmonth.CustomerID)\n#SQL-like: Show COUNT(DISTINCT yearmonth.CustomerID), WHERE customers.Currency = 'EUR' AND yearmonth.Consumption > 1000\n#SQL: SELECT COUNT(DISTINCT T1.CustomerID) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Currency = 'EUR' AND T2.Consumption > 1000\n```"
    ],
    "428": [
        "```\n#reason: The question wants to display the \"name of set number 5\" and \"its translation\". The filter condition is set.id = 5.\n#columns: sets.name, set_translations.translation\n#values: set number 5 refers to sets.id = 5\n#SELECT: name of set number 5 refers to sets.name, its translation refers to set_translations.translation\n#SQL-like: Show sets.name, set_translations.translation WHERE sets.id = 5\n#SQL: SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.id = 5\n```"
    ],
    "189": [
        "```\n#reason: The question wants to find the account numbers of female clients who are the oldest and have the lowest average salary. This involves filtering for female clients, determining the oldest client, and finding the average salary to identify the lowest. \n#columns: account.account_id, client.client_id, district.A11, client.gender\n#values: female refers to client.gender = 'F', oldest refers to MAX(client.birth_date), lowest average salary refers to district.A11 = (SELECT MIN(A11) FROM district)\n#SELECT: account numbers refer to account.account_id\n#SQL-like: Show account.account_id WHERE client.gender = 'F' AND client.birth_date = (SELECT MAX(birth_date) FROM client WHERE gender = 'F') AND district.A11 = (SELECT MIN(A11) FROM district)\n#SQL: SELECT account.account_id FROM account INNER JOIN client ON account.account_id = client.client_id INNER JOIN district ON client.district_id = district.district_id WHERE client.gender = 'F' AND client.birth_date = (SELECT MAX(birth_date) FROM client WHERE gender = 'F') AND district.A11 = (SELECT MIN(A11) FROM district)\n```"
    ],
    "750": [
        "```\n#reason: The question wants to calculate the average weight of all female superheroes, so the SQL SELECT statement will compute the average using AVG(weight_kg) with the filter for gender being 'Female'.\n#columns: superhero.weight_kg, superhero.gender_id\n#values: female refers to superhero.gender_id = 2\n#SELECT: average weight refer to AVG(superhero.weight_kg)\n#SQL-like: Show AVG(superhero.weight_kg), WHERE superhero.gender_id = 2\n#SQL: SELECT AVG(superhero.weight_kg) FROM superhero WHERE superhero.gender_id = 2\n```"
    ],
    "1255": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the most common disease diagnosed among patients with an abnormal Ig M level, so the SQL SELECT will focus on counting the occurrences of diagnoses for patients whose Ig M levels are outside the normal range.\n#columns: Examination.Diagnosis, Laboratory.IGM\n#values: abnormal Ig M level refers to Laboratory.IGM <= 40 OR Laboratory.IGM >= 400\n#SELECT: SELECT MAX(Examination.Diagnosis) refer to Examination.Diagnosis\n#SQL-like: Show MAX(Examination.Diagnosis), WHERE Laboratory.IGM <= 40 OR Laboratory.IGM >= 400, GROUP BY Examination.Diagnosis ORDER BY COUNT(Examination.Diagnosis) DESC\n#SQL: SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGM <= 40 OR T2.IGM >= 400 GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1\n```"
    ],
    "1338": [
        "```\n#reason: The question wants to determine if each expense related to the event 'October Meeting' on '2019-10-08' was approved, so the SQL SELECT will check the approval status of expenses linked to that event.\n#columns: expense.approved, event.event_name, event.event_date\n#values: event_name = 'October Meeting' refers to event.event_name = 'October Meeting', event_date = '2019-10-08' refers to event.event_date = '2019-10-08'\n#SELECT: SELECT expense.approved refer to expense.approved\n#SQL-like: Show expense.approved, WHERE event.event_name = 'October Meeting' AND event.event_date = '2019-10-08'\n#SQL: SELECT expense.approved FROM expense INNER JOIN event ON expense.link_to_budget = event.event_id WHERE event.event_name = 'October Meeting' AND event.event_date = '2019-10-08'\n```"
    ],
    "858": [
        "```\n#reason: The question requires the display of the \"country\" of the \"constructor\" who got \"1 point\" in \"race No. 24\". The filtering conditions are raceId = 24 and points = 1.\n#columns: constructors.nationality, results.points, results.raceId\n#values: race number 24 refers to results.raceId = 24; 1 point refers to results.points = 1\n#SELECT: SELECT constructors.nationality\n#SQL-like: Show constructors.nationality WHERE results.raceId = 24 AND results.points = 1\n#SQL: SELECT T1.nationality FROM results AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T1.raceId = 24 AND T1.points = 1\n```"
    ],
    "572": [
        "```\n#reason: The question wants to find the total views of a specific post title, so the SQL SELECT will count the ViewCount from posts where the Title matches the given post title.\n#columns: posts.ViewCount, posts.Title\n#values: 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' refer to posts.Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'\n#SELECT: SELECT ViewCount\n#SQL-like: Show ViewCount WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'\n#SQL: SELECT ViewCount FROM posts WHERE Title = 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer'\n```"
    ],
    "19": [
        "```\n#reason: The question wants to display \"the phone number of the school that has the highest average score in Math\", so the SQL SELECT will include the school phone number and filter by the highest average score in Math.\n#columns: satscores.AvgScrMath, schools.Phone, satscores.sname, schools.CDSCode\n#values: highest average score in Math refers to \"ORDER BY AvgScrMath DESC LIMIT 1\"\n#SELECT: SELECT Phone refer to schools.Phone \n#SQL-like: Show schools.Phone, ORDER BY satscores.AvgScrMath DESC LIMIT 1\n#SQL: SELECT T2.Phone FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.AvgScrMath DESC LIMIT 1\n```"
    ],
    "1237": [
        "```\n#reason: The question wants to list out patients who are outpatients with low hemoglobin levels, so the SQL SELECT will return IDs and their sex based on the specified conditions.\n#columns: Patient.ID, Patient.SEX\n#values: outpatients refer to Patient.Admission = '-', low hemoglobin level refer to Laboratory.HGB < 10\n#SELECT: list out those have low hemoglobin level refer to Patient.ID, Patient.SEX\n#SQL-like: Show Patient.ID, Patient.SEX WHERE Patient.Admission = '-' AND Laboratory.HGB < 10\n#SQL: SELECT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.HGB < 10\n```"
    ],
    "498": [
        "```\n#reason: The question wants to retrieve the French name of the set of cards that includes \"Tendo Ice Bridge\" as a translated name, so the SQL SELECT will involve filtering by the card name and language.\n#columns: foreign_data.name, sets.name\n#values: 'Tendo Ice Bridge' refers to foreign_data.name = 'Tendo Ice Bridge', 'French' refers to foreign_data.language = 'French'\n#SELECT: SELECT foreign_data.name, sets.name refer to foreign_data.name, sets.name\n#SQL-like: Show foreign_data.name, sets.name, WHERE foreign_data.name = 'Tendo Ice Bridge' AND foreign_data.language = 'French'\n#SQL: SELECT T1.name, T2.name FROM foreign_data AS T1 INNER JOIN sets AS T2 ON T1.uuid = T2.code WHERE T1.name = 'Tendo Ice Bridge' AND T1.language = 'French'\n```"
    ],
    "820": [
        "```\n#reason: The question wants to retrieve the strength attribute value of the Hulk, so the SQL SELECT will filter by the superhero's name and the attribute name.\n#columns: hero_attribute.attribute_value, attribute.attribute_name, superhero.superhero_name\n#values: 'the Hulk' refers to superhero.superhero_name = 'Hulk', 'Strength' refers to attribute.attribute_name = 'Strength'\n#SELECT: SELECT hero_attribute.attribute_value WHERE superhero.superhero_name = 'Hulk' AND attribute.attribute_name = 'Strength'\n#SQL-like: Show hero_attribute.attribute_value WHERE superhero.superhero_name = 'Hulk' AND attribute.attribute_name = 'Strength'\n#SQL: SELECT T1.attribute_value FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id INNER JOIN attribute AS T3 ON T1.attribute_id = T3.id WHERE T2.superhero_name = 'Hulk' AND T3.attribute_name = 'Strength'\n```"
    ],
    "424": [
        "```\n#reason: The question wants to determine the proportion of cards that do not have a text box with a normal layout, so the SQL SELECT will count the cards where isTextless = 1 and layout = 'normal' and divide it by the total count of cards, multiplying by 100 to get the proportion.\n#columns: cards.isTextless, cards.layout\n#values: do not have a text box refers to cards.isTextless = 1, normal layout refers to cards.layout = 'normal'\n#SELECT: proportion of cards that do not have a text box with a normal layout refer to (COUNT(cards.isTextless = 1 AND cards.layout = 'normal') / COUNT(cards.isTextless)) * 100\n#SQL-like: Show (COUNT(cards.isTextless = 1 AND cards.layout = 'normal') / COUNT(cards.isTextless)) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards\n```"
    ],
    "677": [
        "```\n#reason: The question wants to count the number of posts by Jay Stevens in 2010, so the SQL SELECT COUNT(posts.Id) and the filtering conditions are based on the user's display name and the year of the post's creation date.\n#columns: posts.Id, users.DisplayName, posts.CreaionDate\n#values: DisplayName = 'Jay Stevens' refer to users.DisplayName = 'Jay Stevens', in 2010 refer to strftime('%Y', posts.CreaionDate) = '2010'\n#SELECT: SELECT COUNT(posts.Id) refer to COUNT(posts.Id)\n#SQL-like: Show COUNT(posts.Id), WHERE users.DisplayName = 'Jay Stevens' AND strftime('%Y', posts.CreaionDate) = '2010'\n#SQL: SELECT COUNT(posts.Id) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Jay Stevens' AND strftime('%Y', posts.CreaionDate) = '2010'\n```"
    ],
    "690": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the latest badge awarded to the user with the display name Emmett, so the SQL SELECT will retrieve the badge name from the badges table where the date is the maximum for that user.\n#columns: badges.Name, badges.Date, users.DisplayName\n#values: 'user with the display name Emmett' refer to users.DisplayName = 'Emmett'\n#SELECT: SELECT badges.Name refer to badges.Name\n#SQL-like: Show badges.Name WHERE users.DisplayName = 'Emmett' ORDER BY badges.Date DESC LIMIT 1\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Emmett' ORDER BY T1.Date DESC LIMIT 1\n```"
    ],
    "1089": [
        "```\n#reason: The question wants to determine the number of matches held in Belgium during the 2008/2009 season, so the SQL SELECT COUNT(Match.id) and COUNT(Match.id) corresponds to the count of matches in the specified season and country.\n#columns: Match.id, Match.country_id, Country.name, Match.season\n#values: 'Belgium' refers to Country.name = 'Belgium', '2008/2009' refers to Match.season = '2008/2009'\n#SELECT: SELECT COUNT(M.id) refer to COUNT(Match.id)\n#SQL-like: Show COUNT(Match.id), WHERE Country.name = 'Belgium' AND Match.season = '2008/2009'\n#SQL: SELECT COUNT(M.id) FROM Match AS M INNER JOIN Country AS C ON M.country_id = C.id WHERE C.name = 'Belgium' AND M.season = '2008/2009'\n```"
    ],
    "1327": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the full name of all the members of the Student_Club who attended the \"Laugh Out Loud\" event, so the SQL SELECT will include the first_name and last_name from the member table and will JOIN with the attendance and event tables to filter by the event name.\n#columns: member.first_name, member.last_name, event.event_name\n#values: 'Laugh Out Loud' refers to event.event_name = 'Laugh Out Loud'\n#SELECT: SELECT member.first_name, member.last_name refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name WHERE event.event_name = 'Laugh Out Loud'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Laugh Out Loud'\n```"
    ],
    "685": [
        "```\n#reason: The question wants to identify the total views on the post 'Computer Game Datasets' and the name of the user who posted it last time, so the SQL SELECT will include the total views from the posts table and the display name from the users table.\n#columns: posts.ViewCount, users.DisplayName\n#values: post 'Computer Game Datasets' refers to posts.Text = 'Computer Game Datasets'\n#SELECT: SELECT posts.ViewCount, users.DisplayName\n#SQL-like: Show posts.ViewCount, users.DisplayName WHERE posts.Text = 'Computer Game Datasets'\n#SQL: SELECT posts.ViewCount, users.DisplayName FROM posts INNER JOIN users ON posts.LastEditorUserId = users.Id WHERE posts.Text = 'Computer Game Datasets'\n```"
    ],
    "254": [
        "```\n#reason: The question wants to calculate the percentage of bonds that have the most common combination of atoms' elements, so the SQL SELECT will count the bonds and divide it by the count of atoms corresponding to the most common combination of elements.\n#columns: bond.bond_id, atom.element\n#values: 'most common combination of atoms' elements' refer to atom.element = (SELECT atom.element FROM atom GROUP BY atom.element ORDER BY COUNT(atom.element) DESC LIMIT 1)\n#SELECT: SELECT CAST(COUNT(bond.bond_id) AS REAL) * 100 / COUNT(atom.element) FROM bond INNER JOIN atom ON bond.molecule_id = atom.molecule_id WHERE atom.element = (SELECT atom.element FROM atom GROUP BY atom.element ORDER BY COUNT(atom.element) DESC LIMIT 1)\n#SQL-like: Show CAST(COUNT(bond.bond_id) AS REAL) * 100 / COUNT(atom.element) FROM bond INNER JOIN atom ON bond.molecule_id = atom.molecule_id WHERE atom.element = (SELECT atom.element FROM atom GROUP BY atom.element ORDER BY COUNT(atom.element) DESC LIMIT 1)\n#SQL: SELECT CAST(COUNT(bond.bond_id) AS REAL) * 100 / COUNT(atom.element) FROM bond INNER JOIN atom ON bond.molecule_id = atom.molecule_id WHERE atom.element = (SELECT atom.element FROM atom GROUP BY atom.element ORDER BY COUNT(atom.element) DESC LIMIT 1)\n```"
    ],
    "748": [
        "```\n#reason: The question wants to display the \"eye colour\" of a superhero. This involves filtering by \"superhero ID 75\" which translates to superhero.id = 75, and selecting the \"eye colour\" which is linked through eye_colour_id.\n#columns: colour.colour, superhero.eye_colour_id\n#values: superhero ID 75 refers to superhero.id = 75\n#SELECT: eye colour refers to colour\n#SQL-like: Show colour WHERE superhero.id = 75\n#SQL: SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.id = 75\n```"
    ],
    "643": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to show the display names and ages of users who got the highest in views, so the SQL SELECT will be on users.DisplayName and users.Age, and we want to filter for the maximum views.\n#columns: users.DisplayName, users.Age\n#values: highest in views refers to views = (SELECT MAX(Views) FROM users)\n#SELECT: SELECT users.DisplayName, users.Age \n#SQL-like: Show users.DisplayName, users.Age WHERE users.Views = (SELECT MAX(Views) FROM users)\n#SQL: SELECT users.DisplayName, users.Age FROM users WHERE users.Views = (SELECT MAX(Views) FROM users)\n```"
    ],
    "1130": [
        "```\n#reason: The question wants to display the short name of teams that create chances while passing safely. Thus, the SQL SELECT statement will pull data based on the filtering condition \"chanceCreationPassingClass = 'Safe'\".\n#columns: Team.team_short_name\n#values: played safe while creating chance of passing refers to chanceCreationPassingClass = 'Safe'\n#SELECT: short name of team refer to Team.team_short_name.\n#SQL-like: Show Team.team_short_name WHERE Team_Attributes.chanceCreationPassingClass = 'Safe'\n#SQL: SELECT T1.team_short_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.chanceCreationPassingClass = 'Safe'\n```"
    ],
    "847": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve \"the surname of the driver\" who has the best lap time in \"race number 19\" during \"the second qualifying period\". This involves filtering for a specific race ID and calculating the minimum time recorded in the second qualifying period.\n#columns: drivers.surname, qualifying.q2\n#values: race number refers to qualifying.raceId = 19, second qualifying period refers to qualifying.q2 is not null\n#SELECT: SELECT drivers.surname refer to drivers.surname\n#SQL-like: Show drivers.surname WHERE qualifying.raceId = 19 AND qualifying.q2 IS NOT NULL ORDER BY qualifying.q2 LIMIT 1\n#SQL: SELECT T1.surname FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 19 AND T2.q2 IS NOT NULL ORDER BY T2.q2 LIMIT 1\n```"
    ],
    "434": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question want to count sets flagged as available in Japanese, so the SQL SELECT COUNT(*) ...)\n#columns: sets.keyruneCode, sets.name\n#values: Japanese refer to set_translations.language = 'Japanese', not in Magic: The Gathering Online refer to sets.mtgoCode IS NULL OR sets.mtgoCode = ''\n#SELECT: How many sets refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE set_translations.language = 'Japanese' AND (sets.mtgoCode IS NULL OR sets.mtgoCode = '')\n#SQL: SELECT COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')\n```"
    ],
    "599": [
        "```\n#reason: The question wants to display the post history type IDs for a specific post and count the unique users who have commented on that post, so the SQL SELECT will retrieve the post history type IDs and count distinct user IDs from comments.\n#columns: postHistory.PostHistoryTypeId, comments.UserId\n#values: post ID 3720 refers to postHistory.PostId = 3720 and comments.PostId = 3720\n#SELECT: post history type IDs refer to postHistory.PostHistoryTypeId, how many unique users refer to COUNT(DISTINCT comments.UserId)\n#SQL-like: Show postHistory.PostHistoryTypeId, COUNT(DISTINCT comments.UserId) WHERE postHistory.PostId = 3720 AND comments.PostId = 3720\n#SQL: SELECT postHistory.PostHistoryTypeId, COUNT(DISTINCT comments.UserId) FROM postHistory INNER JOIN comments ON postHistory.PostId = comments.PostId WHERE postHistory.PostId = 3720\n```"
    ],
    "1390": [
        "```\n#reason: The question wants to calculate the percentage of the total cost for the 'Yearly Kickoff' event compared to the total cost for all events. This involves summing the costs for the specific event and dividing it by the total costs, then multiplying by 100 to get the percentage.\n#columns: expense.cost, event.event_name\n#values: event_name = 'Yearly Kickoff' refer to event.event_name = 'Yearly Kickoff'\n#SELECT: SELECT SUM(cost WHERE event_name = 'Yearly Kickoff') * 100 / SUM(cost) \n#SQL-like: Show SUM(cost WHERE event_name = 'Yearly Kickoff') * 100 / SUM(cost)\n#SQL: SELECT CAST(SUM(CASE WHEN T1.event_name = 'Yearly Kickoff' THEN T2.cost ELSE 0 END) AS REAL) * 100 / SUM(T2.cost) FROM expense AS T2 INNER JOIN event AS T1 ON T2.link_to_event = T1.event_id\n```"
    ],
    "323": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to check if molecule TR000 is carcinogenic by referring to its label, so the SQL SELECT will retrieve the label for the specified molecule.\n#columns: molecule.label\n#values: TR000 refers to molecule.molecule_id = 'TR000'\n#SELECT: SELECT label refer to molecule.label\n#SQL-like: Show molecule.label WHERE molecule.molecule_id = 'TR000'\n#SQL: SELECT label FROM molecule WHERE molecule.molecule_id = 'TR000'\n```"
    ],
    "564": [
        "```\n#reason: The question wants to retrieve the only one comment text of the post with a specific parent id, so the SQL SELECT needs to filter for posts with a parent id of 107829 and ensure that there is only one comment.\n#columns: comments.Text\n#values: the only one comment refers to comments.CommentCount = '1' and parent id is 107829 refers to posts.ParentId = 107829\n#SELECT: SELECT comments.Text\n#SQL-like: Show comments.Text WHERE posts.ParentId = 107829 AND comments.CommentCount = '1'\n#SQL: SELECT comments.Text FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.ParentId = 107829 AND posts.CommentCount = 1\n```"
    ],
    "1154": [
        "```\n#reason: The question wants to state the sex and birthday of patient ID '163109', and also to find out when the examination was taken and what symptom the patient had, so the SQL SELECT will include Patient.SEX, Patient.Birthday, Examination.`Examination Date`, and Examination.Symptoms.\n#columns: Patient.SEX, Patient.Birthday, Examination.`Examination Date`, Examination.Symptoms\n#values: patient ID '163109' refers to Patient.ID = 163109\n#SELECT: State the sex and birthday of patient ID '163109' and when the examination was taken and what symptom does the patient had refers to Patient.SEX, Patient.Birthday, Examination.`Examination Date`, Examination.Symptoms\n#SQL-like: Show Patient.SEX, Patient.Birthday, Examination.`Examination Date`, Examination.Symptoms WHERE Patient.ID = 163109\n#SQL: SELECT T1.SEX, T1.Birthday, T2.`Examination Date`, T2.Symptoms FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.ID = 163109\n```"
    ],
    "931": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the fastest lap speed among all drivers for the 2009 Spanish Grand Prix, so the SQL SELECT will focus on the maximum fastest lap speed where the race name matches and the year is specified.\n#columns: results.fastestLapSpeed\n#values: Spanish Grand Prix refers to races.name = 'Spanish Grand Prix'\n#SELECT: SELECT the fastest lap speed refer to results.fastestLapSpeed\n#SQL-like: Show MAX(results.fastestLapSpeed), WHERE races.name = 'Spanish Grand Prix'\n#SQL: SELECT MAX(results.fastestLapSpeed) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009\n```"
    ],
    "1413": [
        "```\n#reason: The question wants to retrieve the zip code of the member who incurred less than 50 USD in expenses, so the SQL SELECT will focus on the member's zip code based on the expense cost criteria.\n#columns: member.zip, expense.cost\n#values: incurred less than 50 USD refers to expense.cost < 50\n#SELECT: SELECT member.zip refer to member.zip\n#SQL-like: Show member.zip WHERE expense.cost < 50\n#SQL: SELECT T1.zip FROM member AS T1 INNER JOIN expense AS T2 ON T2.link_to_member = T1.member_id WHERE T2.cost < 50\n```"
    ],
    "111": [
        "```\n#reason: The question wants to count the number of accounts opened in Litomerice in 1996, so the SQL SELECT will count the account records that meet the criteria of being in the district 'Litomerice' and having a creation date in the year 1996.\n#columns: account.account_id, account.date, district.A2\n#values: 'Litomerice' refers to district.A2 = 'Litomerice'; '1996' refers to strftime('%Y', account.date) = '1996'\n#SELECT: COUNT(account.account_id) refers to COUNT(account.account_id)\n#SQL-like: Show COUNT(account.account_id) WHERE district.A2 = 'Litomerice' AND strftime('%Y', account.date) = '1996'\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Litomerice' AND strftime('%Y', T1.date) = '1996'\n```"
    ],
    "991": [
        "```\n#reason: The question wants to display the \"full name and date of birth\" of Austrian drivers born between 1981 and 1991. Full name refers to the concatenation of \"forename\" and \"surname,\" and date of birth refers to \"dob.\" The filtering condition for year is based on the range between 1981 and 1991 for the date of birth and nationality as 'Austrian'.\n#columns: drivers.forename, drivers.surname, drivers.dob\n#values: 'born between 1981 and 1991' refer to strftime('%Y', dob) BETWEEN '1981' AND '1991', 'Austrian' refer to drivers.nationality = 'Austrian'\n#SELECT: SELECT full name refers to drivers.forename || ' ' || drivers.surname, date of birth refers to drivers.dob\n#SQL-like: Show drivers.forename || ' ' || drivers.surname, drivers.dob WHERE strftime('%Y', dob) BETWEEN '1981' AND '1991' AND drivers.nationality = 'Austrian'\n#SQL: SELECT drivers.forename || ' ' || drivers.surname, drivers.dob FROM drivers WHERE strftime('%Y', dob) BETWEEN '1981' AND '1991' AND drivers.nationality = 'Austrian'\n```"
    ],
    "760": [
        "```\n#reason: The question wants to calculate the percentage of superheroes whose height is between 150 and 180 cm and who are published by Marvel Comics. Therefore, the SQL SELECT statement involves filtering by height and publisher, applying a percentage calculation based on the publisher's ID.\n#columns: superhero.height_cm, publisher.publisher_name, publisher.id\n#values: height between 150 to 180 refers to superhero.height_cm BETWEEN 150 AND 180, heroes published by Marvel Comics refers to publisher_name = 'Marvel Comics'\n#SELECT: percentage of heroes published by Marvel Comics refers to MULTIPLY(DIVIDE(SUM(publisher.id = 13), COUNT(publisher.id)), 100)\n#SQL-like: Show MULTIPLY(DIVIDE(SUM(publisher.id = 13), COUNT(publisher.id)), 100), WHERE superhero.height_cm BETWEEN 150 AND 180\n#SQL: SELECT CAST(COUNT(CASE WHEN T3.id = 13 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(*) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180\n```"
    ],
    "1252": [
        "```\n#reason: The question wants to find out how many patients have a normal Ig G level and symptoms, so the SQL SELECT will filter based on the conditions of the Ig G level and whether symptoms are present.\n#columns: Laboratory.IGG, Examination.Symptoms\n#values: normal Ig G level refers to Laboratory.IGG > 900 AND Laboratory.IGG < 2000, have symptoms refers to Examination.Symptoms IS NOT NULL\n#SELECT: How many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.IGG > 900 AND Laboratory.IGG < 2000 AND Examination.Symptoms IS NOT NULL\n#SQL: SELECT COUNT(DISTINCT Patient.ID) FROM Laboratory INNER JOIN Examination ON Laboratory.ID = Examination.ID WHERE Laboratory.IGG > 900 AND Laboratory.IGG < 2000 AND Examination.Symptoms IS NOT NULL\n```"
    ],
    "405": [
        "```\n#reason: The question wants to determine the count of sets that are translated into Brazilian Portuguese and belong to the Commander block, so the SQL SELECT will count the distinct set codes where the block is 'Commander' and the language is 'Portuguese (Brazil)'.\n#columns: sets.code, set_translations.language\n#values: Commander block refer to sets.block = 'Commander', Portuguese refer to set_translations.language = 'Portuguese (Brazil)'\n#SELECT: SELECT COUNT(DISTINCT sets.code) refer to sets.code\n#SQL-like: Show COUNT(DISTINCT sets.code), WHERE sets.block = 'Commander' AND set_translations.language = 'Portuguese (Brazil)'\n#SQL: SELECT COUNT(DISTINCT sets.code) FROM sets INNER JOIN set_translations ON sets.code = set_translations.setCode WHERE sets.block = 'Commander' AND set_translations.language = 'Portuguese (Brazil)'\n```"
    ],
    "1019": [
        "```\n#reason: The question wants to calculate the average lap time in milliseconds of all lap records set on circuits in Italy, so the SQL SELECT will calculate AVG(milliseconds) with a filter for the country being 'Italy'.\n#columns: lapTimes.milliseconds, circuits.country\n#values: country = 'Italy' refer to circuits.country = 'Italy'\n#SELECT: average lap time refer to AVG(lapTimes.milliseconds)\n#SQL-like: Show AVG(lapTimes.milliseconds), WHERE circuits.country = 'Italy'\n#SQL: SELECT AVG(T1.milliseconds) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId WHERE T3.country = 'Italy'\n```"
    ],
    "151": [
        "```\n#reason: The question wants to list the name of the districts with accounts that made withdrawal transactions, so the SQL SELECT will retrieve district names where the transaction type is 'VYDAJ'.\n#columns: district.A2, trans.type\n#values: withdrawal transactions refers to trans.type = 'VYDAJ'\n#SELECT: SELECT district.A2 refer to district.A2\n#SQL-like: Show district.A2 WHERE trans.type = 'VYDAJ'\n#SQL: SELECT DISTINCT T1.A2 FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN trans AS T3 ON T2.account_id = T3.account_id WHERE T3.type = 'VYDAJ'\n```"
    ],
    "1506": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the product descriptions of the transactions taken place in the gas stations in the Czech Republic, so the SQL SELECT will include product descriptions filtered by gas stations located in 'CZE'.\n#columns: products.Description\n#values: 'Czech Republic' refer to gasstations.Country = 'CZE'\n#SELECT: SELECT products.Description\n#SQL-like: Show products.Description WHERE gasstations.Country = 'CZE'\n#SQL: SELECT DISTINCT T1.Description FROM products AS T1 INNER JOIN transactions_1k AS T2 ON T1.ProductID = T2.ProductID INNER JOIN gasstations AS T3 ON T2.GasStationID = T3.GasStationID WHERE T3.Country = 'CZE'\n```"
    ],
    "587": [
        "```\n#reason: The question wants to calculate the average view count of each post tagged as 'humor' and list the title and the comment of each post. The average view count is calculated using AVG(ViewCount), and the filtering condition is based on the tag '<humor>'. The title and comment are also selected from the posts and post history tables.\n#columns: posts.Title, postHistory.Text, posts.ViewCount\n#values: tagged as 'humor' refers to tags.TagName = '<humor>'\n#SELECT: SELECT posts.Title, postHistory.Text, AVG(posts.ViewCount) refer to posts.Title, postHistory.Text, posts.ViewCount\n#SQL-like: Show posts.Title, postHistory.Text, AVG(posts.ViewCount) WHERE tags.TagName = '<humor>'\n#SQL: SELECT posts.Title, postHistory.Text, AVG(posts.ViewCount) FROM posts INNER JOIN postHistory ON posts.Id = postHistory.PostId INNER JOIN tags ON posts.Tags LIKE '%' || tags.TagName || '%' WHERE tags.TagName = '<humor>' GROUP BY posts.Title, postHistory.Text\n```"
    ],
    "1377": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question want to count how many students have the position of president, so the SQL SELECT will count member.position where the position is 'President')\n#columns: member.position\n#values: position is 'President' refer to member.position = 'President'\n#SELECT: SELECT COUNT(position) FROM member WHERE position = 'President'\n#SQL-like: Show COUNT(member.position), WHERE member.position = 'President'\n#SQL: SELECT COUNT(position) FROM member WHERE position = 'President'\n```"
    ],
    "1337": [
        "```\n#reason: The question wants to calculate the total budgeted amount for all categories in the \"October Speaker\" event, so the SQL SELECT will sum the budgeted amounts where the event name matches \"October Speaker\".\n#columns: budget.amount, event.event_name\n#values: 'October Speaker' refer to event.event_name = 'October Speaker'\n#SELECT: total budgeted amount refers to SUM(budget.amount)\n#SQL-like: Show SUM(budget.amount), WHERE event.event_name = 'October Speaker'\n#SQL: SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'October Speaker'\n```"
    ],
    "619": [
        "```\n#reason: The question wants to determine the number of adults who obtained the badge Supporter, so the SQL SELECT will count the users who have the badge and are within the specified age range.\n#columns: badges.UserId, users.Age\n#values: Supporter refers to badges.Name = 'Supporter', adult refers to users.Age BETWEEN 19 AND 65\n#SELECT: How many adults refer to COUNT(badges.UserId)\n#SQL-like: Show COUNT(badges.UserId), WHERE badges.Name = 'Supporter' AND users.Age BETWEEN 19 AND 65\n#SQL: SELECT COUNT(T1.UserId) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'Supporter' AND T2.Age BETWEEN 19 AND 65\n```"
    ],
    "766": [
        "```\n#reason: The question wants to display \"the hero's full name with the highest attribute in strength\". Hence, the SQL SELECT involves finding the hero's full name associated with the maximum attribute value for strength.\n#columns: superhero.full_name, hero_attribute.attribute_value, attribute.attribute_name\n#values: highest attribute in strength refers to hero_attribute.attribute_value = (SELECT MAX(hero_attribute.attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength')\n#SELECT: SELECT superhero.full_name refer to superhero.full_name\n#SQL-like: Show superhero.full_name WHERE hero_attribute.attribute_value = (SELECT MAX(hero_attribute.attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength')\n#SQL: SELECT superhero.full_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE hero_attribute.attribute_value = (SELECT MAX(hero_attribute.attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Strength')\n```"
    ],
    "1515": [
        "```\n#reason: The question wants to find the segment of the customer based on a specific date and time, so the SQL SELECT will retrieve the segment from the customers table where the customer ID matches the one in the transactions table for the given date and time.\n#columns: customers.Segment, transactions_1k.CustomerID, transactions_1k.Date, transactions_1k.Time\n#values: '2012/8/23 21:20:00' refers to transactions_1k.Date = '2012-08-23' AND transactions_1k.Time = '21:20:00'\n#SELECT: SELECT customers.Segment refer to customers.Segment\n#SQL-like: Show customers.Segment, WHERE transactions_1k.Date = '2012-08-23' AND transactions_1k.Time = '21:20:00'\n#SQL: SELECT T1.Segment FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date = '2012-08-23' AND T2.Time = '21:20:00'\n```"
    ],
    "951": [
        "```\n#reason: The question wants to display how many constructors of Japanese nationality have 0 points in exactly 2 races, so the SQL SELECT counts the races where points are equal to 0.\n#columns: constructorResults.constructorId, constructorResults.points, constructorResults.raceId\n#values: Japanese refers to constructors.nationality = 'Japanese', 0 points refer to constructorResults.points = 0\n#SELECT: SELECT COUNT(constructorResults.raceId) refer to COUNT(constructorResults.raceId)\n#SQL-like: Show COUNT(constructorResults.raceId) WHERE constructors.nationality = 'Japanese' AND constructorResults.points = 0 GROUP BY constructorResults.constructorId HAVING COUNT(constructorResults.raceId) = 2\n#SQL: SELECT COUNT(constructorResults.raceId) FROM constructorResults INNER JOIN constructors ON constructorResults.constructorId = constructors.constructorId WHERE constructors.nationality = 'Japanese' AND constructorResults.points = 0 GROUP BY constructorResults.constructorId HAVING COUNT(constructorResults.raceId) = 2\n```"
    ],
    "158": [
        "```\n#reason: The question requires displaying the \"district Id of the account\" that placed the specific order with id 33333. \"order with the id 33333\" is the filtering condition.\n#columns: account.district_id, order.order_id, order.account_id\n#values: 33333 refers to order.order_id = 33333\n#SELECT: district Id of the account refers to account.district_id\n#SQL-like: Show account.district_id, WHERE order.order_id = 33333\n#SQL: SELECT T1.district_id FROM account AS T1 INNER JOIN order AS T2 ON T1.account_id = T2.account_id WHERE T2.order_id = 33333\n```"
    ],
    "1401": [
        "```\n#reason: The question wants to indicate the cost of posters for the 'September Speaker' event, so the SQL SELECT will retrieve the cost from the expense table where the expense description is 'Posters' and the event name is 'September Speaker'.\n#columns: expense.cost, event.event_name\n#values: 'Posters' refer to expense.expense_description = 'Posters', 'September Speaker' refer to event.event_name = 'September Speaker'\n#SELECT: SELECT expense.cost, event.event_name\n#SQL-like: Show expense.cost, event.event_name WHERE expense.expense_description = 'Posters' AND event.event_name = 'September Speaker'\n#SQL: SELECT T1.cost, T2.event_name FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.expense_description = 'Posters' AND T3.event_name = 'September Speaker'\n```"
    ],
    "109": [
        "```\n#reason: The question wants to count the number of clients who opened their accounts in the Jesenik branch and are women, so the SQL SELECT will count the client IDs where the gender is 'F' and the district name is 'Jesenik'.\n#columns: client.client_id, client.gender, district.A2\n#values: clients opened their accounts in Jesenik branch refer to district.A2 = 'Jesenik', women refer to client.gender = 'F'\n#SELECT: COUNT(client.client_id) refer to COUNT(client.client_id)\n#SQL-like: Show COUNT(client.client_id), WHERE client.gender = 'F' AND district.A2 = 'Jesenik'\n#SQL: SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A2 = 'Jesenik'\n```"
    ],
    "167": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all the clients' IDs whose junior credit cards were issued after 1996, so the SQL SELECT will include the client IDs and apply the necessary filters.\n#columns: client.client_id, card.type, card.issued\n#values: junior credit cards refer to card.type = 'junior', issued after 1996 refers to card.issued >= '1997-01-01'\n#SELECT: SELECT content refers to client.client_id. \n#SQL-like: Show client.client_id, WHERE card.type = 'junior' AND card.issued >= '1997-01-01'\n#SQL: SELECT T1.client_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN card AS T3 ON T2.disp_id = T3.disp_id WHERE T3.type = 'junior' AND T3.issued >= '1997-01-01'\n```"
    ],
    "502": [
        "```\n#reason: The question wants to display the release date for the set \"Ola de frío\", so the SQL SELECT will retrieve the release date from the sets table where the translation matches 'Ola de frío'.\n#columns: sets.releaseDate\n#values: 'set \"Ola de frío\"' refer to set_translations.translation = 'Ola de frío'\n#SELECT: SELECT releaseDate refer to sets.releaseDate\n#SQL-like: Show sets.releaseDate, WHERE set_translations.translation = 'Ola de frío'\n#SQL: SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.translation = 'Ola de frío'\n```"
    ],
    "937": [
        "```\n#reason: The question wants to find the finish time for the driver who ranked second in the 2008 Australian Grand Prix, so the SQL SELECT will involve filtering by the race name and the rank, and selecting the finish time.\n#columns: results.time, results.rank, races.name, results.raceId\n#values: 'ranked second' refers to results.rank = 2, 'AustChineseralian Grand Prix' refers to races.name = 'Chinese Grand Prix', 'in 2008' refers to seasons.year = 2008\n#SELECT: SELECT results.time refer to results.time\n#SQL-like: Show results.time WHERE results.rank = 2 AND races.name = 'Chinese Grand Prix' AND seasons.year = 2008\n#SQL: SELECT T1.time FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN seasons AS T3 ON T2.year = T3.year WHERE T1.rank = 2 AND T2.name = 'Chinese Grand Prix' AND T3.year = 2008\n```"
    ],
    "975": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify \"which year has the lowest speed of lap time\", so the SQL SELECT will focus on identifying the year where the lap time is the maximum (indicating the slowest speed).\n#columns: races.year, lapTimes.time\n#values: lowest speed refers to Max(lapTimes.time)\n#SELECT: SELECT year refer to races.year, lap time refer to lapTimes.time\n#SQL-like: Show races.year, lapTimes.time ORDER BY lapTimes.time DESC LIMIT 1\n#SQL: SELECT T1.year FROM races AS T1 INNER JOIN lapTimes AS T2 ON T1.raceId = T2.raceId ORDER BY T2.time DESC LIMIT 1\n```"
    ],
    "946": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the location coordinates of the US circuits, so the SQL SELECT will retrieve the latitude and longitude from the circuits table where the country is 'USA'.\n#columns: circuits.lat, circuits.lng\n#values: 'the US' refers to circuits.country = 'USA'\n#SELECT: location coordinates refers to (circuits.lat, circuits.lng)\n#SQL-like: Show circuits.lat, circuits.lng WHERE circuits.country = 'USA'\n#SQL: SELECT circuits.lat, circuits.lng FROM circuits WHERE circuits.country = 'USA'\n```"
    ],
    "1017": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to list the location coordinates of the circuits whose lap record is 1:29.488, so the SQL SELECT circuits.lat, circuits.lng and circuits.name WHERE lapTimes.time = '1:29.488' and lapTimes.lap = 1)\n#columns: circuits.lat, circuits.lng\n#values: lap record is 1:29.488 refer to lapTimes.time = '1:29.488'\n#SELECT: location coordinates refers to circuits.lat, circuits.lng\n#SQL-like: Show circuits.lat, circuits.lng WHERE lapTimes.time = '1:29.488'\n#SQL: SELECT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN lapTimes AS T2 ON T1.circuitId = T2.raceId WHERE T2.time = '1:29.488'\n```"
    ],
    "218": [
        "```\n#reason: The question wants to determine the percentage of carcinogenic-type molecules that do not contain fluorine. The SQL SELECT statement counts the distinct molecules with the carcinogenic label ('+') and those that contain element 'f' (fluorine), calculating the percentage as required.\n#columns: molecule.label, atom.element, atom.molecule_id\n#values: label = '+' refers to molecule.label = '+', contain fluorine refers to atom.element = 'f'\n#SELECT: percentage of carcinogenic-type molecules that do not contain fluorine refer to DIVIDE(SUM(element = 'f') * 100, COUNT(molecule_id))\n#SQL-like: Show DIVIDE(SUM(CASE WHEN atom.element = 'f' THEN 1 ELSE 0 END) * 100, COUNT(DISTINCT atom.molecule_id)), WHERE molecule.label = '+'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.element = 'f' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'\n```"
    ],
    "1290": [
        "```\n#reason: The question want to find the \"examination date\" of the patient whose albumin is the highest in the normal range. The \"highest in the normal range\" for albumin is defined as MAX(ALB) where ALB is between 3.5 and 5.5.\n#columns: Laboratory.Date, Laboratory.ALB\n#values: albumin is the highest in the normal range refers to Laboratory.ALB > 3.5 AND Laboratory.ALB < 5.5\n#SELECT: SELECT Laboratory.Date refer to Laboratory.Date\n#SQL-like: Show Laboratory.Date WHERE Laboratory.ALB > 3.5 AND Laboratory.ALB < 5.5 ORDER BY Laboratory.ALB DESC LIMIT 1\n#SQL: SELECT Date FROM Laboratory WHERE ALB > 3.5 AND ALB < 5.5 ORDER BY ALB DESC LIMIT 1\n```"
    ],
    "372": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires displaying in order: \"How many cards\". The filtering condition is \"toughness of 99\".\n#columns: cards.toughness\n#values: toughness of 99 refers to cards.toughness = 99\n#SELECT: How many cards refer to COUNT(cards.toughness)\n#SQL-like: Show COUNT(cards.toughness), WHERE cards.toughness = 99\n#SQL: SELECT COUNT(toughness) FROM cards WHERE toughness = 99\n```"
    ],
    "657": [
        "```\n#reason: The question wants to display the display names and website URLs of the user who got the highest bounty amount under the vote type of 8, so the SQL SELECT will retrieve the maximum bounty amount and the corresponding user details.\n#columns: users.DisplayName, users.WebsiteUrl\n#values: vote type of 8 refers to votes.VoteTypeId = 8\n#SELECT: SELECT users.DisplayName, users.WebsiteUrl\n#SQL-like: Show users.DisplayName, users.WebsiteUrl WHERE votes.BountyAmount = MAX(votes.BountyAmount) AND votes.VoteTypeId = 8\n#SQL: SELECT T1.DisplayName, T1.WebsiteUrl FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.VoteTypeId = 8 AND T2.BountyAmount = (SELECT MAX(BountyAmount) FROM votes WHERE VoteTypeId = 8)\n```"
    ],
    "414": [
        "```\n#reason: The question wants to display the language of the set that has a base set size of 180, so the SQL SELECT will retrieve the language from the set_translations table where the baseSetSize is 180.\n#columns: set_translations.language\n#values: base set size of 180 refers to sets.baseSetSize = 180\n#SELECT: language refer to set_translations.language\n#SQL-like: Show set_translations.language WHERE sets.baseSetSize = 180\n#SQL: SELECT T1.language FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.baseSetSize = 180\n```"
    ],
    "124": [
        "```\n#reason: The question requires displaying the \"loan ID\", \"district\", and \"average salary\" for loans with a duration of 60 months. The filter involves finding loans specifically with a duration of 60 months.\n#columns: loan.loan_id, district.A2, district.A11\n#values: duration of 60 months refers to loan.duration = 60\n#SELECT: loan ID refer to loan.loan_id, district refer to district.A2, average salary refer to district.A11\n#SQL-like: Show loan.loan_id, district.A2, district.A11, WHERE loan.duration = 60\n#SQL: SELECT loan.loan_id, district.A2, district.A11 FROM loan INNER JOIN account ON loan.account_id = account.account_id INNER JOIN district ON account.district_id = district.district_id WHERE loan.duration = 60\n```"
    ],
    "529": [
        "```\n#reason: The question wants to find and list the names of sets which doesn't have Japanese translation but have Korean translation, so the SQL SELECT will filter the sets based on the presence of translations for Korean and the absence for Japanese.\n#columns: sets.name, set_translations.language\n#values: doesn't have Japanese translation refer to set_translations.language NOT LIKE '%Japanese%', have Korean translation refer to set_translations.language = 'Korean'\n#SELECT: SELECT sets.name refer to sets.name\n#SQL-like: Show sets.name, WHERE set_translations.language NOT LIKE '%Japanese%' AND set_translations.language = 'Korean'\n#SQL: SELECT T1.name FROM sets AS T1 LEFT JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Korean' AND (SELECT COUNT(*) FROM set_translations AS T3 WHERE T3.setCode = T1.code AND T3.language LIKE '%Japanese%') = 0\n```"
    ],
    "1372": [
        "```\n#reason: The question asks for \"When did the member, Casey Mason, received the income?\" which refers to the date_income received. So the SQL SELECT will target the date_received of that member.\n#columns: income.date_received, member.first_name, member.last_name\n#values: 'Casey Mason' refers to member.first_name = 'Casey' AND member.last_name = 'Mason'\n#SELECT: SELECT income.date_received refer to income.date_received\n#SQL-like: Show income.date_received WHERE member.first_name = 'Casey' AND member.last_name = 'Mason'\n#SQL: SELECT T1.date_received FROM income AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.first_name = 'Casey' AND T2.last_name = 'Mason'\n```"
    ],
    "828": [
        "```\n#reason: The question wants to count the superheroes with the highest attribute value for speed, so the SQL SELECT will count the occurrences of hero IDs where the attribute value for the attribute name 'Speed' is 100.\n#columns: COUNT(hero_attribute.hero_id)\n#values: attribute_value = 100 and attribute_name = 'Speed' refer to hero_attribute.attribute_value = 100 AND attribute.attribute_name = 'Speed'\n#SELECT: COUNT(hero_attribute.hero_id) refer to COUNT(hero_attribute.hero_id)\n#SQL-like: COUNT(hero_attribute.hero_id) WHERE hero_attribute.attribute_value = 100 AND attribute.attribute_name = 'Speed'\n#SQL: SELECT COUNT(T1.hero_id) FROM hero_attribute AS T1 INNER JOIN attribute AS T2 ON T1.attribute_id = T2.id WHERE T1.attribute_value = 100 AND T2.attribute_name = 'Speed'\n```"
    ],
    "140": [
        "```\n#reason: The question requires displaying \"How many accounts\" in the district of \"Pisek\". The district name \"Pisek\" is a filtering condition.\n#columns: account.account_id, account.district_id, district.A2\n#values: district name \"Pisek\" refers to district.A2 = 'Pisek'\n#SELECT: How many accounts refer to COUNT(account.account_id)\n#SQL-like: Show COUNT(account.account_id), WHERE district.A2 = 'Pisek'\n#SQL: SELECT COUNT(account.account_id) FROM account INNER JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Pisek'\n```"
    ],
    "198": [
        "```\n#reason: The question wants to calculate the average number of carcinogenic molecules that are single bonded, so the SQL SELECT will sum the instances of single bonds and divide by the count of atoms.\n#columns: bond.bond_type, molecule.label, bond.molecule_id, atom.atom_id\n#values: carcinogenic molecules refers to label = '+' and single-bonded refers to bond_type = '-'\n#SELECT: average number of carcinogenic molecules refer to DIVIDE(SUM(bond.bond_type = '-'), COUNT(atom.atom_id))\n#SQL-like: Show DIVIDE(SUM(bond.bond_type = '-'), COUNT(atom.atom_id)), WHERE molecule.label = '+' AND bond.bond_type = '-'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.bond_type = '-' THEN 1 ELSE 0 END) AS REAL) / COUNT(T2.atom_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'\n```"
    ],
    "107": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the gender of the oldest client who opened their account in the branch with the highest average salary, so the SQL SELECT will involve filtering clients by their birth date and joining with the district table to get the average salary.\n#columns: client.gender, client.birth_date, account.district_id, district.A11\n#values: 'oldest client' refers to MIN(client.birth_date), 'highest average salary branch' refers to MAX(district.A11)\n#SELECT: SELECT client.gender, client.birth_date refer to client.gender, client.birth_date\n#SQL-like: Show client.gender, client.birth_date WHERE account.district_id = (SELECT district_id FROM district ORDER BY A11 DESC LIMIT 1) ORDER BY client.birth_date ASC LIMIT 1\n#SQL: SELECT T1.gender FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN district AS T4 ON T3.district_id = T4.district_id WHERE T4.district_id = (SELECT district_id FROM district ORDER BY A11 DESC LIMIT 1) ORDER BY T1.birth_date ASC LIMIT 1\n```"
    ],
    "1465": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the budget category related to the expense description 'Posters', so the SQL SELECT will connect the expense with the budget.\n#columns: budget.category, expense.expense_description\n#values: 'Posters' refer to expense.expense_description = 'Posters'\n#SELECT: budget category refer to budget.category\n#SQL-like: Show budget.category, WHERE expense.expense_description = 'Posters'\n#SQL: SELECT T1.category FROM budget AS T1 INNER JOIN expense AS T2 ON T1.link_to_event = T2.link_to_budget WHERE T2.expense_description = 'Posters'\n```"
    ],
    "1134": [
        "```\n#reason: The question wants to determine the difference between the jumping scores of two specific players, so the SQL SELECT will subtract the jumping scores where the player IDs are 6 and 23 respectively.\n#columns: Player_Attributes.jumping, Player_Attributes.id\n#values: id = 6 refer to Player_Attributes.id = 6, id = 23 refer to Player_Attributes.id = 23\n#SELECT: difference between players 6 and 23's jumping scores refer to SUBTRACT(jumping AND id = 6, jumping AND id = 23)\n#SQL-like: Show SUBTRACT(MAX(jumping) WHERE id = 6, MAX(jumping) WHERE id = 23)\n#SQL: SELECT (SELECT jumping FROM Player_Attributes WHERE id = 6) - (SELECT jumping FROM Player_Attributes WHERE id = 23)\n```"
    ],
    "415": [
        "```\n#reason: The question wants to calculate the percentage of cards with the format 'commander' and legal status that do not have a content warning. The SQL SELECT statement will count the cards that meet these criteria and calculate the percentage based on the total count of cards in that format and status.\n#columns: cards.hasContentWarning, cards.id, legalities.format, legalities.status\n#values: 'commander' refers to legalities.format = 'commander', 'legal' refers to legalities.status = 'Legal', 'do not have a content warning' refers to cards.hasContentWarning = 0\n#SELECT: SELECT DIVIDE(COUNT(CASE WHEN cards.hasContentWarning = 0 THEN 1 END), COUNT(cards.id)) * 100\n#SQL-like: Show DIVIDE(COUNT(CASE WHEN cards.hasContentWarning = 0 THEN 1 END), COUNT(cards.id)) * 100, WHERE legalities.format = 'commander' AND legalities.status = 'Legal'\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.hasContentWarning = 0 THEN 1 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'\n```"
    ],
    "240": [
        "```\n#reason: The question wants to list all the elements of the toxicology of the molecule \"TR004\", so the SQL SELECT will fetch the elements for the specified molecule ID.\n#columns: atom.element\n#values: TR004 refers to atom.molecule_id = 'TR004'\n#SELECT: SELECT all elements refer to atom.element\n#SQL-like: Show atom.element WHERE atom.molecule_id = 'TR004'\n#SQL: SELECT element FROM atom WHERE molecule_id = 'TR004'\n```"
    ],
    "1260": [
        "```\n#reason: The question wants to list the ID of the patient whose RF is normal and who is older than 60, so the SQL SELECT will filter based on the RF value and the age calculation.\n#columns: Patient.ID, Laboratory.RF, Patient.Birthday\n#values: RF is normal refers to Laboratory.RF < '20.0', older than 60 refers to (strftime('%Y', 'now') - strftime('%Y', Patient.Birthday)) > 60\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID WHERE Laboratory.RF < '20.0' AND (strftime('%Y', 'now') - strftime('%Y', Patient.Birthday)) > 60\n#SQL: SELECT Patient.ID FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.RF < '20.0' AND (strftime('%Y', 'now') - strftime('%Y', Patient.Birthday)) > 60\n```"
    ],
    "570": [
        "```\n#reason: The question wants to display the badge's name for a specific user based on their display name, so the SQL SELECT will join the users and badges tables to filter by the user's display name.\n#columns: badges.Name, users.DisplayName\n#values: 'DatEpicCoderGuyWhoPrograms' refer to users.DisplayName = 'DatEpicCoderGuyWhoPrograms'\n#SELECT: badge's name refers to badges.Name\n#SQL-like: Show badges.Name, WHERE users.DisplayName = 'DatEpicCoderGuyWhoPrograms'\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'DatEpicCoderGuyWhoPrograms'\n```"
    ],
    "41": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the names of virtual schools that are among the top 5 in their respective counties based on average reading scores, so the SQL SELECT will involve filtering for exclusively virtual schools and ranking them within each county.\n#columns: schools.School, satscores.AvgScrRead, schools.County\n#values: exclusively virtual refers to schools.Virtual = 'F'\n#SELECT: SELECT schools.School refer to schools.School\n#SQL-like: Show schools.School WHERE schools.Virtual = 'F' ORDER BY satscores.AvgScrRead DESC LIMIT 5 PARTITION BY schools.County\n#SQL: WITH RankedSchools AS (SELECT schools.School, satscores.AvgScrRead, schools.County, ROW_NUMBER() OVER (PARTITION BY schools.County ORDER BY satscores.AvgScrRead DESC) AS rank FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE schools.Virtual = 'F') SELECT School FROM RankedSchools WHERE rank <= 5\n```"
    ],
    "650": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to describe the last accessed date and location of the users who received the outliers badge, so the SQL SELECT will include users' last accessed date and location where the badge name is 'outliers'.\n#columns: users.LastAccessDate, users.Location\n#values: badge name is 'outliers' refer to badges.Name = 'outliers'\n#SELECT: SELECT last accessed date, location refer to users.LastAccessDate, users.Location\n#SQL-like: Show users.LastAccessDate, users.Location WHERE badges.Name = 'outliers'\n#SQL: SELECT T1.LastAccessDate, T2.Location FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T1.Name = 'outliers'\n```"
    ],
    "817": [
        "```\n#reason: The question wants to identify the race of the blue-haired male superhero, so the SQL SELECT will extract the race from the superhero table based on the filters for hair color and gender.\n#columns: race.race\n#values: 'blue-haired' refers to colour.colour = 'Blue', 'male' refers to gender.gender = 'Male'\n#SELECT: SELECT race.race\n#SQL-like: Show race.race WHERE superhero.hair_colour_id = colour.id AND superhero.gender_id = gender.id\n#SQL: SELECT T3.race FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.colour = 'Blue' AND T3.gender = 'Male'\n```"
    ],
    "1459": [
        "```\n#reason: The question wants to find \"the major of Garrett Gerke\" and \"the department it belongs to\", so the SQL SELECT will retrieve major.major_name and major.department from the relevant tables based on the member's information.\n#columns: major.major_name, major.department\n#values: 'Garrett Gerke' refers to member.first_name = 'Garrett' AND member.last_name = 'Gerke'\n#SELECT: SELECT major.major_name, major.department refer to major.major_name, major.department\n#SQL-like: Show major.major_name, major.department WHERE member.first_name = 'Garrett' AND member.last_name = 'Gerke'\n#SQL: SELECT T1.major_name, T1.department FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Garrett' AND T2.last_name = 'Gerke'\n```"
    ],
    "1005": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires displaying the \"longest time a driver had ever spent at a pit stop.\" The \"longest time spent at pit stop\" refers to the MAX(duration).\n#columns: pitStops.duration\n#values: longest time spent at pit stop refers to MAX(duration)\n#SELECT: longest time refers to MAX(pitStops.duration)\n#SQL-like: Show MAX(pitStops.duration)\n#SQL: SELECT MAX(duration) FROM pitStops\n```"
    ],
    "373": [
        "```\n#reason: The question wants to retrieve the names of the cards illustrated by a specific artist, so the SQL SELECT will filter based on the artist's name.\n#columns: cards.name\n#values: 'Aaron Boyd' refers to cards.artist = 'Aaron Boyd'\n#SELECT: SELECT cards.name refer to cards.name\n#SQL-like: Show cards.name WHERE cards.artist = 'Aaron Boyd'\n#SQL: SELECT T1.name FROM cards AS T1 WHERE T1.artist = 'Aaron Boyd'\n```"
    ],
    "876": [
        "```\n#reason: The question wants to determine how many drivers did not finish the race on a specific date. Drivers who didn't finish are represented by having a null value in the 'time' column of the results table. The date of the race is a filtering condition.\n#columns: results.driverId, results.time, races.date\n#values: race date is '2015-11-29' refer to races.date = '2015-11-29'\n#SELECT: How many drivers refer to COUNT(results.driverId)\n#SQL-like: Show COUNT(results.driverId), WHERE results.time IS NULL AND races.date = '2015-11-29'\n#SQL: SELECT COUNT(T1.driverId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NULL AND T2.date = '2015-11-29'\n```"
    ],
    "934": [
        "```\n#reason: The question wants to identify the driver who was in the no. 4 grid formation during the 1989 Australian Grand Prix, so the SQL SELECT will retrieve the driver's forename and surname where the grid is 4 and the race is the Australian Grand Prix in 1989.\n#columns: drivers.forename, drivers.surname\n#values: 'in 1989' refers to races.year = 1989, 'Australian Grand Prix' refers to races.name = 'Australian Grand Prix', 'no. 4 grid formation' refers to results.grid = 4\n#SELECT: SELECT drivers.forename, drivers.surname\n#SQL-like: Show drivers.forename, drivers.surname WHERE results.grid = 4 AND races.year = 1989 AND races.name = 'Australian Grand Prix'\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T2.grid = 4 AND T3.year = 1989 AND T3.name = 'Australian Grand Prix'\n```"
    ],
    "701": [
        "```\n#reason: The question wants to identify the percentage of posts with a score above 50 posted by the most influential user, so the SQL SELECT will count the posts with a score above 50 and divide it by the total count of posts by that user.\n#columns: posts.Id, posts.Score, users.Reputation\n#values: 'the most influential user' refers to MAX(users.Reputation)\n#SELECT: SELECT CAST(COUNT(CASE WHEN posts.Score > 50 THEN 1 END) AS REAL) * 100 / COUNT(posts.Id) \n#SQL-like: Show percentage of posts with Score > 50 (CAST(COUNT(CASE WHEN posts.Score > 50 THEN 1 END) AS REAL) * 100 / COUNT(posts.Id)), WHERE users.Reputation = (SELECT MAX(Reputation) FROM users)\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.Score > 50 THEN 1 END) AS REAL) * 100 / COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.Reputation = (SELECT MAX(Reputation) FROM users)\n```"
    ],
    "1186": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all patients by ID who were diagnosed with Behcet's and had their exams in a specific date range, so the SQL SELECT will retrieve Patient.ID while applying the necessary filters for diagnosis and examination date.\n#columns: Patient.ID, Patient.Diagnosis, Patient.Description, Examination.`Examination Date`\n#values: diagnosed with Behcet's refers to Patient.Diagnosis = 'Behcet', exams between 01/01/1997 and 12/31/1997 refers to Patient.Description BETWEEN '1997-01-01' AND '1997-12-31'\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID, WHERE Patient.Diagnosis = 'Behcet' AND Patient.Description BETWEEN '1997-01-01' AND '1997-12-31'\n#SQL: SELECT Patient.ID FROM Patient INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Patient.Diagnosis = 'Behcet' AND Patient.Description BETWEEN '1997-01-01' AND '1997-12-31'\n```"
    ],
    "1133": [
        "```\n#reason: The question wants to find the count of football players who were born after the 1990s with the first name \"Aaron\". Therefore, the SQL SELECT will count the players matching these criteria.\n#columns: Player.id, Player.birthday, Player.player_name\n#values: born after the 1990s refers to birthday > '1990-01-01', first name \"Aaron\" refers to player_name LIKE 'Aaron%'\n#SELECT: How many football players refer to COUNT(Player.id)\n#SQL-like: Show COUNT(Player.id), WHERE Player.birthday > '1990-01-01' AND Player.player_name LIKE 'Aaron%'\n#SQL: SELECT COUNT(id) FROM Player WHERE birthday > '1990-01-01' AND player_name LIKE 'Aaron%'\n```"
    ],
    "598": [
        "```\n#reason: The question wants to calculate the percentage difference of student badges given during 2010 and 2011. The SQL SELECT statement will count the number of badges for each year and calculate the percentage difference based on the total count of badges.\n#columns: badges.Name, badges.Date\n#values: 'student badges' refers to badges.Name = 'Student', 'during 2010' refers to strftime('%Y', badges.Date) = '2010', 'during 2011' refers to strftime('%Y', badges.Date) = '2011'\n#SELECT: SELECT (CAST(COUNT(CASE WHEN strftime('%Y', Date) = '2010' THEN Name END) AS REAL) / COUNT(Name) * 100) - (CAST(COUNT(CASE WHEN strftime('%Y', Date) = '2011' THEN Name END) AS REAL) / COUNT(Name) * 100) AS percentage_difference\n#SQL-like: Show (CAST(COUNT(CASE WHEN strftime('%Y', Date) = '2010' THEN Name END) AS REAL) / COUNT(Name) * 100) - (CAST(COUNT(CASE WHEN strftime('%Y', Date) = '2011' THEN Name END) AS REAL) / COUNT(Name) * 100)\n#SQL: SELECT (CAST(COUNT(CASE WHEN strftime('%Y', badges.Date) = '2010' THEN badges.Name END) AS REAL) / COUNT(badges.Name) * 100) - (CAST(COUNT(CASE WHEN strftime('%Y', badges.Date) = '2011' THEN badges.Name END) AS REAL) / COUNT(badges.Name) * 100) AS percentage_difference FROM badges\n```"
    ],
    "1452": [
        "```\n#reason: The question wants to calculate the \"average amount paid\" by students who hold a position other than 'Member', so the SQL SELECT will compute the average by dividing the total cost by the count of events.\n#columns: expense.cost, member.position, expense.link_to_budget\n#values: position other than a member refer to member.position != 'Member'\n#SELECT: SELECT CAST(SUM(expense.cost) AS REAL) / COUNT(expense.link_to_budget) AS avg_amount_paid\n#SQL-like: Show CAST(SUM(expense.cost) AS REAL) / COUNT(expense.link_to_budget), WHERE member.position != 'Member'\n#SQL: SELECT CAST(SUM(T1.cost) AS REAL) / COUNT(T1.link_to_budget) AS avg_amount_paid FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.position != 'Member'\n```"
    ],
    "282": [
        "```\n#reason: The question wants to calculate the ratio of Hydrogen elements in molecule ID TR006 and display it along with its carcinogenic label. The SQL SELECT statement will sum the occurrences of Hydrogen elements and divide it by the total count of elements for the specified molecule ID, while also including the label indicating whether the molecule is carcinogenic or not.\n#columns: atom.element, molecule.label\n#values: molecule ID TR006 refer to atom.molecule_id = 'TR006'\n#SELECT: SELECT DIVIDE(SUM(element = 'h'), COUNT(element)), label refer to atom.element, molecule.label\n#SQL-like: Show DIVIDE(SUM(element = 'h'), COUNT(element)), molecule.label WHERE atom.molecule_id = 'TR006'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.element = 'h' THEN 1 ELSE 0 END) AS REAL) / COUNT(T1.element), T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.molecule_id = 'TR006'\n```"
    ],
    "1306": [
        "```\n#reason: The question wants to count the number of patients diagnosed with SLE who have a normal white blood cell level, so the SQL SELECT will count the distinct patients where the diagnosis is 'SLE' and the WBC is within the normal range.\n#columns: Patient.ID, Laboratory.WBC\n#values: diagnosed with SLE refers to Patient.Diagnosis = 'SLE', normal white blood cell level refers to Laboratory.WBC BETWEEN 3.5 AND 9.0\n#SELECT: COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.Diagnosis = 'SLE' AND Laboratory.WBC BETWEEN 3.5 AND 9.0\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SLE' AND T2.WBC BETWEEN 3.5 AND 9.0\n```"
    ],
    "900": [
        "```\n#reason: The question requires listing circuits in the USA that hosted F1 races in 2006, so the SQL SELECT will include the name and location of the circuit along with the name of the race it hosted.\n#columns: circuits.name, circuits.location, races.name\n#values: USA refers to circuits.country = 'USA', 2006 refers to races.year = 2006\n#SELECT: SELECT circuits.name, circuits.location, races.name\n#SQL-like: Show circuits.name, circuits.location, races.name, WHERE circuits.country = 'USA' AND races.year = 2006\n#SQL: SELECT T1.name, T1.location, T2.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T1.country = 'USA' AND T2.year = 2006\n```"
    ],
    "1175": [
        "```\n#reason: The question wants to find the age of the patient with the highest hemoglobin count at the time of the examination and the corresponding doctor's diagnosis, so the SQL SELECT will calculate the age using the examination date and birthday, and retrieve the diagnosis based on the highest hemoglobin count.\n#columns: Laboratory.HGB, Patient.Birthday, Examination.Diagnosis, Examination.`Examination Date`\n#values: highest hemoglobin count refers to HGB = (SELECT MAX(HGB) FROM Laboratory), and the age calculation is based on the examination date and birthday.\n#SELECT: SELECT SUBTRACT(year(`Examination Date`), year(Birthday)) AS age, Examination.Diagnosis\n#SQL-like: Show SUBTRACT(year(`Examination Date`), year(Birthday)), Examination.Diagnosis WHERE Laboratory.HGB = (SELECT MAX(HGB) FROM Laboratory)\n#SQL: SELECT SUBTRACT(strftime('%Y', T4.`Examination Date`), strftime('%Y', T2.Birthday)) AS age, T3.Diagnosis FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T2.ID = T3.ID WHERE T1.HGB = (SELECT MAX(HGB) FROM Laboratory)\n```"
    ],
    "1278": [
        "```\n#reason: The question wants to count the number of patients with a normal level of IGG who were admitted to the hospital, so the SQL SELECT will count the patients where IGG is within the normal range and Admission is '+'.\n#columns: Laboratory.IGG, Patient.Admission\n#values: normal level of IGG refers to Laboratory.IGG > 900 AND Laboratory.IGG < 2000, admitted to the hospital refers to Patient.Admission = '+'\n#SELECT: how many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Laboratory.IGG > 900 AND Laboratory.IGG < 2000 AND Patient.Admission = '+'\n#SQL: SELECT COUNT(Patient.ID) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Laboratory.IGG > 900 AND Laboratory.IGG < 2000 AND Patient.Admission = '+'\n```"
    ],
    "30": [
        "```\n#reason: The question wants to identify cities with the lowest enrollment numbers for students in grades 1 through 12, so the SQL SELECT will focus on retrieving the city names associated with the lowest enrollment values for that specific grade range.\n#columns: schools.City, frpm.`Enrollment (K-12)`\n#values: K-12 refers to frpm.`Enrollment (K-12)`, and we want the lowest values, so ORDER BY `Enrollment (K-12)` \n#SELECT: SELECT cities referring to schools.City\n#SQL-like: Show schools.City, ORDER BY frpm.`Enrollment (K-12)` ASC LIMIT 5\n#SQL: SELECT schools.City FROM schools JOIN frpm ON schools.CDSCode = frpm.CDSCode ORDER BY frpm.`Enrollment (K-12)` ASC LIMIT 5\n```"
    ],
    "1383": [
        "```\n#reason: The question wants to display the \"name of students\" from \"Georgetown, South Carolina,\" so the SQL SELECT will retrieve the first and last names of students who live in that specific city and state.\n#columns: member.first_name, member.last_name\n#values: 'Georgetown' refer to zip_code.city = 'Georgetown', 'South Carolina' refer to zip_code.state = 'South Carolina'\n#SELECT: SELECT member.first_name, member.last_name \n#SQL-like: Show member.first_name, member.last_name, WHERE zip_code.city = 'Georgetown' AND zip_code.state = 'South Carolina'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Georgetown' AND T2.state = 'South Carolina'\n```"
    ],
    "377": [
        "```\n#reason: The question wants to count how many cards have an original type of \"Summon - Angel\" and a subtype other than \"Angel\", so the SQL SELECT will count the cards that meet these conditions.\n#columns: cards.originalType, cards.subtypes\n#values: original type is 'Summon - Angel' refer to cards.originalType = 'Summon - Angel', subtype other than 'Angel' refer to cards.subtypes <> 'Angel'\n#SELECT: How many cards refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE cards.originalType = 'Summon - Angel' AND cards.subtypes <> 'Angel'\n#SQL: SELECT COUNT(*) FROM cards WHERE cards.originalType = 'Summon - Angel' AND cards.subtypes <> 'Angel'\n```"
    ],
    "1253": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the diagnosis of the patient with the highest Ig A within the normal range, so the SQL SELECT will retrieve the diagnosis where Ig A is the maximum value within the specified range.\n#columns: Patient.Diagnosis, Laboratory.IGA\n#values: highest Ig A within the normal range refers to Laboratory.IGA BETWEEN 80 AND 500\n#SELECT: diagnosis refers to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis WHERE Laboratory.IGA BETWEEN 80 AND 500 ORDER BY Laboratory.IGA DESC LIMIT 1\n#SQL: SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA BETWEEN 80 AND 500 ORDER BY T2.IGA DESC LIMIT 1\n```"
    ],
    "1068": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the average overall rating of players who are taller than 170 cm from the years 2010 to 2015, so the SQL SELECT will compute the average overall rating and apply the necessary filters.\n#columns: Player_Attributes.overall_rating, Player.height, Player.birthday\n#values: from 2010 to 2015 refers to \"strftime('%Y', Player.birthday) >= '2010' AND strftime('%Y', Player.birthday) <= '2015'\", higher than 170 refers to Player.height > 170\n#SELECT: average overall rating refers to SUM(Player_Attributes.overall_rating) / COUNT(Player.id)\n#SQL-like: Show SUM(Player_Attributes.overall_rating) / COUNT(Player.id), WHERE strftime('%Y', Player.birthday) >= '2010' AND strftime('%Y', Player.birthday) <= '2015' AND Player.height > 170\n#SQL: SELECT CAST(SUM(T1.overall_rating) AS REAL) / COUNT(T2.id) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE strftime('%Y', T2.birthday) >= '2010' AND strftime('%Y', T2.birthday) <= '2015' AND T2.height > 170\n```"
    ],
    "115": [
        "```\n#reason: The question wants to calculate the percentage of male clients in the branch located in south Bohemia with the biggest number of inhabitants, so the SQL SELECT will count the male clients and divide it by the total number of clients, multiplying by 100 to get the percentage.\n#columns: client.gender, client.client_id, district.A3, district.A4\n#values: 'south Bohemia' refers to district.A3 = 'south Bohemia', 'male clients' refers to client.gender = 'M'\n#SELECT: SELECT CAST(COUNT(CASE WHEN client.gender = 'M' THEN 1 END) AS REAL) * 100 / COUNT(client.client_id) \n#SQL-like: Show CAST(COUNT(CASE WHEN client.gender = 'M' THEN 1 END) AS REAL) * 100 / COUNT(client.client_id), WHERE district.A3 = 'south Bohemia'\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.gender = 'M' THEN 1 END) AS REAL) * 100 / COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A3 = 'south Bohemia' AND T2.A4 = (SELECT MAX(A4) FROM district WHERE A3 = 'south Bohemia')\n```"
    ],
    "607": [
        "```\n#reason: The question wants to count the number of positive comments, so the SQL SELECT COUNT(comments.Id) and COUNT is used to aggregate the results.\n#columns: comments.Id\n#values: positive comment refers to comments.Score > 60\n#SELECT: SELECT COUNT(comments.Id) \n#SQL-like: Show COUNT(comments.Id), WHERE comments.Score > 60\n#SQL: SELECT COUNT(Id) FROM comments WHERE Score > 60\n```"
    ],
    "459": [
        "```\n#reason: The question wants to compare the converted mana cost of two specific cards, \"Serra Angel\" and \"Shrine Keeper\", so the SQL SELECT will filter these cards and order by their converted mana cost to find the one with the higher cost.\n#columns: cards.name, cards.convertedManaCost\n#values: 'Serra Angel' refers to cards.name = 'Serra Angel', 'Shrine Keeper' refers to cards.name = 'Shrine Keeper'\n#SELECT: SELECT name, convertedManaCost refer to cards.name, cards.convertedManaCost\n#SQL-like: Show cards.name, cards.convertedManaCost WHERE cards.name IN ('Serra Angel', 'Shrine Keeper') ORDER BY cards.convertedManaCost DESC LIMIT 1\n#SQL: SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1\n```"
    ],
    "889": [
        "```\n#reason: The question wants to identify \"the last F1 season\" in which \"Brands Hatch hosted the British Grand Prix\", so the SQL SELECT will find the maximum year where the circuit is Brands Hatch and the race is British Grand Prix.\n#columns: seasons.year, circuits.name, races.name\n#values: 'Brands Hatch' refers to circuits.name = 'Brands Hatch', 'British Grand Prix' refers to races.name = 'British Grand Prix'\n#SELECT: SELECT max(seasons.year) refer to seasons.year\n#SQL-like: Show max(seasons.year), WHERE circuits.name = 'Brands Hatch' AND races.name = 'British Grand Prix'\n#SQL: SELECT max(seasons.year) FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId INNER JOIN seasons ON races.year = seasons.year WHERE circuits.name = 'Brands Hatch' AND races.name = 'British Grand Prix'\n```"
    ],
    "672": [
        "```\n#reason: The question wants to count the number of users located in the United Kingdom whose posts have a total favorite amount of 4 or more, so the SQL SELECT will count users based on the specified conditions.\n#columns: users.Id, posts.FavoriteCount\n#values: 'Location = United Kingdom' refer to users.Location = 'United Kingdom', 'favorite amount of 4 or more' refer to posts.FavoriteCount >= 4\n#SELECT: COUNT(DISTINCT users.Id) refer to users.Id\n#SQL-like: Show COUNT(DISTINCT users.Id), WHERE users.Location = 'United Kingdom' AND posts.FavoriteCount >= 4\n#SQL: SELECT COUNT(DISTINCT T1.Id) FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T1.Location = 'United Kingdom' AND T2.FavoriteCount >= 4\n```"
    ],
    "976": [
        "```\n#reason: The question requires displaying \"driver's ID\" for the top five drivers ordered by their \"fastest time during the first lap of the race\". \"fastest time\" refers to MIN(time), and the top five drivers indicates a limit of 5 results.\n#columns: lapTimes.driverId, lapTimes.time\n#values: lap number = 1 refers to lapTimes.lap = 1\n#SELECT: driver's ID corresponds to lapTimes.driverId\n#SQL-like: Show lapTimes.driverId, where lapTimes.lap = 1 ORDER BY lapTimes.time ASC LIMIT 5\n#SQL: SELECT driverId FROM lapTimes WHERE lap = 1 ORDER BY time ASC LIMIT 5\n```"
    ],
    "939": [
        "```\n#reason: The question wants to count the number of drivers from the UN, specifically those with British nationality who participated in the 2008 Australian Grand Prix, so the SQL SELECT will count the drivers based on the nationality and the race year.\n#columns: drivers.driverId, drivers.nationality, races.year\n#values: 'from the UN' refer to drivers.nationality = 'British', '2008' refer to races.year = 2008\n#SELECT: SELECT COUNT(drivers.driverId) refer to drivers.driverId\n#SQL-like: Show COUNT(drivers.driverId), WHERE drivers.nationality = 'British' AND races.year = 2008\n#SQL: SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T1.nationality = 'British' AND T3.year = 2008\n```"
    ],
    "681": [
        "```\n#reason: The question wants to display the users' display names whose posts had over 20000 views in 2011. \"had over 20000 views\" refers to ViewCount > 20000, and \"in 2011\" refers to YEAR(CreationDate) = 2011.\n#columns: users.DisplayName, posts.ViewCount, posts.CreaionDate\n#values: over 20000 views refer to posts.ViewCount > 20000 and in 2011 refer to strftime('%Y', posts.CreaionDate) = '2011'\n#SELECT: SELECT users.DisplayName \n#SQL-like: Show users.DisplayName, WHERE posts.ViewCount > 20000 AND strftime('%Y', posts.CreaionDate) = '2011'\n#SQL: SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.ViewCount > 20000 AND strftime('%Y', T2.CreaionDate) = '2011'\n```"
    ],
    "595": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find users who have only one post history per post and have at least 1000 views, so the SQL SELECT will count the post history entries per user and filter by views.\n#columns: postHistory.UserId, posts.Views\n#values: having at least 1000 views refers to posts.Views >= 1000\n#SELECT: SELECT postHistory.UserId\n#SQL-like: Show postHistory.UserId, WHERE posts.Views >= 1000, GROUP BY postHistory.UserId HAVING COUNT(postHistory.Id) = 1\n#SQL: SELECT postHistory.UserId FROM postHistory INNER JOIN posts ON postHistory.PostId = posts.Id WHERE posts.Views >= 1000 GROUP BY postHistory.UserId HAVING COUNT(postHistory.Id) = 1\n```"
    ],
    "774": [
        "```\n#reason: The question wants to identify the race for the superhero A-Bomb, so the SQL SELECT will retrieve the race information based on the superhero name as a filtering condition.\n#columns: race.race, superhero.superhero_name\n#values: superhero A-Bomb refer to superhero.superhero_name = 'A-Bomb'\n#SELECT: group refer to race.race\n#SQL-like: Show race.race WHERE superhero.superhero_name = 'A-Bomb'\n#SQL: SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'A-Bomb'\n```"
    ],
    "705": [
        "```\n#reason: The question wants to display the user's reputation and up vote number of the user that commented \"fine, you win :)\". So the SQL SELECT will include users.Reputation and users.UpVotes, and it will filter based on comments.Text = 'fine, you win :)'.\n#columns: users.Reputation, users.UpVotes\n#values: 'fine, you win :)' refer to comments.Text = 'fine, you win :)'\n#SELECT: SELECT users.Reputation, users.UpVotes\n#SQL-like: Show users.Reputation, users.UpVotes, WHERE comments.Text = 'fine, you win :)'\n#SQL: SELECT T1.Reputation, T1.UpVotes FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Text = 'fine, you win :)'\n```"
    ],
    "135": [
        "```\n#reason: The question wants to count the number of accounts with a negative balance after a credit card withdrawal, so the SQL SELECT will count the distinct account IDs where the balance is less than 0, filtered by the operation type and frequency.\n#columns: account.account_id, trans.balance, trans.operation, account.frequency\n#values: negative balance refers to trans.balance < 0; operation = 'VYBER KARTOU' refers to trans.operation = 'VYBER KARTOU'; frequency = 'POPLATEK MESICNE' refers to account.frequency = 'POPLATEK MESICNE'\n#SELECT: how many accounts refer to COUNT(DISTINCT account.account_id)\n#SQL-like: Show COUNT(DISTINCT account.account_id), WHERE trans.balance < 0 AND trans.operation = 'VYBER KARTOU' AND account.frequency = 'POPLATEK MESICNE'\n#SQL: SELECT COUNT(DISTINCT account.account_id) FROM account INNER JOIN trans ON account.account_id = trans.account_id WHERE trans.balance < 0 AND trans.operation = 'VYBER KARTOU' AND account.frequency = 'POPLATEK MESICNE'\n```"
    ],
    "1504": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the average total price of transactions in January, 2012, so the SQL SELECT involves calculating AVG(Price) where the Date is in January 2012.\n#columns: transactions_1k.Price\n#values: In January, 2012 refers to transactions_1k.Date LIKE '2012-01%'\n#SELECT: SELECT AVG(Price) refer to transactions_1k.Price\n#SQL-like: Show AVG(Price), WHERE Date LIKE '2012-01%'\n#SQL: SELECT AVG(Price) FROM transactions_1k WHERE Date LIKE '2012-01%'\n```"
    ],
    "523": [
        "```\n#reason: The question wants to calculate the annual average number of sets released between 1/1/2012 to 12/31/2015 and also determine the common language of the card. The SQL SELECT will compute the average of the set IDs and the most common language based on the specified date range.\n#columns: sets.id, foreign_data.language\n#values: releaseDate BETWEEN '2012-01-01' AND '2015-12-31' refers to sets.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\n#SELECT: annual average number of sets refers to CAST(COUNT(sets.id) AS REAL) / 4, common language of the card refers to MAX(COUNT(foreign_data.language))\n#SQL-like: Show CAST(COUNT(sets.id) AS REAL) / 4, MAX(COUNT(foreign_data.language)), WHERE sets.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\n#SQL: SELECT CAST(COUNT(T1.id) AS REAL) / 4, (SELECT foreign_data.language FROM foreign_data INNER JOIN cards ON foreign_data.uuid = cards.uuid WHERE cards.id IN (SELECT id FROM sets WHERE releaseDate BETWEEN '2012-01-01' AND '2015-12-31') GROUP BY foreign_data.language ORDER BY COUNT(foreign_data.language) DESC LIMIT 1) FROM sets AS T1 WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31'\n```"
    ],
    "1189": [
        "```\n#reason: The question wants to determine the number of patients who meet two specific criteria: a degree of thrombosis level 2 and an ANA pattern of 'S', while having a level of anti-Cardiolip in antibody (IgM) that is 20% higher than the average. So the SQL SELECT will count the patients from the given filters and conditions.\n#columns: Patient.ID, Examination.Thrombosis, Examination.`ANA Pattern`, Examination.`aCL IgM`\n#values: 'thrombosis level 2' refer to Examination.Thrombosis = 2, 'ANA pattern of only S' refer to Examination.`ANA Pattern` = 'S', 'level of anti-Cardiolip in antibody (IgM) 20% higher than average' refer to Examination.`aCL IgM` > (SELECT AVG(`aCL IgM`) FROM Examination) * 1.2\n#SELECT: number of patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID) WHERE Examination.Thrombosis = 2 AND Examination.`ANA Pattern` = 'S' AND Examination.`aCL IgM` > (SELECT AVG(`aCL IgM`) FROM Examination) * 1.2\n#SQL: SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2 AND T2.`ANA Pattern` = 'S' AND T2.`aCL IgM` > (SELECT AVG(`aCL IgM`) FROM Examination) * 1.2\n```"
    ],
    "15": [
        "```\n#reason: The question wants to identify the \"active district\" with the \"highest average score in Reading\", so the SQL SELECT will focus on the district's name and the average reading score, ordering by the average reading score in descending order and limiting the results to 1.\n#columns: schools.District, satscores.AvgScrRead\n#values: active district refers to schools.StatusType = 'Active'\n#SELECT: SELECT schools.District, satscores.AvgScrRead\n#SQL-like: Show schools.District, satscores.AvgScrRead, WHERE schools.StatusType = 'Active' ORDER BY satscores.AvgScrRead DESC LIMIT 1\n#SQL: SELECT T1.District, T2.AvgScrRead FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.StatusType = 'Active' ORDER BY T2.AvgScrRead DESC LIMIT 1\n```"
    ],
    "169": [
        "```\n#reason: The question wants to calculate the growth rate of the total amount of loans for male clients between 1996 and 1997, so the SQL SELECT will sum the loan amounts for each year and compute the growth rate.\n#columns: loan.amount, client.gender\n#values: male refers to client.gender = 'M', 1996 refers to strftime('%Y', loan.date) = '1996', 1997 refers to strftime('%Y', loan.date) = '1997'\n#SELECT: growth rate of the total amount of loans refers to (SUM(CASE WHEN strftime('%Y', loan.date) = '1997' THEN loan.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END)) * 100.0 / SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END)\n#SQL-like: Show (SUM(CASE WHEN strftime('%Y', loan.date) = '1997' THEN loan.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END)) * 100.0 / SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END), WHERE client.gender = 'M'\n#SQL: SELECT (SUM(CASE WHEN strftime('%Y', loan.date) = '1997' THEN loan.amount ELSE 0 END) - SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END)) * 100.0 / SUM(CASE WHEN strftime('%Y', loan.date) = '1996' THEN loan.amount ELSE 0 END) FROM loan INNER JOIN disp ON loan.account_id = disp.account_id INNER JOIN client ON disp.client_id = client.client_id WHERE client.gender = 'M'\n```"
    ],
    "101": [
        "```\n#reason: The question requires listing the accounts with the earliest trading date in 1995. This involves filtering accounts by the year 1995 and finding the minimum date.\n#columns: account.account_id, account.date\n#values: the earliest trading date in 1995 refers to \"account.date >= '1995-01-01' AND account.date < '1996-01-01'\"\n#SELECT: accounts refer to account.account_id\n#SQL-like: Show account.account_id, WHERE account.date >= '1995-01-01' AND account.date < '1996-01-01' ORDER BY account.date ASC LIMIT 1\n#SQL: SELECT account_id FROM account WHERE date >= '1995-01-01' AND date < '1996-01-01' AND date = (SELECT MIN(date) FROM account WHERE date >= '1995-01-01' AND date < '1996-01-01')\n```"
    ],
    "49": [
        "```\n#reason: The question wants to identify the counties with the most closed schools, necessitating a count of closed schools grouped by county. Furthermore, it requires displaying the names of each closed school along with their closure dates. \n#columns: schools.County, schools.School, schools.ClosedDate\n#values: 'closed schools' refers to schools.StatusType = 'Closed'\n#SELECT: SELECT district and closure date refers to schools.County, schools.School, schools.ClosedDate\n#SQL-like: Show schools.County, schools.School, schools.ClosedDate WHERE schools.StatusType = 'Closed' GROUP BY schools.County ORDER BY COUNT(schools.School) DESC\n#SQL: SELECT schools.County, schools.School, schools.ClosedDate FROM schools WHERE schools.StatusType = 'Closed' GROUP BY schools.County ORDER BY COUNT(schools.School) DESC\n```"
    ],
    "100": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to find the count of female customers born before 1950 who are located in Sokolov, so the SQL SELECT will aggregate the count of clients satisfying these conditions.)\n#columns: client.gender, client.birth_date, district.A2, client.client_id\n#values: female refers to client.gender = 'F', born before 1950 refers to client.birth_date < '1950-01-01', stayed in Sokolov refers to district.A2 = 'Sokolov'\n#SELECT: SELECT COUNT(client.client_id) refer to client.client_id\n#SQL-like: Show COUNT(client.client_id), WHERE client.gender = 'F' AND client.birth_date < '1950-01-01' AND district.A2 = 'Sokolov'\n#SQL: SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T1.birth_date < '1950-01-01' AND T2.A2 = 'Sokolov'\n```"
    ],
    "1197": [
        "```\n#reason: The question wants to find the \"Description\" of the first documented medical information and the \"Diagnosis\" of the patient with the specific ID. Therefore, the SQL SELECT will include both these columns based on the filtering condition of patient ID.\n#columns: Patient.Description, Patient.Diagnosis\n#values: patient number 48473 refers to Patient.ID = 48473\n#SELECT: SELECT Patient.Description, Patient.Diagnosis\n#SQL-like: Show Patient.Description, Patient.Diagnosis WHERE Patient.ID = 48473\n#SQL: SELECT Patient.Description, Patient.Diagnosis FROM Patient WHERE Patient.ID = 48473\n```"
    ],
    "496": [
        "```\n#reason: The question wants to display the \"number of cards\" in the set of \"Rinascita di Alara\", so the SQL SELECT will retrieve the baseSetSize from the sets table where the translation matches 'Rinascita di Alara'.\n#columns: sets.baseSetSize\n#values: 'set of \"Rinascita di Alara\"' refer to set_translations.translation = 'Rinascita di Alara'\n#SELECT: SELECT baseSetSize refer to sets.baseSetSize\n#SQL-like: Show sets.baseSetSize, WHERE set_translations.translation = 'Rinascita di Alara'\n#SQL: SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.translation = 'Rinascita di Alara'\n```"
    ],
    "205": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to identify the molecules containing carbon, so the SQL SELECT will retrieve the unique molecule IDs associated with the atom that is carbon.)\n#columns: atom.molecule_id\n#values: carbon refers to atom.element = 'c'\n#SELECT: SELECT DISTINCT atom.molecule_id refer to atom.molecule_id\n#SQL-like: Show DISTINCT(atom.molecule_id), WHERE atom.element = 'c'\n#SQL: SELECT DISTINCT atom.molecule_id FROM atom WHERE atom.element = 'c'\n```"
    ],
    "1120": [
        "```\n#reason: The question wants to sum up the away team goals scored by both Daan Smith and Filipe Ferreira, so the SQL SELECT will aggregate the away team goals where the player names match the specified names.\n#columns: Match.away_team_goal\n#values: 'Daan Smith' refer to Player.player_name = 'Daan Smith', 'Filipe Ferreira' refer to Player.player_name = 'Filipe Ferreira'\n#SELECT: SELECT SUM(Match.away_team_goal) refer to Match.away_team_goal\n#SQL-like: Show SUM(Match.away_team_goal) WHERE Match.away_player_1 = Player.player_api_id OR Match.away_player_2 = Player.player_api_id OR Match.away_player_3 = Player.player_api_id OR Match.away_player_4 = Player.player_api_id OR Match.away_player_5 = Player.player_api_id OR Match.away_player_6 = Player.player_api_id OR Match.away_player_7 = Player.player_api_id OR Match.away_player_8 = Player.player_api_id OR Match.away_player_9 = Player.player_api_id OR Match.away_player_10 = Player.player_api_id OR Match.away_player_11 = Player.player_api_id\n#SQL: SELECT SUM(Match.away_team_goal) FROM Match INNER JOIN Player ON Match.away_player_1 = Player.player_api_id OR Match.away_player_2 = Player.player_api_id OR Match.away_player_3 = Player.player_api_id OR Match.away_player_4 = Player.player_api_id OR Match.away_player_5 = Player.player_api_id OR Match.away_player_6 = Player.player_api_id OR Match.away_player_7 = Player.player_api_id OR Match.away_player_8 = Player.player_api_id OR Match.away_player_9 = Player.player_api_id OR Match.away_player_10 = Player.player_api_id OR Match.away_player_11 = Player.player_api_id WHERE Player.player_name IN ('Daan Smith', 'Filipe Ferreira')\n```"
    ],
    "346": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all the card id and artist with unknown power which are legal for commander play format, so the SQL SELECT will include the card id and artist while applying the necessary filters for power and legality.\n#columns: cards.id, cards.artist\n#values: unknown power refers to cards.power = '*' or cards.power IS NULL; commander play format refers to legalities.format = 'commander'; legal for commander play format refers to legalities.format = 'commander' AND legalities.status = 'Legal'\n#SELECT: SELECT cards.id, cards.artist\n#SQL-like: Show cards.id, cards.artist WHERE (cards.power = '*' OR cards.power IS NULL) AND legalities.format = 'commander' AND legalities.status = 'Legal'\n#SQL: SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE (T1.power = '*' OR T1.power IS NULL) AND T2.format = 'commander' AND T2.status = 'Legal'\n```"
    ],
    "72": [
        "```\n#reason: The question wants to know how many students from the ages of 5 to 17 are enrolled at the State Special School in Fremont for the 2014-2015 academic year, so the SQL SELECT COUNT(Enrollment (Ages 5-17)) and WHERE conditions are applied.\n#columns: frpm.`Enrollment (Ages 5-17)`, frpm.`Educational Option Type`, schools.City, frpm.`Academic Year`\n#values: State Special School refers to frpm.`Educational Option Type` = 'State Special School', Fremont refers to schools.City = 'Fremont', 2014-2015 refers to frpm.`Academic Year` = '2014-2015'\n#SELECT: SELECT COUNT(frpm.`Enrollment (Ages 5-17)`) refer to frpm.`Enrollment (Ages 5-17)`\n#SQL-like: Show COUNT(frpm.`Enrollment (Ages 5-17)`), WHERE frpm.`Educational Option Type` = 'State Special School' AND schools.City = 'Fremont' AND frpm.`Academic Year` = '2014-2015'\n#SQL: SELECT COUNT(frpm.`Enrollment (Ages 5-17)`) FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.`Educational Option Type` = 'State Special School' AND schools.City = 'Fremont' AND frpm.`Academic Year` = '2014-2015'\n```"
    ],
    "399": [
        "```\n#reason: The question wants to list all types of cards available in arena, so the SQL SELECT will retrieve the subtypes and supertypes of cards where availability is 'arena'.\n#columns: cards.subtypes, cards.supertypes\n#values: available in arena refers to cards.availability = 'arena'\n#SELECT: SELECT cards.subtypes, cards.supertypes\n#SQL-like: Show cards.subtypes, cards.supertypes WHERE cards.availability = 'arena'\n#SQL: SELECT cards.subtypes, cards.supertypes FROM cards WHERE cards.availability = 'arena'\n```"
    ],
    "569": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to know the number of votes for the post about data visualization, so the SQL SELECT COUNT(votes.Id) and filters for the title that contains 'data visualization'.\n#columns: votes.Id, posts.Title\n#values: title contains 'data visualization' refer to posts.Title LIKE '%data visualization%'\n#SELECT: number of votes refer to COUNT(votes.Id)\n#SQL-like: Show COUNT(votes.Id) WHERE posts.Title LIKE '%data visualization%'\n#SQL: SELECT COUNT(T1.Id) FROM votes AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title LIKE '%data visualization%'\n```"
    ],
    "1262": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of distinct patients with a normal level of complement 3 and a specific ANA pattern, so the SQL SELECT will count distinct Patient.ID and filter based on the conditions for C3 and ANA Pattern.\n#columns: DISTINCT Patient.ID, Laboratory.C3, Examination.`ANA Pattern`\n#values: normal level of complement 3 refers to Laboratory.C3 > 35, have a P pattern observed in the sheet of ANA examination refers to Examination.`ANA Pattern` = 'P'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to DISTINCT Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.C3 > 35 AND Examination.`ANA Pattern` = 'P'\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID INNER JOIN Examination AS E ON P.ID = E.ID WHERE L.C3 > 35 AND E.`ANA Pattern` = 'P'\n```"
    ],
    "692": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the duration it took for the user with the display name 'Zolomon' to obtain the badge, calculated as the difference between the date the badge was awarded and the date the user's account was created. Therefore, the SQL SELECT will include the subtraction of these dates, and the necessary filtering condition is on the user's display name.\n#columns: stats_badges.Date, users.CreationDate\n#values: DisplayName = 'Zolomon' refers to users.DisplayName = 'Zolomon'\n#SELECT: SUBTRACT(stats_badges.Date, users.CreationDate) refer to stats_badges.Date and users.CreationDate\n#SQL-like: Show SUBTRACT(stats_badges.Date, users.CreationDate) WHERE users.DisplayName = 'Zolomon'\n#SQL: SELECT (JULIANDAY(T1.Date) - JULIANDAY(T2.CreationDate)) AS Duration FROM stats_badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Zolomon'\n```"
    ],
    "597": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the count of users from India who have the teacher badges, so the SQL SELECT will count the users filtered by their location and badge name.\n#columns: users.Location, badges.Name\n#values: 'India' refers to users.Location = 'India', 'Teacher' refers to badges.Name = 'Teacher'\n#SELECT: How many users refer to COUNT(*) \n#SQL-like: Show COUNT(*), WHERE users.Location = 'India' AND badges.Name = 'Teacher'\n#SQL: SELECT COUNT(*) FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T1.Location = 'India' AND T2.Name = 'Teacher'\n```"
    ],
    "35": [
        "```\n#reason: The question wants to find the administrator's email address of the chartered school with the fewest students enrolled in grades 1 through 12, so the SQL SELECT will focus on the `AdmEmail1` column from the `schools` table, filtering for charter schools and ordering by the `Enrollment (K-12)` column to find the minimum.\n#columns: schools.AdmEmail1, frpm.`Enrollment (K-12)`\n#values: chartered school refers to frpm.`Charter School (Y/N)` = 1, fewest students enrolled in grades 1 through 12 refers to frpm.`Enrollment (K-12)` = (SELECT MIN(frpm.`Enrollment (K-12)`) FROM frpm WHERE frpm.`Charter School (Y/N)` = 1)\n#SELECT: SELECT administrator's email address refer to schools.AdmEmail1\n#SQL-like: Show schools.AdmEmail1 WHERE frpm.`Charter School (Y/N)` = 1 ORDER BY frpm.`Enrollment (K-12)` LIMIT 1\n#SQL: SELECT T1.AdmEmail1 FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`Charter School (Y/N)` = 1 ORDER BY T2.`Enrollment (K-12)` LIMIT 1\n```"
    ],
    "86": [
        "```\n#reason: The question wants to find the \"administrator's last name\" along with the \"district\", \"county\", and \"name of the school\" for a specific \"Charter number\". The filtering condition is \"Charter number 40\".\n#columns: schools.AdmLName1, schools.District, schools.County, schools.School\n#values: Charter number 40 refers to schools.CharterNum = '40'\n#SELECT: SELECT administrator's last name, district, county, name of the school refer to schools.AdmLName1, schools.District, schools.County, schools.School\n#SQL-like: Show schools.AdmLName1, schools.District, schools.County, schools.School WHERE schools.CharterNum = '40'\n#SQL: SELECT T1.AdmLName1, T1.District, T1.County, T1.School FROM schools AS T1 WHERE T1.CharterNum = '40'\n```"
    ],
    "238": [
        "```\n#reason: The question want to count the molecules that have a triple bond type, so the SQL SELECT will count distinct molecules based on the bond type condition.\n#columns: COUNT(DISTINCT bond.molecule_id)\n#values: bond_type is a triple bond refer to bond.bond_type = '#'\n#SELECT: How many molecules refer to COUNT(DISTINCT bond.molecule_id)\n#SQL-like: Show COUNT(DISTINCT bond.molecule_id), WHERE bond.bond_type = '#'\n#SQL: SELECT COUNT(DISTINCT bond.molecule_id) FROM bond WHERE bond.bond_type = '#'\n```"
    ],
    "116": [
        "```\n#reason: The question wants to calculate the increase rate of the account balance for a specific client whose loan was approved first on a given date. The SQL SELECT will retrieve the balance for the specified dates and calculate the increase rate based on the formula provided.\n#columns: trans.balance, trans.date, loan.date, loan.account_id, account.account_id\n#values: 'loan approved first in 1993/7/5' refers to loan.date = '1993-07-05', 'from 1993/3/22 to 1998/12/27' refers to trans.date = '1993-03-22' and trans.date = '1998-12-27'\n#SELECT: increase rate of account balance refers to (trans.balance where trans.date = '1998-12-27' - trans.balance where trans.date = '1993-03-22') / trans.balance where trans.date = '1993-03-22' * 100\n#SQL-like: Show (CAST((SELECT balance FROM trans WHERE trans.date = '1998-12-27' AND trans.account_id = (SELECT loan.account_id FROM loan WHERE loan.date = '1993-07-05' LIMIT 1) ) - (SELECT balance FROM trans WHERE trans.date = '1993-03-22' AND trans.account_id = (SELECT loan.account_id FROM loan WHERE loan.date = '1993-07-05' LIMIT 1) )) AS REAL) / (SELECT balance FROM trans WHERE trans.date = '1993-03-22' AND trans.account_id = (SELECT loan.account_id FROM loan WHERE loan.date = '1993-07-05' LIMIT 1)) * 100\n#SQL: SELECT CAST((SELECT T1.balance FROM trans AS T1 WHERE T1.date = '1998-12-27' AND T1.account_id = (SELECT T2.account_id FROM loan AS T2 WHERE T2.date = '1993-07-05' LIMIT 1)) - (SELECT T1.balance FROM trans AS T1 WHERE T1.date = '1993-03-22' AND T1.account_id = (SELECT T2.account_id FROM loan AS T2 WHERE T2.date = '1993-07-05' LIMIT 1)) AS REAL) / (SELECT T1.balance FROM trans AS T1 WHERE T1.date = '1993-03-22' AND T1.account_id = (SELECT T2.account_id FROM loan AS T2 WHERE T2.date = '1993-07-05' LIMIT 1)) * 100\n```"
    ],
    "674": [
        "```\n#reason: The question wants to identify \"who has the highest reputation\" and display the \"display name\". The highest reputation is defined as MAX(Reputation).\n#columns: users.DisplayName, users.Reputation\n#values: highest reputation refers to MAX(Reputation)\n#SELECT: FULL NAME refers to users.DisplayName\n#SQL-like: Show users.DisplayName, ORDER BY users.Reputation DESC LIMIT 1\n#SQL: SELECT DisplayName FROM users ORDER BY Reputation DESC LIMIT 1\n```"
    ],
    "1108": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to find the build up play speed class for the team \"Willem II\" on the specified date, so the SQL SELECT will focus on extracting the corresponding class from the Team_Attributes table given the filtering conditions.)\n#columns: Team_Attributes.buildUpPlaySpeedClass, Team.team_long_name, Team_Attributes.date\n#values: 'Willem II' refer to Team.team_long_name = 'Willem II', '2011-02-22' refer to Team_Attributes.date = '2011-02-22'\n#SELECT: SELECT Team_Attributes.buildUpPlaySpeedClass refer to Team_Attributes.buildUpPlaySpeedClass \n#SQL-like: Show Team_Attributes.buildUpPlaySpeedClass, WHERE Team.team_long_name = 'Willem II' AND Team_Attributes.date = '2011-02-22'\n#SQL: SELECT T1.buildUpPlaySpeedClass FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.team_long_name = 'Willem II' AND T1.date = '2011-02-22'\n```"
    ],
    "711": [
        "```\n#reason: The question wants to find the total number of users who have commented on products with a score of 0 and are 40 years old, so the SQL SELECT will count the distinct users based on the filtering conditions.\n#columns: users.Id, comments.Score, users.Age\n#values: 'comments with 0 score' refer to comments.Score = 0, 'ages 40 years old' refer to users.Age = 40\n#SELECT: SELECT COUNT(DISTINCT users.Id) refer to users.Id\n#SQL-like: Show COUNT(DISTINCT users.Id), WHERE comments.Score = 0 AND users.Age = 40\n#SQL: SELECT COUNT(DISTINCT T1.Id) FROM users AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.UserId WHERE T2.Score = 0 AND T1.Age = 40\n```"
    ],
    "656": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to describe the display name of the parent ID for the child post with the highest score. Specifically, the highest score refers to MAX(Score), and posts with a non-null parent ID are considered child posts.\n#columns: posts.OwnerDisplayName, posts.ParentId\n#values: highest score refer to posts.Score = (SELECT MAX(Score) FROM posts), child post condition refer to posts.ParentId IS NOT NULL\n#SELECT: SELECT posts.OwnerDisplayName, posts.ParentId\n#SQL-like: Show posts.OwnerDisplayName, posts.ParentId WHERE posts.ParentId IS NOT NULL AND posts.Score = (SELECT MAX(Score) FROM posts)\n#SQL: SELECT T1.OwnerDisplayName, T1.ParentId FROM posts AS T1 WHERE T1.ParentId IS NOT NULL AND T1.Score = (SELECT MAX(Score) FROM posts)\n```"
    ],
    "1169": [
        "```\n#reason: The question wants to calculate the ratio of male to female patients among those with abnormal uric acid counts, so the SQL SELECT will count the number of male patients with UA <= 8.0 and female patients with UA <= 6.5.\n#columns: Patient.SEX, Laboratory.UA\n#values: abnormal uric acid refers to UA <= 8.0 where SEX = 'M' and UA <= 6.5 where SEX = 'F' refer to Laboratory.UA <= 8.0 AND Patient.SEX = 'M', Laboratory.UA <= 6.5 AND Patient.SEX = 'F'\n#SELECT: ratio of male to female patients among all those with abnormal uric acid counts refer to DIVIDE(SUM(UA <= 8.0 AND SEX = 'M'), SUM(UA <= 6.5 AND SEX = 'F'))\n#SQL-like: Show DIVIDE(SUM(UA <= 8.0 AND SEX = 'M'), SUM(UA <= 6.5 AND SEX = 'F'))\n#SQL: SELECT CAST(SUM(CASE WHEN Laboratory.UA <= 8.0 AND Patient.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Laboratory.UA <= 6.5 AND Patient.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID\n```"
    ],
    "321": [
        "```\n#reason: The question wants to find the molecule that contains both atom ids \"TR000_2\" and \"TR000_4\", so the SQL SELECT will retrieve the molecule.molecule_id where both atoms are part of the same molecule.\n#columns: molecule.molecule_id\n#values: atom id 'TR000_2' refers to atom.molecule_id = molecule.molecule_id AND atom id 2 'TR000_4' refers to atom.molecule_id = molecule.molecule_id\n#SELECT: SELECT molecule_id refer to molecule.molecule_id\n#SQL-like: Show molecule.molecule_id WHERE atom.atom_id = 'TR000_2' AND atom.atom_id = 'TR000_4'\n#SQL: SELECT DISTINCT T1.molecule_id FROM atom AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR000_2' AND T2.atom_id = 'TR000_4'\n```"
    ],
    "384": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the uuid for legacy cards and the foreign language of these cards. This indicates we need to filter by the format being 'legacy' and join the relevant tables to access the foreign language.\n#columns: cards.uuid, foreign_data.language\n#values: legacy card refers to legalities.format = 'legacy'\n#SELECT: uuid refers to cards.uuid, foreign language refers to foreign_data.language\n#SQL-like: Show cards.uuid, foreign_data.language WHERE legalities.format = 'legacy'\n#SQL: SELECT T1.uuid, T2.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'legacy'\n```"
    ],
    "878": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the driver with the best lap time in a specific race, so the SQL SELECT will retrieve the driver's full name and is filtered based on the race number and lap time.\n#columns: drivers.forename, drivers.surname, lapTimes.time, lapTimes.raceId\n#values: race No. 348 refers to lapTimes.raceId = 348; the best lap time refers to MIN(lapTimes.time)\n#SELECT: SELECT the driver that got the best lap time in the race refers to drivers.forename, drivers.surname\n#SQL-like: Show drivers.forename, drivers.surname, WHERE lapTimes.raceId = 348, ORDER BY lapTimes.time ASC LIMIT 1\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 348 ORDER BY T2.time ASC LIMIT 1\n```"
    ],
    "1412": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the kind of expenses incurred by members who have X-Large in size of tee shirt, so the SQL SELECT will focus on the expense_description and filter by t_shirt_size.\n#columns: expense.expense_description, member.t_shirt_size\n#values: t_shirt_size = 'X-Large' refer to member.t_shirt_size = 'X-Large'\n#SELECT: SELECT expense_description refer to expense.expense_description\n#SQL-like: Show expense.expense_description WHERE member.t_shirt_size = 'X-Large'\n#SQL: SELECT expense.expense_description FROM expense INNER JOIN member ON expense.link_to_member = member.member_id WHERE member.t_shirt_size = 'X-Large'\n```"
    ],
    "1485": [
        "```\n#reason: The question wants to determine the difference in consumption between customer 7 and customer 5 for April 2013, so the SQL SELECT will calculate the consumption for both customers and subtract the two values.\n#columns: yearmonth.Consumption, yearmonth.CustomerID\n#values: April 2013 refers to yearmonth.Date = '201304' AND yearmonth.CustomerID IN (7, 5)\n#SELECT: SELECT (SUM(CASE WHEN yearmonth.CustomerID = 7 THEN Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.CustomerID = 5 THEN Consumption ELSE 0 END)) refer to yearmonth.Consumption\n#SQL-like: Show (SUM(CASE WHEN yearmonth.CustomerID = 7 THEN Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.CustomerID = 5 THEN Consumption ELSE 0 END)), WHERE yearmonth.Date = '201304'\n#SQL: SELECT SUM(CASE WHEN yearmonth.CustomerID = 7 THEN Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.CustomerID = 5 THEN Consumption ELSE 0 END) FROM yearmonth WHERE yearmonth.Date = '201304'\n```"
    ],
    "1451": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires finding the member who incurred expenses in more than one event and paid the most amount. \"Paid the most amount\" refers to MAX(cost) where the member has expenses in more than one event.\n#columns: member.member_id, expense.cost, expense.link_to_member\n#values: 'incurred expenses in more than one event' refer to COUNT(expense.link_to_budget) > 1\n#SELECT: SELECT member.member_id, MAX(expense.cost) refer to member.member_id, expense.cost\n#SQL-like: Show member.member_id, MAX(expense.cost) WHERE COUNT(expense.link_to_budget) > 1 GROUP BY member.member_id ORDER BY MAX(expense.cost) DESC LIMIT 1\n#SQL: SELECT T1.link_to_member FROM expense AS T1 INNER JOIN ( SELECT link_to_member, COUNT(link_to_budget) AS event_count FROM expense GROUP BY link_to_member HAVING event_count > 1 ) AS T2 ON T1.link_to_member = T2.link_to_member ORDER BY T1.cost DESC LIMIT 1\n```"
    ],
    "1393": [
        "```\n#reason: The question wants to display the full name and email address of the Student Club's Secretary, so the SQL SELECT will pull the first and last name from the member table and also the email column from the same table with a filtering condition on the position.\n#columns: member.first_name, member.last_name, member.email\n#values: 'Secretary' refer to member.position = 'Secretary'\n#SELECT: SELECT member.first_name, member.last_name, member.email refer to member.first_name, member.last_name, member.email\n#SQL-like: Show member.first_name, member.last_name, member.email WHERE member.position = 'Secretary'\n#SQL: SELECT first_name, last_name, email FROM member WHERE position = 'Secretary'\n```"
    ],
    "29": [
        "```\n#reason: The question wants to find out when the school with the largest enrollment opened, so the SQL SELECT will retrieve the OpenDate of the school with the maximum enrollment for K-12.\n#columns: schools.OpenDate, frpm.`Enrollment (K-12)`\n#values: K-12 refers to schools.GSoffered = 'K-12'\n#SELECT: SELECT OpenDate refer to schools.OpenDate\n#SQL-like: Show OpenDate WHERE schools.GSoffered = 'K-12' ORDER BY frpm.`Enrollment (K-12)` DESC LIMIT 1\n#SQL: SELECT schools.OpenDate FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.GSoffered = 'K-12' ORDER BY frpm.`Enrollment (K-12)` DESC LIMIT 1\n```"
    ],
    "348": [
        "```\n#reason: The question wants to describe the information about rulings for a card named 'Sublime Epiphany' with number 74s, so the SQL SELECT will fetch the text from the rulings table with the appropriate filters on the cards table.\n#columns: rulings.text\n#values: 'Sublime Epiphany' refer to cards.name = 'Sublime Epiphany', '74s' refer to cards.number = '74s'\n#SELECT: SELECT rulings.text refer to rulings.text.\n#SQL-like: Show rulings.text WHERE cards.name = 'Sublime Epiphany' AND cards.number = '74s'\n#SQL: SELECT T2.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Sublime Epiphany' AND T2.number = '74s'\n```"
    ],
    "94": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list out the account numbers of female clients who are the oldest and have the lowest average salary, and calculate the gap between this lowest average salary with the highest average salary. To achieve this, I will filter for female clients, determine the lowest average salary for the oldest clients, and then calculate the gap between the highest and lowest average salary.\n#columns: account.account_id, client.gender, district.A11\n#values: female refers to client.gender = 'F', oldest clients refer to client.birth_date = (SELECT MAX(birth_date) FROM client WHERE gender = 'F'), lowest average salary refers to district.A11 = (SELECT MIN(A11) FROM district WHERE district.district_id = client.district_id GROUP BY client.district_id ORDER BY AVG(A11) ASC LIMIT 1)\n#SELECT: account numbers refer to account.account_id, gap refers to (SELECT MAX(A11) - MIN(A11) FROM district WHERE district.district_id = client.district_id)\n#SQL-like: Show account.account_id, (SELECT MAX(A11) - MIN(A11) FROM district WHERE district.district_id = client.district_id) WHERE client.gender = 'F' AND A11 = (SELECT MIN(A11) FROM district WHERE district.district_id = client.district_id GROUP BY client.district_id) \n#SQL: SELECT a.account_id, (SELECT MAX(A11) - MIN(A11) FROM district AS d WHERE d.district_id = c.district_id) FROM account AS a INNER JOIN disp AS d ON a.account_id = d.account_id INNER JOIN client AS c ON d.client_id = c.client_id WHERE c.gender = 'F' AND c.birth_date = (SELECT MAX(birth_date) FROM client WHERE gender = 'F') AND (SELECT AVG(A11) FROM district AS d WHERE d.district_id = c.district_id GROUP BY c.district_id) = (SELECT MIN(AVG(A11)) FROM district GROUP BY district_id)\n```"
    ],
    "756": [
        "```\n#reason: The question wants to determine the total number of bad superheroes, so the SQL SELECT COUNT(superhero.id) and COUNT is used to count the number of superheroes with a specific alignment.\n#columns: superhero.id\n#values: bad superheroes refer to alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad')\n#SELECT: SELECT COUNT(superhero.id) refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad')\n#SQL: SELECT COUNT(superhero.id) FROM superhero WHERE superhero.alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad')\n```"
    ],
    "673": [
        "```\n#reason: The question wants to find the average number of posts voted by the oldest users, so the SQL SELECT will calculate the average of PostId from the votes table, filtering for users with the maximum age.\n#columns: votes.PostId, users.Age\n#values: oldest users refer to MAX(Age) from users\n#SELECT: SELECT AVG(votes.PostId) FROM votes INNER JOIN users ON votes.UserId = users.Id WHERE users.Age = (SELECT MAX(Age) FROM users)\n#SQL-like: Show AVG(PostId), WHERE Age = (SELECT MAX(Age) FROM users)\n#SQL: SELECT AVG(votes.PostId) FROM votes INNER JOIN users ON votes.UserId = users.Id WHERE users.Age = (SELECT MAX(Age) FROM users)\n```"
    ],
    "507": [
        "```\n#reason: The question wants to calculate the percentage of cards with Brazil Portuguese translation that are only available online, so the SQL SELECT will count the cards that are online only and divide it by the total number of cards with Brazil Portuguese translation.\n#columns: cards.isOnlineOnly, foreign_data.language\n#values: 'Brazil Portuguese translation' refer to foreign_data.language = 'Portuguese (Brazil)', 'only available online' refer to cards.isOnlineOnly = 1\n#SELECT: percentage of online only Brazil Portuguese in all Brazil Portuguese cards refer to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)')) * 100\n#SQL-like: Show DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)')) * 100 WHERE foreign_data.language = 'Portuguese (Brazil)'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Portuguese (Brazil)'\n```"
    ],
    "114": [
        "```\n#reason: The question wants to find the account ID of the first client who opened an account in Prague, so the SQL SELECT will retrieve the account ID from the account table, filtering by the district associated with Prague and ordering by the account creation date to get the first record.\n#columns: account.account_id, account.date, client.client_id, client.district_id, district.A3\n#values: 'Prague' refers to district.A3 = 'Prague'\n#SELECT: SELECT account.account_id refer to account.account_id\n#SQL-like: Show account.account_id WHERE district.A3 = 'Prague' ORDER BY account.date LIMIT 1\n#SQL: SELECT T1.account_id FROM account AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T3.A3 = 'Prague' ORDER BY T1.date LIMIT 1\n```"
    ],
    "1343": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the remaining amount of the biggest budget for the \"Food\" category, so the SQL SELECT will select the remaining budget where the amount is the maximum for that category.\n#columns: budget.remaining, budget.amount\n#values: biggest budget for 'Food' refers to budget.amount = (SELECT MAX(budget.amount) FROM budget WHERE budget.category = 'Food')\n#SELECT: SELECT budget.remaining refer to budget.remaining\n#SQL-like: Show budget.remaining WHERE budget.amount = (SELECT MAX(budget.amount) FROM budget WHERE budget.category = 'Food')\n#SQL: SELECT remaining FROM budget WHERE amount = (SELECT MAX(amount) FROM budget WHERE category = 'Food')\n```"
    ],
    "536": [
        "```\n#reason: The question wants to count the number of users with more than 10 views who created their account after the year 2013, so the SQL SELECT will count the users and filter based on views and account creation date.\n#columns: users.Views, users.CreationDate\n#values: more than 10 views refers to Views > 10, created after the year 2013 refers to year(CreationDate) > 2013\n#SELECT: SELECT COUNT(*) refer to users.Id\n#SQL-like: Show COUNT(*), WHERE Views > 10 AND year(CreationDate) > 2013\n#SQL: SELECT COUNT(*) FROM users WHERE Views > 10 AND year(CreationDate) > 2013\n```"
    ],
    "1494": [
        "```\n#reason: The question wants to calculate the percentage of premium gas stations in Slovakia, so the SQL SELECT will count the premium gas stations and divide it by the total gas stations in Slovakia, then multiply by 100.\n#columns: gasstations.Segment, gasstations.Country, gasstations.GasStationID\n#values: 'premium gas stations' refer to gasstations.Segment = 'Premium', 'Slovakia' refer to gasstations.Country = 'SVK'\n#SELECT: percentage of premium gas stations refer to (COUNT(CASE WHEN gasstations.Segment = 'Premium' THEN 1 END) * 100.0 / COUNT(*))\n#SQL-like: Show (COUNT(CASE WHEN gasstations.Segment = 'Premium' THEN 1 END) * 100.0 / COUNT(*)), WHERE gasstations.Country = 'SVK'\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.Segment = 'Premium' THEN 1 END) AS REAL) * 100.0 / COUNT(*) FROM gasstations AS T1 WHERE T1.Country = 'SVK'\n```"
    ],
    "1233": [
        "```\n#reason: The question wants to list each patient's ID and blood glucose (GLU) index that were within normal range for patients whose data was first recorded in 1991, so the SQL SELECT will include Patient.ID and Laboratory.GLU with filtering conditions for normal range and the year of the first recorded data.\n#columns: Patient.ID, Laboratory.GLU\n#values: blood glucose (GLU) index that were within normal range refers to Laboratory.GLU < 180; data that was first recorded in 1991 refers to strftime('%Y', Patient.Description) = '1991'\n#SELECT: SELECT Patient.ID, Laboratory.GLU\n#SQL-like: Show Patient.ID, Laboratory.GLU WHERE Laboratory.GLU < 180 AND strftime('%Y', Patient.Description) = '1991'\n#SQL: SELECT Patient.ID, Laboratory.GLU FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.GLU < 180 AND strftime('%Y', Patient.Description) = '1991'\n```"
    ],
    "966": [
        "```\n#reason: The question requires to display \"How many driver\" with the specific condition of \"race ID number 18\". The count of drivers is represented by COUNT(driverId).\n#columns: results.driverId\n#values: race ID number 18 refers to results.raceId = 18\n#SELECT: How many driver refer to COUNT(results.driverId)\n#SQL-like: Show COUNT(results.driverId), WHERE results.raceId = 18\n#SQL: SELECT COUNT(driverId) FROM results WHERE raceId = 18\n```"
    ],
    "1083": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to find the player with the strongest overall strength, so the SQL SELECT will retrieve the player with the maximum overall_rating.)\n#columns: Player.player_name, Player_Attributes.overall_rating\n#values: overall strength refers to MAX(overall_rating)\n#SELECT: SELECT Player.player_name, which player has the strongest overall strength refers to MAX(Player_Attributes.overall_rating)\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\n#SQL: SELECT P.player_name FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.overall_rating = (SELECT MAX(overall_rating) FROM Player_Attributes)\n```"
    ],
    "1144": [
        "```\n#reason: The question wants to identify the finishing rate and curve score of the player with the heaviest weight, so the SQL SELECT will retrieve the finishing and curve scores for the player with the maximum weight.\n#columns: Player_Attributes.finishing, Player_Attributes.curve, Player.weight\n#values: heaviest weight refers to Player.weight = (SELECT MAX(Player.weight) FROM Player)\n#SELECT: SELECT Player_Attributes.finishing, Player_Attributes.curve refer to Player_Attributes.finishing, Player_Attributes.curve\n#SQL-like: Show Player_Attributes.finishing, Player_Attributes.curve WHERE Player.weight = (SELECT MAX(Player.weight) FROM Player)\n#SQL: SELECT T1.finishing, T2.curve FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.weight = (SELECT MAX(weight) FROM Player)\n```"
    ],
    "149": [
        "```\n#reason: The question wants to list account types that are not eligible for loans and the average income of residents in the corresponding district. Account type 'OWNER' is eligible for loans, so we filter out that type while checking if the average income is between 8000 and 9000. \n#columns: account.frequency, district.A11\n#values: account.type is not 'OWNER' refers to account.frequency <> 'OWNER', average income exceeds $8000 but no more than $9000 refers to district.A11 > 8000 AND district.A11 <= 9000\n#SELECT: SELECT account.frequency, district.A11\n#SQL-like: Show account.frequency, district.A11 WHERE account.frequency <> 'OWNER' AND district.A11 > 8000 AND district.A11 <= 9000\n#SQL: SELECT account.frequency, district.A11 FROM account INNER JOIN district ON account.district_id = district.district_id WHERE account.frequency <> 'OWNER' AND district.A11 > 8000 AND district.A11 <= 9000\n```"
    ],
    "1347": [
        "```\n#reason: The question wants to identify the \"hometown county\" for the member \"Adela O'Gallagher\", so the SQL SELECT will retrieve the county from the zip_code table based on the member's zip code.\n#columns: zip_code.county\n#values: 'Adela O''Gallagher' refers to member.first_name = 'Adela' AND member.last_name = 'O''Gallagher'\n#SELECT: SELECT zip_code.county\n#SQL-like: Show zip_code.county, WHERE member.first_name = 'Adela' AND member.last_name = 'O''Gallagher'\n#SQL: SELECT T2.county FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Adela' AND T1.last_name = 'O''Gallagher'\n```"
    ],
    "290": [
        "```\n#reason: The question wants to find the toxic element present in the molecule TR151, so the SQL SELECT will identify the element based on the filtering condition of molecule_id = 'TR151'.\n#columns: atom.element\n#values: TR151 refers to atom.molecule_id = 'TR151'\n#SELECT: SELECT element refer to atom.element \n#SQL-like: Show atom.element WHERE atom.molecule_id = 'TR151'\n#SQL: SELECT atom.element FROM atom WHERE atom.molecule_id = 'TR151'\n```"
    ],
    "18": [
        "```\n#reason: The question wants to count the number of schools in Fresno that are directly funded and have a number of test takers not more than 250, so the SQL SELECT will count the schools meeting these criteria.\n#columns: schools.County, schools.FundingType, satscores.NumTstTakr\n#values: 'Fresno' refers to schools.County = 'Fresno', 'directly funded' refers to schools.FundingType = 'Directly funded', 'not more than 250' refers to satscores.NumTstTakr <= 250\n#SELECT: SELECT COUNT(schools.County) \n#SQL-like: Show COUNT(schools.County), WHERE schools.County = 'Fresno' AND schools.FundingType = 'Directly funded' AND satscores.NumTstTakr <= 250\n#SQL: SELECT COUNT(T1.County) FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.County = 'Fresno' AND T1.FundingType = 'Directly funded' AND T2.NumTstTakr <= 250\n```"
    ],
    "733": [
        "```\n#reason: The question wants to know \"how many gold-eyed superheroes\", so the SQL SELECT COUNT(superhero.id) and the necessary conditions for filtering the superheroes based on their eye color and publisher.\n#columns: superhero.id, colour.colour, publisher.publisher_name\n#values: 'gold-eyed' refers to colour.colour = 'Gold', 'Marvel Comics' refers to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE colour.colour = 'Gold' and publisher.publisher_name = 'Marvel Comics'\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id WHERE T3.colour = 'Gold' AND T2.publisher_name = 'Marvel Comics'\n```"
    ],
    "123": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to provide the account ID, district, and region for loan amounts greater than USD 300,000, so the SQL SELECT will pull data from the account and loan tables while filtering for loan amounts.\n#columns: account.account_id, district.A2, district.A3, loan.amount\n#values: loan amount greater than USD 300,000 refers to loan.amount > 300000\n#SELECT: account ID refers to account.account_id, district refers to district.A2, region refers to district.A3\n#SQL-like: Show account.account_id, district.A2, district.A3, WHERE loan.amount > 300000\n#SQL: SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T1.district_id = T3.district_id WHERE T2.amount > 300000\n```"
    ],
    "613": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list out the dates that users who are located in Rochester, NY obtained their badges, so the SQL SELECT will retrieve the badge dates filtered by user location.\n#columns: badges.Date, users.Location\n#values: 'Rochester, NY' refers to users.Location = 'Rochester, NY'\n#SELECT: SELECT badges.Date refer to badges.Date\n#SQL-like: Show badges.Date, WHERE users.Location = 'Rochester, NY'\n#SQL: SELECT badges.Date FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE users.Location = 'Rochester, NY'\n```"
    ],
    "91": [
        "```\n#reason: The question wants to compare the average unemployment ratios of 1995 and 1996 to determine which one has a higher percentage, so the SQL SELECT will calculate the average of A12 and A13 and compare them.\n#columns: district.A12, district.A13\n#values: None\n#SELECT: SELECT AVG(district.A12) AS avg_1995, AVG(district.A13) AS avg_1996\n#SQL-like: Show AVG(district.A12), AVG(district.A13)\n#SQL: SELECT AVG(district.A12) AS avg_1995, AVG(district.A13) AS avg_1996 FROM district\n```"
    ],
    "948": [
        "```\n#reason: The question wants to find the maximum points of British constructors, so the SQL SELECT will involve finding MAX(points) from constructorStandings filtered by nationality being 'British'.\n#columns: constructorStandings.points, constructors.nationality\n#values: British refer to constructors.nationality = 'British'\n#SELECT: SELECT MAX(points) refer to constructorStandings.points\n#SQL-like: Show MAX(constructorStandings.points), WHERE constructors.nationality = 'British'\n#SQL: SELECT MAX(T1.points) FROM constructorStandings AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T2.nationality = 'British'\n```"
    ],
    "371": [
        "```\n#reason: The question wants to calculate the percentage of cards whose language is French among the Story Spotlight cards, so the SQL SELECT will count the cards with the specified conditions and calculate the percentage.\n#columns: cards.id, foreign_data.language, cards.isStorySpotlight\n#values: 'French' refers to foreign_data.language = 'French', 'Story Spotlight' refers to cards.isStorySpotlight = 1\n#SELECT: SELECT Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100\n#SQL-like: Show Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100\n#SQL: SELECT CAST(SUM(CASE WHEN T1.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1\n```"
    ],
    "340": [
        "```\n#reason: The question wants to identify the cards that have incredibly powerful foils, so the SQL SELECT will include relevant columns from the cards table based on the conditions specified.\n#columns: cards.cardKingdomFoilId, cards.cardKingdomId, cards.name\n#values: 'incredibly powerful foils' refer to cards.cardKingdomFoilId is not null AND cards.cardKingdomId is not null\n#SELECT: SELECT cards.cardKingdomFoilId, cards.cardKingdomId, cards.name\n#SQL-like: Show cards.cardKingdomFoilId, cards.cardKingdomId, cards.name, WHERE cards.cardKingdomFoilId is not null AND cards.cardKingdomId is not null\n#SQL: SELECT cards.cardKingdomFoilId, cards.cardKingdomId, cards.name FROM cards WHERE cards.cardKingdomFoilId is not null AND cards.cardKingdomId is not null\n```"
    ],
    "1205": [
        "```\n#reason: The question wants to determine if the uric acid level of a specific patient is within a normal range based on their sex, so the SQL SELECT will check the conditions for uric acid and sex.\n#columns: Laboratory.UA, Patient.SEX\n#values: patient number 57266 refers to Patient.ID = 57266\n#SELECT: SELECT content refers to Laboratory.UA, Patient.SEX\n#SQL-like: Show Laboratory.UA, Patient.SEX WHERE Patient.ID = 57266\n#SQL: SELECT T1.UA, T2.SEX FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.ID = 57266\n```"
    ],
    "288": [
        "```\n#reason: The question wants to identify if the molecule containing atom TR001_1 is carcinogenic, so the SQL SELECT will check the label of the molecule associated with the atom.\n#columns: molecule.label\n#values: 'contains atom TR001_1' refer to atom.atom_id = 'TR001_1'\n#SELECT: SELECT molecule.label refer to molecule.label\n#SQL-like: Show molecule.label WHERE atom.atom_id = 'TR001_1'\n#SQL: SELECT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_1'\n```"
    ],
    "1288": [
        "```\n#reason: The question wants to list the diagnosis of the patients whose total protein is lower than normal, so the SQL SELECT will retrieve the diagnosis from the Patient table where the total protein from the Laboratory table is less than 6.0.\n#columns: Patient.Diagnosis, Laboratory.TP\n#values: total protein is lower than normal refer to Laboratory.TP < 6.0\n#SELECT: SELECT Patient.Diagnosis refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis WHERE Laboratory.TP < 6.0\n#SQL: SELECT Patient.Diagnosis FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.TP < 6.0\n```"
    ],
    "659": [
        "```\n#reason: The question wants to count the number of tags that have a post count between 5,000 to 7,000, so the SQL SELECT will count the tags where the post count falls within that range.\n#columns: tags.Count\n#values: post count between 5,000 to 7,000 refer to tags.Count BETWEEN 5000 AND 7000\n#SELECT: How many tags refer to COUNT(*)\n#SQL-like: Show COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000\n#SQL: SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000\n```"
    ],
    "505": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to show the Simplified Chinese translation of the name of the set \"Mirrodin\", so the SQL SELECT will retrieve the translation where the language is 'Chinese Simplified' and the set name is 'Mirrodin'.\n#columns: set_translations.translation, sets.name\n#values: 'Simplified Chinese translation' refer to set_translations.language = 'Chinese Simplified', 'name of the set \"Mirrodin\"' refer to sets.name = 'Mirrodin'\n#SELECT: SELECT set_translations.translation refer to set_translations.translation\n#SQL-like: Show set_translations.translation, WHERE set_translations.language = 'Chinese Simplified' AND sets.name = 'Mirrodin'\n#SQL: SELECT T1.translation FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Chinese Simplified' AND T2.name = 'Mirrodin'\n```"
    ],
    "1371": [
        "```\n#reason: The question wants to determine the number of members who attended a specific event, so the SQL SELECT will count the distinct members linked to the event 'Women's Soccer'.\n#columns: attendance.link_to_member, event.event_name\n#values: 'Women's Soccer' refer to event.event_name = 'Women's Soccer'\n#SELECT: Show COUNT(DISTINCT attendance.link_to_member) refer to attendance.link_to_member\n#SQL-like: Show COUNT(DISTINCT attendance.link_to_member), WHERE event.event_name = 'Women's Soccer'\n#SQL: SELECT COUNT(DISTINCT T1.link_to_member) FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'Women's Soccer'\n```"
    ],
    "559": [
        "```\n#reason: The question wants to indicate the creation date of the maximum number of votes, so the SQL SELECT will count the votes and find the maximum count, then retrieve the corresponding creation date.\n#columns: votes.CreationDate, votes.Id\n#values: maximum number of votes refers to Max(Count(votes.Id))\n#SELECT: SELECT CreationDate refer to votes.CreationDate\n#SQL-like: Show votes.CreationDate, WHERE condition is the maximum number of votes (ORDER BY COUNT(votes.Id) DESC LIMIT 1), GROUP BY votes.CreationDate\n#SQL: SELECT CreationDate FROM votes GROUP BY CreationDate ORDER BY COUNT(Id) DESC LIMIT 1\n```"
    ],
    "439": [
        "```\n#reason: The question requires displaying \"set name\" for the specified set code. The filtering condition is based on the set code being \"ALL\".\n#columns: sets.name, sets.code\n#values: set code \"ALL\" refer to sets.code = 'ALL'\n#SELECT: SELECT set name refer to sets.name\n#SQL-like: Show sets.name, WHERE sets.code = 'ALL'\n#SQL: SELECT name FROM sets WHERE code = 'ALL'\n```"
    ],
    "374": [
        "```\n#reason: The question wants to display \"How many black border cards\". \"black border card\" refers to borderColor = 'black' and \"available on mtgo\" refers to availability = 'mtgo'.\n#columns: cards.borderColor, cards.availability\n#values: black border card refers to cards.borderColor = 'black', available on mtgo refers to cards.availability = 'mtgo'\n#SELECT: How many black border cards refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE cards.borderColor = 'black' AND cards.availability = 'mtgo'\n#SQL: SELECT COUNT(*) FROM cards WHERE cards.borderColor = 'black' AND cards.availability = 'mtgo'\n```"
    ],
    "331": [
        "```\n#reason: The question wants to count the number of molecules that are carcinogenic, so the SQL SELECT COUNT(molecule.molecule_id) and WHERE molecule.label = '+'.\n#columns: molecule.molecule_id, molecule.label\n#values: 'carcinogenic' refer to molecule.label = '+'\n#SELECT: SELECT COUNT(molecule.molecule_id) refer to molecule.molecule_id.\n#SQL-like: Show COUNT(molecule.molecule_id), WHERE molecule.label = '+'\n#SQL: SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '+'\n```"
    ],
    "491": [
        "```\n#reason: The question wants to display the magic card market name for a specific set release date, so the SQL SELECT will retrieve mcmName where the release date matches.\n#columns: sets.mcmName, sets.releaseDate\n#values: 'released on 2017/6/9' refers to sets.releaseDate = '2017-06-09'\n#SELECT: magic card market name refers to sets.mcmName\n#SQL-like: Show sets.mcmName, WHERE sets.releaseDate = '2017-06-09'\n#SQL: SELECT T1.mcmName FROM sets AS T1 WHERE T1.releaseDate = '2017-06-09'\n```"
    ],
    "206": [
        "```\n#reason: The question wants to identify the elements associated with the atoms in the bond with id 'TR004_8_9', so the SQL SELECT will retrieve the elements from the atom table that are linked to the atoms in the specified bond.\n#columns: atom.element\n#values: bond_id = 'TR004_8_9' refers to bond.bond_id = 'TR004_8_9'\n#SELECT: SELECT atom.element\n#SQL-like: Show atom.element WHERE bond.bond_id = 'TR004_8_9'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR004_8_9'\n```"
    ],
    "1188": [
        "```\n#reason: The question wants to count the number of female patients born in 1964 who were admitted to the hospital, so the SQL SELECT will count the Patient.ID and filter based on the specified conditions.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday, Patient.Admission\n#values: female refers to SEX = 'F', born in 1964 refers to strftime('%Y', Birthday) = '1964', admitted to the hospital refers to Admission = '+'\n#SELECT: SELECT Patient.ID\n#SQL-like: Show Patient.ID, WHERE Patient.SEX = 'F' AND strftime('%Y', Patient.Birthday) = '1964' AND Patient.Admission = '+'\n#SQL: SELECT Patient.ID FROM Patient WHERE Patient.SEX = 'F' AND strftime('%Y', Patient.Birthday) = '1964' AND Patient.Admission = '+'\n```"
    ],
    "14": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the top five schools by the highest number of Enrollment (Ages 5-17), so the SQL SELECT will retrieve the NCES school identification number ordered by Enrollment (Ages 5-17) in descending order and limited to five results.\n#columns: schools.NCESSchool, frpm.`Enrollment (Ages 5-17)`\n#values: None\n#SELECT: SELECT NCES school identification number refer to schools.NCESSchool\n#SQL-like: Show schools.NCESSchool, ORDER BY frpm.`Enrollment (Ages 5-17)` DESC LIMIT 5\n#SQL: SELECT T1.NCESSchool FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode ORDER BY T2.`Enrollment (Ages 5-17)` DESC LIMIT 5\n```"
    ],
    "661": [
        "```\n#reason: The question wants to determine \"how old is the most influential user\", so the SQL SELECT will retrieve the age of the user with the maximum reputation.\n#columns: users.Age\n#values: most influential refer to MAX(Reputation) which gives the user with the highest reputation.\n#SELECT: SELECT Age refer to users.Age.\n#SQL-like: Show users.Age WHERE users.Reputation = MAX(Reputation)\n#SQL: SELECT Age FROM users WHERE Reputation = (SELECT MAX(Reputation) FROM users)\n```"
    ],
    "1148": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of players that are under 180 cm and have an overall strength of more than 70, so the SQL SELECT will count the number of players satisfying these conditions divided by the total number of players and multiplied by 100.\n#columns: Player.height, Player.id, Player_Attributes.overall_rating\n#values: 'under 180 cm' refer to Player.height < 180, 'overall strength of more than 70' refer to Player_Attributes.overall_rating > 70\n#SELECT: percentage of players under 180 cm who have an overall strength of more than 70 refer to DIVIDE(COUNT(Player.id WHERE Player.height < 180 AND Player_Attributes.overall_rating > 70), COUNT(Player.id)) * 100\n#SQL-like: Show DIVIDE(COUNT(Player.id WHERE Player.height < 180 AND Player_Attributes.overall_rating > 70), COUNT(Player.id)) * 100\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.height < 180 AND T2.overall_rating > 70 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id\n```"
    ],
    "159": [
        "```\n#reason: The question wants to list all the withdrawals in cash transactions made by the client with the id 3356, so the SQL SELECT will filter for operation = 'VYBER' and client_id = 3356.\n#columns: trans.trans_id, trans.amount, trans.date, trans.operation\n#values: client id 3356 refers to trans.account_id IN (SELECT account_id FROM disp WHERE client_id = 3356) AND operation = 'VYBER'\n#SELECT: SELECT trans.trans_id, trans.amount, trans.date, trans.operation refer to trans.trans_id, trans.amount, trans.date, trans.operation\n#SQL-like: Show trans.trans_id, trans.amount, trans.date, trans.operation WHERE trans.account_id IN (SELECT account_id FROM disp WHERE client_id = 3356) AND trans.operation = 'VYBER'\n#SQL: SELECT T1.trans_id, T1.amount, T1.date, T1.operation FROM trans AS T1 WHERE T1.account_id IN (SELECT disp.account_id FROM disp WHERE disp.client_id = 3356) AND T1.operation = 'VYBER'\n```"
    ],
    "1208": [
        "```\n#reason: The question wants to provide IDs for male patients with GPT that exceed the normal range, so the SQL SELECT will count the IDs of male patients where GPT is greater than or equal to 60.\n#columns: Patient.ID, Laboratory.GPT, Patient.SEX\n#values: male refers to Patient.SEX = 'M', ALT glutamic pylvic transaminase (GPT) exceed the normal range refers to Laboratory.GPT >= 60\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID WHERE Patient.SEX = 'M' AND Laboratory.GPT >= 60\n#SQL: SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GPT >= 60\n```"
    ],
    "1362": [
        "```\n#reason: The question wants to display the total count of cities in Orange County, Virginia. \"Orange County\" is a filtering condition for the county and \"Virginia\" is a filtering condition for the state.\n#columns: zip_code.city, zip_code.county, zip_code.state\n#values: 'Orange County' refers to zip_code.county = 'Orange County', 'Virginia' refers to zip_code.state = 'Virginia'\n#SELECT: SELECT COUNT(zip_code.city) refer to COUNT(zip_code.city)\n#SQL-like: Show COUNT(zip_code.city), WHERE zip_code.county = 'Orange County' AND zip_code.state = 'Virginia'\n#SQL: SELECT COUNT(*) FROM zip_code WHERE zip_code.county = 'Orange County' AND zip_code.state = 'Virginia'\n```"
    ],
    "988": [
        "```\n#reason: The question wants to list down the top 3 German drivers who have the shortest average pit stop duration and were born between 1980-1985. The average pit stop duration is calculated by dividing the sum of durations by the count of durations, and filtering is done based on the birth year range of 1980 to 1985.\n#columns: drivers.forename, drivers.surname, pitStops.duration\n#values: born between 1980-1985 refers to 'strftime('%Y', drivers.dob) BETWEEN '1980' AND '1985''\n#SELECT: SELECT drivers.forename, drivers.surname refer to drivers.forename, drivers.surname; also calculating avg(duration) for filtering\n#SQL-like: Show drivers.forename, drivers.surname, WHERE drivers.nationality = 'German' AND strftime('%Y', drivers.dob) BETWEEN '1980' AND '1985' GROUP BY drivers.driverId ORDER BY AVG(pitStops.duration) ASC LIMIT 3\n#SQL: SELECT drivers.forename, drivers.surname FROM drivers INNER JOIN pitStops ON drivers.driverId = pitStops.driverId WHERE drivers.nationality = 'German' AND strftime('%Y', drivers.dob) BETWEEN '1980' AND '1985' GROUP BY drivers.driverId ORDER BY AVG(pitStops.duration) ASC LIMIT 3\n```"
    ],
    "925": [
        "```\n#reason: The question wants to display the link of the website that shows more information about the circuits used in the Spanish Grand Prix in 2009, so the SQL SELECT will get the circuits.url filtered by race name and year.\n#columns: circuits.url, races.name, races.year\n#values: 'Spanish Grand Prix' refer to races.name = 'Spanish Grand Prix', 2009 refer to races.year = 2009\n#SELECT: SELECT circuits.url refer to circuits.url\n#SQL-like: Show circuits.url WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009\n#SQL: SELECT T1.url FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitId = T1.circuitId WHERE T2.name = 'Spanish Grand Prix' AND T2.year = 2009\n```"
    ],
    "489": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the keyrune code for a specific set, so the SQL SELECT will retrieve the keyruneCode from the sets table where the set code matches 'PKHC'.\n#columns: sets.keyruneCode\n#values: 'PKHC' refers to sets.code = 'PKHC'\n#SELECT: SELECT keyruneCode refer to sets.keyruneCode\n#SQL-like: Show sets.keyruneCode WHERE sets.code = 'PKHC'\n#SQL: SELECT keyruneCode FROM sets WHERE code = 'PKHC'\n```"
    ],
    "663": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"id of the youngest user\", so the SQL SELECT will retrieve the user id where the age is the minimum.\n#columns: users.Id, users.Age\n#values: youngest user refers to MIN(Age)\n#SELECT: id of the youngest user refers to users.Id\n#SQL-like: Show users.Id, WHERE users.Age = MIN(Age)\n#SQL: SELECT Id FROM users WHERE Age = (SELECT MIN(Age) FROM users)\n```"
    ],
    "1261": [
        "```\n#reason: The question wants to determine the count of patients with a normal RF who do not have thrombosis, so the SQL SELECT will count the patients based on the specified conditions.\n#columns: Patient.ID, Laboratory.RF, Examination.Thrombosis\n#values: normal RF refers to Laboratory.RF < 20, don't have thrombosis refers to Examination.Thrombosis = 0\n#SELECT: COUNT(Patient.ID) refer to the count of patients with normal RF and no thrombosis\n#SQL-like: Show COUNT(Patient.ID), WHERE Laboratory.RF < 20 AND Examination.Thrombosis = 0\n#SQL: SELECT COUNT(Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Laboratory.RF < 20 AND Examination.Thrombosis = 0\n```"
    ],
    "344": [
        "```\n#reason: The question wants to list all the mythic rarity print cards that are banned in gladiator format, so the SQL SELECT will include the relevant columns and apply the necessary filters.\n#columns: cards.rarity, legalities.status, legalities.format\n#values: 'mythic rarity printing' refer to cards.rarity = 'mythic', 'card banned' refer to legalities.status = 'Banned', 'in gladiator format' refer to legalities.format = 'gladiator'\n#SELECT: SELECT cards.rarity, legalities.status, legalities.format\n#SQL-like: Show cards.rarity, legalities.status, legalities.format WHERE cards.rarity = 'mythic' AND legalities.status = 'Banned' AND legalities.format = 'gladiator'\n#SQL: SELECT cards.rarity, legalities.status, legalities.format FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.rarity = 'mythic' AND legalities.status = 'Banned' AND legalities.format = 'gladiator'\n```"
    ],
    "560": [
        "```\n#reason: The question wants to count the number of \"Revival\" badges, so the SQL SELECT will count the badge Id where the badge Name is 'Revival'.\n#columns: badges.Id, badges.Name\n#values: 'Revival' refers to badges.Name = 'Revival'\n#SELECT: number of \"Revival\" badges refers to COUNT(badges.Id)\n#SQL-like: Show COUNT(badges.Id), WHERE badges.Name = 'Revival'\n#SQL: SELECT COUNT(Id) FROM badges WHERE Name = 'Revival'\n```"
    ],
    "136": [
        "```\n#reason: The question wants to count the number of loans approved between specified dates, so the SQL SELECT will count the loan records filtered by the date range and frequency condition.\n#columns: loan.loan_id, loan.amount, account.frequency\n#values: 'between 1/1/1995 and 12/31/1997' refer to \"loan.date >= '1995-01-01' AND loan.date <= '1997-12-31'\", 'at least 250,000' refer to loan.amount >= 250000, 'monthly statement issuance' refers to account.frequency = 'POPLATEK MESICNE'\n#SELECT: SELECT COUNT(loan.loan_id) refer to how many loans\n#SQL-like: Show COUNT(loan.loan_id) WHERE loan.date BETWEEN '1995-01-01' AND '1997-12-31' AND loan.amount >= 250000 AND account.frequency = 'POPLATEK MESICNE'\n#SQL: SELECT COUNT(T1.loan_id) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.date BETWEEN '1995-01-01' AND '1997-12-31' AND T1.amount >= 250000 AND T2.frequency = 'POPLATEK MESICNE'\n```"
    ],
    "142": [
        "```\n#reason: The question wants to identify accounts that placed orders for household payment, so the SQL SELECT will retrieve account IDs from the order table where the k_symbol indicates household payment and join with the account table to filter by the district name 'Pisek'.\n#columns: order.account_id, account.district_id\n#values: 'household payment' refers to order.k_symbol = 'SIPO', 'Pisek' refers to district.A2 = 'Pisek'\n#SELECT: SELECT order.account_id refer to order.account_id\n#SQL-like: Show order.account_id, WHERE order.k_symbol = 'SIPO' AND account.district_id IN (SELECT district.district_id FROM district WHERE district.A2 = 'Pisek')\n#SQL: SELECT T1.account_id FROM order AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.k_symbol = 'SIPO' AND T2.district_id IN (SELECT district_id FROM district WHERE A2 = 'Pisek')\n```"
    ],
    "881": [
        "```\n#reason: The question wants to calculate the race completion rate for drivers who participated in the race on a specific date. This involves counting the number of drivers who finished the race (i.e., have a time value) and dividing it by the total number of drivers who participated in that race. The date filter is applied to select the race on '1983-07-16'.\n#columns: results.driverId, results.time\n#values: 'in 1983/7/16' refers to results.raceId IN (SELECT raceId FROM races WHERE date = '1983-07-16')\n#SELECT: SELECT DIVIDE(COUNT(driverId WHERE time IS NOT NULL), COUNT(driverId)) as percentage\n#SQL-like: Show DIVIDE(COUNT(driverId WHERE time IS NOT NULL), COUNT(driverId)), WHERE raceId IN (SELECT raceId FROM races WHERE date = '1983-07-16')\n#SQL: SELECT CAST(COUNT(CASE WHEN T2.time IS NOT NULL THEN 1 END) AS REAL) * 100 / COUNT(T2.driverId) FROM results AS T2 INNER JOIN races AS T1 ON T2.raceId = T1.raceId WHERE T1.date = '1983-07-16'\n```"
    ],
    "767": [
        "```\n#reason: The question wants to calculate the average of superheroes with no skin colour, so the SQL SELECT will count the total number of superheroes and divide it by the sum of superheroes with skin_colour_id equal to 1 (indicating no skin colour).\n#columns: superhero.id, superhero.skin_colour_id\n#values: no skin colour refers to superhero.skin_colour_id = 1\n#SELECT: SELECT DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1)) refer to superhero.id\n#SQL-like: Show DIVIDE(COUNT(superhero.id), SUM(skin_colour_id = 1))\n#SQL: SELECT CAST(COUNT(superhero.id) AS REAL) / SUM(CASE WHEN superhero.skin_colour_id = 1 THEN 1 ELSE 0 END) FROM superhero\n```"
    ],
    "550": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to find the body of the post that has the most popular tag, so the SQL SELECT will retrieve the post body where the tag count is maximized.)\n#columns: posts.Body, tags.Count\n#values: most popular tag refers to MAX(Count) which means we need to group by tags and find the maximum count.\n#SELECT: SELECT posts.Body refer to posts.Body\n#SQL-like: Show posts.Body, WHERE condition is the most popular tag (refer to MAX(Count)), GROUP BY tags.Id ORDER BY COUNT(tags.Id) DESC LIMIT 1\n#SQL: SELECT T1.Body FROM posts AS T1 INNER JOIN tags AS T2 ON T2.ExcerptPostId = T1.Id GROUP BY T2.Id ORDER BY COUNT(T2.Id) DESC LIMIT 1\n```"
    ],
    "236": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the bond type and the atoms associated with a specific bond ID, so the SQL SELECT will include bond.bond_type for the bond type and connected.atom_id and connected.atom_id2 for the atoms.\n#columns: bond.bond_type, connected.atom_id, connected.atom_id2\n#values: bond ID of TR001_6_9 refers to bond.bond_id = 'TR001_6_9'\n#SELECT: SELECT bond.bond_type, connected.atom_id, connected.atom_id2 refer to bond.bond_type, connected.atom_id and connected.atom_id2.\n#SQL-like: Show bond.bond_type, connected.atom_id, connected.atom_id2 WHERE connected.bond_id = 'TR001_6_9'\n#SQL: SELECT T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_id = 'TR001_6_9'\n```"
    ],
    "61": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of chartered schools in Hickman owned by the Elementary School District. So the SQL SELECT will count schools where Charter = 1 and DOC = 52 while filtering by city = 'Hickman'.\n#columns: schools.Charter, schools.DOC, schools.City\n#values: 'Hickman' refers to schools.City = 'Hickman', 'Elementary School District' refers to schools.DOC = 52, 'Chartered schools' refers to schools.Charter = 1\n#SELECT: SELECT COUNT(schools.Charter) refer to COUNT(schools.Charter)\n#SQL-like: Show COUNT(schools.Charter) WHERE schools.City = 'Hickman' AND schools.DOC = '52' AND schools.Charter = 1\n#SQL: SELECT COUNT(schools.Charter) FROM schools WHERE schools.City = 'Hickman' AND schools.DOC = '52' AND schools.Charter = 1\n```"
    ],
    "190": [
        "```\n#reason: The question wants to count the number of clients born in 1920 who stay in east Bohemia, so the SQL SELECT should count distinct clients and filter by birth_date and region.\n#columns: client.client_id, client.birth_date, district.A3\n#values: 'born in 1920' refers to client.birth_date LIKE '1920%', 'stay in east Bohemia' refers to district.A3 = 'east Bohemia'\n#SELECT: SELECT COUNT(DISTINCT client.client_id) refer to client.client_id\n#SQL-like: Show COUNT(DISTINCT client.client_id), WHERE client.birth_date LIKE '1920%' AND district.A3 = 'east Bohemia'\n#SQL: SELECT COUNT(DISTINCT T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.birth_date LIKE '1920%' AND T2.A3 = 'east Bohemia'\n```"
    ],
    "465": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to check if there is a Korean version of the card \"Ancestor's Chosen\", so the SQL SELECT will check for the existence of a record with the specified name and language.)\n#columns: cards.name, foreign_data.language\n#values: 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen', 'Korean' refer to foreign_data.language = 'Korean'\n#SELECT: SELECT EXISTS (SELECT 1 FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Korean')\n#SQL-like: Show EXISTS (SELECT 1 WHERE cards.name = 'Ancestor''s Chosen' AND foreign_data.language = 'Korean')\n#SQL: SELECT EXISTS (SELECT 1 FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Korean')\n```"
    ],
    "1361": [
        "```\n#reason: The question wants to calculate the total cost of pizzas for all events, so the SQL SELECT will sum the cost from the expense table where the expense description is 'Pizza'.\n#columns: expense.cost, expense.expense_description\n#values: 'pizzas' refer to expense.expense_description = 'Pizza'\n#SELECT: SELECT SUM(cost) refer to expense.cost\n#SQL-like: Show SUM(cost), WHERE expense_description = 'Pizza'\n#SQL: SELECT SUM(cost) FROM expense WHERE expense_description = 'Pizza'\n```"
    ],
    "1125": [
        "```\n#reason: The question wants to display the name of the eldest player among those with a finishing rate of 1, so the SQL SELECT will find the player with the maximum age and a finishing rate of 1.\n#columns: Player.player_name, Player.birthday, Player_Attributes.finishing\n#values: finishing rate of 1 refers to Player_Attributes.finishing = 1\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.finishing = 1, ORDER BY Player.birthday ASC LIMIT 1\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.finishing = 1 ORDER BY T1.birthday ASC LIMIT 1\n```"
    ],
    "967": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to state code numbers of the top 3 youngest drivers and count how many of them are from the Netherlands, so the SQL SELECT will retrieve driver codes and count the number of drivers from the Netherlands.\n#columns: drivers.code, drivers.dob\n#values: youngest driver refers to MAX(year(dob)), nationality refers to drivers.nationality = 'Dutch'\n#SELECT: SELECT drivers.code, COUNT(CASE WHEN drivers.nationality = 'Dutch' THEN 1 END)\n#SQL-like: Show drivers.code, COUNT(*), ORDER BY year(dob) DESC LIMIT 3\n#SQL: SELECT drivers.code, COUNT(CASE WHEN drivers.nationality = 'Dutch' THEN 1 END) FROM drivers ORDER BY drivers.dob DESC LIMIT 3\n```"
    ],
    "22": [
        "```\n#reason: The question wants to identify the school with the highest number of test takers, so the SQL SELECT will order by the number of test takers in descending order and limit the result to 1.\n#columns: satscores.sname, satscores.NumTstTakr\n#values: highest number of test takers refers to ORDER BY satscores.NumTstTakr DESC LIMIT 1\n#SELECT: the school with the highest number of test takers refers to satscores.sname\n#SQL-like: Show satscores.sname, ORDER BY satscores.NumTstTakr DESC LIMIT 1\n#SQL: SELECT T1.sname FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T2.County = 'Contra Costa' ORDER BY T1.NumTstTakr DESC LIMIT 1\n```"
    ],
    "27": [
        "```\n#reason: The question wants to find the average score in writing for schools opened after 1991 or closed before 2000, along with school names and communication numbers. So the SQL SELECT will include the average writing score, school names, and phone numbers based on specific conditions about opening and closing dates.\n#columns: schools.School, satscores.AvgScrWrite, schools.Phone\n#values: opened after 1991 refer to schools.OpenDate > '1991-01-01', closed before 2000 refers to schools.ClosedDate < '2000-01-01'\n#SELECT: SELECT schools.School, AVG(satscores.AvgScrWrite), schools.Phone refer to school names, average writing score, and communication number.\n#SQL-like: Show schools.School, AVG(satscores.AvgScrWrite), schools.Phone WHERE schools.OpenDate > '1991-01-01' OR schools.ClosedDate < '2000-01-01' GROUP BY schools.School\n#SQL: SELECT schools.School, AVG(satscores.AvgScrWrite), schools.Phone FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE schools.OpenDate > '1991-01-01' OR schools.ClosedDate < '2000-01-01' GROUP BY schools.School\n```"
    ],
    "413": [
        "```\n#reason: The question wants to find out the number of cards that have a print rarity with ruling text printed on a specific date, so the SQL SELECT will count the cards' IDs where rarity is 'rare' and ruling date is '2007-02-01'.\n#columns: cards.id, cards.rarity, rulings.date\n#values: 'print rarity' refer to rarity = 'rare', 'on 01/02/2007' refer to rulings.date = '2007-02-01'\n#SELECT: SELECT COUNT(cards.id) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id), WHERE cards.rarity = 'rare' AND rulings.date = '2007-02-01'\n#SQL: SELECT COUNT(cards.id) FROM cards INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE cards.rarity = 'rare' AND rulings.date = '2007-02-01'\n```"
    ],
    "822": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of villains with green skin, so the SQL SELECT will count occurrences where skin_colour_id matches the green colour and alignment is 'Bad'.\n#columns: superhero.id, alignment.alignment, colour.colour\n#values: green-skinned refers to colour.colour = 'Green' WHERE superhero.skin_colour_id = colour.id; villains refers to alignment.alignment = 'Bad'.\n#SELECT: SELECT COUNT(*) refer to superhero.id\n#SQL-like: Show COUNT(*) WHERE alignment.alignment = 'Bad' AND colour.colour = 'Green'\n#SQL: SELECT COUNT(*) FROM superhero INNER JOIN alignment ON superhero.alignment_id = alignment.id INNER JOIN colour ON superhero.skin_colour_id = colour.id WHERE colour.colour = 'Green' AND alignment.alignment = 'Bad'\n```"
    ],
    "146": [
        "```\n#reason: The question wants to identify female account holders who possess both credit cards and loans, so the SQL SELECT will retrieve relevant account holder details while filtering for gender and ensuring card and loan ownership.\n#columns: client.client_id, client.gender, card.card_id, loan.loan_id\n#values: female refers to client.gender = 'F'\n#SELECT: SELECT DISTINCT client.client_id refer to client.client_id, client.gender refer to client.gender, card.card_id refer to card.card_id, loan.loan_id refer to loan.loan_id\n#SQL-like: Show DISTINCT client.client_id, client.gender, card.card_id, loan.loan_id WHERE client.gender = 'F'\n#SQL: SELECT DISTINCT T1.client_id, T1.gender, T2.card_id, T3.loan_id FROM client AS T1 INNER JOIN card AS T2 ON T1.client_id = T2.disp_id INNER JOIN loan AS T3 ON T1.client_id = T3.account_id WHERE T1.gender = 'F'\n```"
    ],
    "1267": [
        "```\n#reason: The question wants to count the number of patients with normal anti-SM who do not have thrombosis, so the SQL SELECT COUNT(*) and the filtering conditions are based on the values of the anti-SM and thrombosis columns.\n#columns: Patient.ID, Laboratory.SM, Examination.Thrombosis\n#values: normal anti-SM refers to Laboratory.SM IN('-', '+-') and does not have thrombosis refers to Examination.Thrombosis = 0\n#SELECT: SELECT COUNT(*) refer to COUNT(*)\n#SQL-like: Show COUNT(*) WHERE Laboratory.SM IN('-', '+-') AND Examination.Thrombosis = 0\n#SQL: SELECT COUNT(*) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.SM IN('-', '+-') AND T3.Thrombosis = 0\n```"
    ],
    "1051": [
        "```\n#reason: The question wants to list all the football players with the highest potential score. Therefore, the SQL SELECT statement will find the player(s) having the maximum potential score.\n#columns: Player.player_name, Player_Attributes.potential\n#values: highest potential score refers to MAX(Player_Attributes.potential)\n#SELECT: SELECT Player.player_name, Player_Attributes.potential\n#SQL-like: Show all football players, where Player_Attributes.potential is the highest\n#SQL: SELECT P.player_name, PA.potential FROM Player AS P INNER JOIN Player_Attributes AS PA ON P.player_api_id = PA.player_api_id WHERE PA.potential = (SELECT MAX(potential) FROM Player_Attributes)\n```"
    ],
    "1132": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to provide the names of the top three football players who are over 180 cm tall, so the SQL SELECT will need to filter players based on height and limit the results to three while ordering the names alphabetically.\n#columns: Player.player_name, Player.height\n#values: over 180 cm tall refers to Player.height > 180\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name WHERE Player.height > 180 ORDER BY Player.player_name ASC LIMIT 3\n#SQL: SELECT Player.player_name FROM Player WHERE Player.height > 180 ORDER BY Player.player_name ASC LIMIT 3\n```"
    ],
    "486": [
        "```\n#reason: The question wants to calculate the percentage of cards with a converted mana cost of 7 in the set Coldsnap, so the SQL SELECT will sum the converted mana cost for cards with a cost of 7 and divide it by the total sum of converted mana costs for all cards in the set, then multiply by 100.\n#columns: cards.convertedManaCost, sets.name\n#values: 'Coldsnap' refer to sets.name = 'Coldsnap', 'converted mana cost of 7' refer to cards.convertedManaCost = 7\n#SELECT: SELECT (percentage of cards with converted mana cost of 7) refer to CAST(SUM(CASE WHEN cards.convertedManaCost = 7 THEN cards.convertedManaCost ELSE 0 END) AS REAL) * 100 / SUM(cards.convertedManaCost)\n#SQL-like: Show CAST(SUM(CASE WHEN cards.convertedManaCost = 7 THEN cards.convertedManaCost ELSE 0 END) AS REAL) * 100 / SUM(cards.convertedManaCost), WHERE sets.name = 'Coldsnap'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN T1.convertedManaCost ELSE 0 END) AS REAL) * 100 / SUM(T1.convertedManaCost) FROM cards AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T2.name = 'Coldsnap'\n```"
    ],
    "1474": [
        "```\n#reason: The question wants to identify customers who consumed the most gas in 2011 while filtering for customers paying in CZK. The consumption data is related to the year 2011, represented by the range between 201101 and 201112, which is applied to the yearmonth.Date.\n#columns: yearmonth.CustomerID, yearmonth.Consumption\n#values: 'paying in CZK' refers to customers.Currency = 'CZK', 'consumed the most gas in 2011' refers to yearmonth.Date BETWEEN '201101' AND '201112'\n#SELECT: SELECT yearmonth.CustomerID, SUM(yearmonth.Consumption) refer to customer ID and total consumption.\n#SQL-like: Show yearmonth.CustomerID, SUM(yearmonth.Consumption), WHERE customers.Currency = 'CZK' AND yearmonth.Date BETWEEN '201101' AND '201112', GROUP BY yearmonth.CustomerID, ORDER BY SUM(yearmonth.Consumption) DESC\n#SQL: SELECT yearmonth.CustomerID FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE customers.Currency = 'CZK' AND yearmonth.Date BETWEEN '201101' AND '201112' GROUP BY yearmonth.CustomerID ORDER BY SUM(yearmonth.Consumption) DESC\n```"
    ],
    "1174": [
        "```\n#reason: The question wants to calculate the average age of patients as of year 1999 who were examined in the laboratory during October of the year 1991, so the SQL SELECT will compute the average of the age based on the birthday and filter the records by the examination date.\n#columns: Patient.Birthday, Laboratory.Date\n#values: October of 1991 refers to Laboratory.Date BETWEEN '1991-10-01' AND '1991-10-30'\n#SELECT: average age of patients as of year 1999 refer to AVG(SUBTRACT('1999', year(Birthday)))\n#SQL-like: Show AVG(SUBTRACT('1999', year(Birthday))), WHERE Laboratory.Date BETWEEN '1991-10-01' AND '1991-10-30'\n#SQL: SELECT AVG(1999 - strftime('%Y', T1.Birthday)) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date BETWEEN '1991-10-01' AND '1991-10-30'\n```"
    ],
    "1367": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the college that most members go to, so the SQL SELECT will count the number of members per college and find the maximum.\n#columns: major.college, member.link_to_major\n#values: most members go refers to MAX(COUNT(major.college)) \n#SELECT: SELECT college refer to major.college\n#SQL-like: Show major.college, GROUP BY major.college, ORDER BY COUNT(member.link_to_major) DESC LIMIT 1\n#SQL: SELECT T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major GROUP BY T1.college ORDER BY COUNT(T2.member_id) DESC LIMIT 1\n```"
    ],
    "535": [
        "```\n#reason: The question want to count how many users have more than 100 upvotes and more than 1 downvote, so the SQL SELECT COUNT(users.Id) and COUNT is used to get the total count of users that meet the criteria.\n#columns: users.Id, users.UpVotes, users.DownVotes\n#values: more than 100 upvotes refers to users.UpVotes > 100, more than 1 downvote refers to users.DownVotes > 1\n#SELECT: SELECT COUNT(users.Id) refer to users.Id\n#SQL-like: Show COUNT(users.Id), WHERE users.UpVotes > 100 AND users.DownVotes > 1\n#SQL: SELECT COUNT(Id) FROM users WHERE UpVotes > 100 AND DownVotes > 1\n```"
    ],
    "239": [
        "```\n#reason: The question wants to count the number of connections for a specific atom, so the SQL SELECT COUNT(bond_id) and GROUP BY atom_id will be used to aggregate the results.\n#columns: connected.bond_id, connected.atom_id\n#values: atom 19 refers to connected.atom_id LIKE 'TR%_19'\n#SELECT: How many connections refers to COUNT(connected.bond_id)\n#SQL-like: Show COUNT(connected.bond_id), WHERE connected.atom_id LIKE 'TR%_19'\n#SQL: SELECT COUNT(bond_id) FROM connected WHERE atom_id LIKE 'TR%_19'\n```"
    ],
    "1400": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage share of events related to 'Community Service' in 2019, so the SQL SELECT will sum the events of that type and divide by the total count of events held in that year.\n#columns: event.type, event.event_date, event.event_id\n#values: 'Community Service' refers to event.type = 'Community Service', 'in 2019' refers to event.event_date BETWEEN '2019-01-01' AND '2019-12-31'\n#SELECT: SELECT percentage share refer to (SUM(type = 'Community Service') / COUNT(event_id)) * 100\n#SQL-like: Show (SUM(type = 'Community Service') / COUNT(event_id)) * 100, WHERE event.event_date BETWEEN '2019-01-01' AND '2019-12-31'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.type = 'Community Service' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.event_id) FROM event AS T1 WHERE T1.event_date BETWEEN '2019-01-01' AND '2019-12-31'\n```"
    ],
    "283": [
        "```\n#reason: The question wants to identify whether the chemical compound that contains Calcium is carcinogenic, so the SQL SELECT will check the presence of Calcium and the label indicating carcinogenicity.\n#columns: molecule.label\n#values: calcium refers to atom.element = 'ca'\n#SELECT: SELECT DISTINCT molecule.label refer to molecule.label\n#SQL-like: Show DISTINCT molecule.label WHERE atom.element = 'ca'\n#SQL: SELECT DISTINCT T2.label FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.element = 'ca'\n```"
    ],
    "38": [
        "```\n#reason: The question requires displaying \"the webpages\" for the \"Los Angeles County school\" that has \"between 2,000 and 3,000 test takers\". The filtering condition involves both the county and the number of test takers.\n#columns: schools.Website, schools.County, satscores.NumTstTakr\n#values: 'Los Angeles County' refers to schools.County = 'Los Angeles', 'between 2,000 and 3,000 test takers' refers to satscores.NumTstTakr BETWEEN 2000 AND 3000\n#SELECT: 'the webpages' refer to schools.Website\n#SQL-like: Show schools.Website, WHERE schools.County = 'Los Angeles' and satscores.NumTstTakr BETWEEN 2000 AND 3000\n#SQL: SELECT schools.Website FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE schools.County = 'Los Angeles' AND satscores.NumTstTakr BETWEEN 2000 AND 3000\n```"
    ],
    "1044": [
        "```\n#reason: The question wants to list the football players with a birthyear of 1970 and a birthmonth of October, so the SQL SELECT will involve filtering players based on their birthday.\n#columns: Player.birthday, Player.player_name\n#values: 'birthyear of 1970' refers to substr(birthday, 1, 4) = '1970' AND 'birthmonth of October' refers to substr(birthday, 6, 2) = '10'\n#SELECT: 'football players' refer to Player.player_name.\n#SQL-like: Show Player.player_name, WHERE substr(birthday, 1, 4) = '1970' AND substr(birthday, 6, 2) = '10'\n#SQL: SELECT Player.player_name FROM Player WHERE substr(birthday, 1, 4) = '1970' AND substr(birthday, 6, 2) = '10'\n```"
    ],
    "1491": [
        "```\n#reason: The question wants to identify the country with the most \"value for money\" gas stations, so the SQL SELECT will count the number of gas stations in each country where the segment is 'Value for money' and group the results by country.\n#columns: gasstations.Country, COUNT(gasstations.GasStationID)\n#values: 'value for money' refers to gasstations.Segment = 'Value for money'\n#SELECT: SELECT gasstations.Country, COUNT(gasstations.GasStationID) refer to total number of \"value for money\" gas stations in each country.\n#SQL-like: Show gasstations.Country, COUNT(gasstations.GasStationID) WHERE gasstations.Segment = 'Value for money' GROUP BY gasstations.Country\n#SQL: SELECT gasstations.Country, COUNT(gasstations.GasStationID) FROM gasstations WHERE gasstations.Segment = 'Value for money' GROUP BY gasstations.Country\n```"
    ],
    "1092": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the league that had the most matches in the 2008/2009 season, so the SQL SELECT will retrieve the league name and count the matches, grouping by league name and filtering for the specified season.\n#columns: League.name, Match.id\n#values: 'in the 2008/2009 season' refer to Match.season = '2008/2009'\n#SELECT: 'the name of the league' refer to League.name\n#SQL-like: Show League.name, WHERE Match.season = '2008/2009', GROUP BY League.name, ORDER BY COUNT(Match.id) DESC LIMIT 1\n#SQL: SELECT T1.name FROM League AS T1 INNER JOIN Match AS T2 ON T1.id = T2.league_id WHERE T2.season = '2008/2009' GROUP BY T1.name ORDER BY COUNT(T2.id) DESC LIMIT 1\n```"
    ],
    "1146": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to get the full name of the away team that scored the most goals, so the SQL SELECT will involve finding the maximum score of the away team and joining the relevant team information.\n#columns: Team.team_long_name, Match.away_team_goal\n#values: scored the most goals refers to MAX(away_team_goal)\n#SELECT: SELECT Team.team_long_name refer to Match.away_team_api_id\n#SQL-like: Show Team.team_long_name, WHERE Match.away_team_goal = (SELECT MAX(away_team_goal) FROM Match)\n#SQL: SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Match AS T2 ON T1.team_api_id = T2.away_team_api_id WHERE T2.away_team_goal = (SELECT MAX(away_team_goal) FROM Match)\n```"
    ],
    "419": [
        "```\n#reason: The question wants to count the number of color cards with no borders that have been ranked higher than 12000 on EDHRec, so the SQL SELECT will count the cards where borderColor is 'borderless' and edhrecRank is greater than 12000.\n#columns: cards.borderColor, cards.edhrecRank\n#values: color cards with no borders refer to cards.borderColor = 'borderless', ranked higher than 12000 on EDHRec refer to cards.edhrecRank > 12000\n#SELECT: How many color cards refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE cards.borderColor = 'borderless' AND cards.edhrecRank > 12000\n#SQL: SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND edhrecRank > 12000\n```"
    ],
    "65": [
        "```\n#reason: The question wants to calculate the ratio in percentage of locally funded schools in Santa Clara County compared to all other types of charter school funding. The SQL SELECT is structured to count locally funded schools and total schools in the county, then compute the percentage.\n#columns: frpm.`Charter Funding Type`, frpm.`County Name`, frpm.`School Name`\n#values: 'locally funded' refers to frpm.`Charter Funding Type` = 'Locally funded', 'Santa Clara County' refers to frpm.`County Name` = 'Santa Clara'\n#SELECT: SELECT (COUNT(CASE WHEN frpm.`Charter Funding Type` = 'Locally funded' THEN 1 END) * 100.0) / COUNT(*) AS percentage\n#SQL-like: SQL-like statements ignoring Join conditions\n#SQL: SELECT CAST(COUNT(CASE WHEN frpm.`Charter Funding Type` = 'Locally funded' THEN 1 END) AS REAL) * 100 / COUNT(*) FROM frpm WHERE frpm.`County Name` = 'Santa Clara'\n```"
    ],
    "816": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question requires displaying \"the names of superheroes\" with attribute values between 75 and 80. \"attribute value between 75 to 80\" is a filtering condition.\n#columns: superhero.superhero_name, hero_attribute.attribute_value\n#values: attribute value between 75 to 80 refer to hero_attribute.attribute_value BETWEEN 75 AND 80\n#SELECT: names of superheroes refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE hero_attribute.attribute_value BETWEEN 75 AND 80\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id WHERE T2.attribute_value BETWEEN 75 AND 80\n```"
    ],
    "326": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the molecule that consists of a Sulphur atom with a double bond, so the SQL SELECT will retrieve the molecule_id where the element is 's' and the bond_type is '='.\n#columns: molecule.molecule_id\n#values: sulphur refers to atom.element = 's', double bond refers to bond.bond_type = '='\n#SELECT: SELECT molecule_id refer to molecule.molecule_id\n#SQL-like: Show molecule.molecule_id, WHERE atom.element = 's' AND bond.bond_type = '='\n#SQL: SELECT DISTINCT T3.molecule_id FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 's' AND T2.bond_type = '='\n```"
    ],
    "1403": [
        "```\n#reason: The question wants to indicate the name of the closed event whose cost has exceeded the budget the most, so the SQL SELECT will filter for closed events and find the event with the minimum remaining budget that is less than zero.\n#columns: event.event_name, budget.remaining\n#values: closed events refer to event.status = 'Closed', exceed the budget the most refers to budget.remaining < 0\n#SELECT: SELECT event_name refer to event.event_name, remaining refer to budget.remaining\n#SQL-like: Show event.event_name, budget.remaining WHERE event.status = 'Closed' AND budget.remaining < 0 ORDER BY budget.remaining ASC LIMIT 1\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.status = 'Closed' AND T2.remaining < 0 ORDER BY T2.remaining ASC LIMIT 1\n```"
    ],
    "1215": [
        "```\n#reason: The question wants to analyze the deviation of total protein (TP) index from the normal for female patients. Therefore, the SQL SELECT will focus on the TP values that exceed the normal range and calculate the deviation from 8.5.\n#columns: Laboratory.TP, Patient.SEX\n#values: female refers to SEX = 'F', total protein (TP) beyond the normal index refers to TP > 8.5\n#SELECT: SUBTRACT(TP, 8.5) refer to Laboratory.TP\n#SQL-like: Show SUBTRACT(Laboratory.TP, 8.5), WHERE Patient.SEX = 'F' AND Laboratory.TP > 8.5\n#SQL: SELECT (T1.TP - 8.5) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.SEX = 'F' AND T1.TP > 8.5\n```"
    ],
    "395": [
        "```\n#reason: Analyze how to generate SQL based on the question. the question wants to count the number of cards designed by UDON and available in mtgo print type has a starting maximum hand size of -1, so the SQL SELECT COUNT(*) will be used along with the necessary filters.\n#columns: cards.id\n#values: 'designed by UDON' refer to cards.artist = 'UDON', 'available in mtgo' refer to cards.availability = 'mtgo', 'starting maximum hand size of -1' refer to cards.hand = '-1'\n#SELECT: SELECT COUNT(*) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(*) WHERE cards.artist = 'UDON' AND cards.availability = 'mtgo' AND cards.hand = '-1'\n#SQL: SELECT COUNT(*) FROM cards WHERE cards.artist = 'UDON' AND cards.availability = 'mtgo' AND cards.hand = '-1'\n```"
    ],
    "468": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the Simplified Chinese translation of the name of the set \"Eighth Edition\", so the SQL SELECT will retrieve the translation where the set name matches and the language is Simplified Chinese.\n#columns: set_translations.translation, sets.name\n#values: 'Eighth Edition' refer to sets.name = 'Eighth Edition', 'Chinese Simplified' refer to set_translations.language = 'Chinese Simplified'\n#SELECT: SELECT set_translations.translation refer to set_translations.translation\n#SQL-like: Show set_translations.translation, WHERE sets.name = 'Eighth Edition' AND set_translations.language = 'Chinese Simplified'\n#SQL: SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'\n```"
    ],
    "126": [
        "```\n#reason: The question wants to calculate the percentage of accounts from the 'Decin' district for all accounts opened in 1993, so the SQL SELECT will count the accounts in 'Decin' and divide by the total accounts opened in 1993, then multiply by 100 for percentage.\n#columns: account.account_id, account.date, district.A2\n#values: 'Decin' refers to district.A2 = 'Decin', 'in 1993' refers to strftime('%Y', account.date) = '1993'\n#SELECT: SELECT CAST(SUM(CASE WHEN district.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(account.account_id) \n#SQL-like: Show CAST(SUM(CASE WHEN district.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(account.account_id), WHERE strftime('%Y', account.date) = '1993'\n#SQL: SELECT CAST(SUM(CASE WHEN D.A2 = 'Decin' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(A.account_id) FROM account AS A INNER JOIN district AS D ON A.district_id = D.district_id WHERE strftime('%Y', A.date) = '1993'\n```"
    ],
    "285": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list chemical elements that form a specific bond (TR001_10_11), so the SQL SELECT will retrieve elements corresponding to the atoms involved in that bond.\n#columns: atom.element\n#values: bond id is 'TR001_10_11' refer to bond.bond_id = 'TR001_10_11'\n#SELECT: SELECT chemical elements refer to atom.element\n#SQL-like: Show atom.element, WHERE bond.bond_id = 'TR001_10_11'\n#SQL: SELECT a.element FROM atom AS a INNER JOIN bond AS b ON SUBSTR(b.bond_id, 1, 5) = a.molecule_id WHERE b.bond_id = 'TR001_10_11' OR SUBSTR(b.bond_id, 7, 2) = a.atom_id OR SUBSTR(b.bond_id, 10, 2) = a.atom_id\n```"
    ],
    "1464": [
        "```\n#reason: The question wants to display the full names of students who received funds on a specific date and the amount received, so the SQL SELECT will include the first name, last name, and amount, with a filter for the date received.\n#columns: member.first_name, member.last_name, income.amount\n#values: 'received funds on the date of 9/9/2019' refer to income.date_received = '2019-09-09'\n#SELECT: SELECT member.first_name, member.last_name, income.amount\n#SQL-like: Show member.first_name, member.last_name, income.amount WHERE income.date_received = '2019-09-09'\n#SQL: SELECT T1.first_name, T1.last_name, T2.amount FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.date_received = '2019-09-09'\n```"
    ],
    "426": [
        "```\n#reason: The question wants to provide the top three sets that do not appear in Magic: The Gathering Online, along with their names in alphabetical order. This translates to a filtering condition where mtgoCode is NULL or mtgoCode = '', and requires ordering the results alphabetically.\n#columns: sets.name, sets.mtgoCode\n#values: don't appear in Magic: The Gathering Online refers to sets.mtgoCode IS NULL OR sets.mtgoCode = ''\n#SELECT: top three sets refers to sets.name\n#SQL-like: Show sets.name WHERE sets.mtgoCode IS NULL OR sets.mtgoCode = '' ORDER BY sets.name ASC LIMIT 3\n#SQL: SELECT sets.name FROM sets WHERE sets.mtgoCode IS NULL OR sets.mtgoCode = '' ORDER BY sets.name ASC LIMIT 3\n```"
    ],
    "1000": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"which racetrack hosted the most recent race\" and \"indicate the full location\", so the SQL SELECT will retrieve the location and country of the circuit associated with the most recent race date.\n#columns: circuits.location, circuits.country\n#values: most recent race refers to MAX(races.date)\n#SELECT: full location refers to circuits.location || ', ' || circuits.country\n#SQL-like: Show circuits.location || ', ' || circuits.country, WHERE races.date = (SELECT MAX(date) FROM races)\n#SQL: SELECT T1.location || ', ' || T1.country FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId ORDER BY T2.date DESC LIMIT 1\n```"
    ],
    "1311": [
        "```\n#reason: The question wants to count the number of patients with severe thrombosis who also have a normal prothrombin time, so the SQL SELECT COUNT(*) will be used, filtering for those conditions.\n#columns: Examination.Thrombosis, Laboratory.PT, Patient.ID\n#values: severe thrombosis refer to Examination.Thrombosis IN (1, 2), normal prothrombin time refer to Laboratory.PT < 14\n#SELECT: how many patients refer to COUNT(*)\n#SQL-like: Show COUNT(*) WHERE Examination.Thrombosis IN (1, 2) AND Laboratory.PT < 14\n#SQL: SELECT COUNT(*) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Patient AS T3 ON T1.ID = T3.ID WHERE T1.Thrombosis IN (1, 2) AND T2.PT < 14\n```"
    ],
    "58": [
        "```\n#reason: The question requires displaying \"the phone number\", \"extension number\", and \"the school's name\". The filtering condition is \"school with the zip code 95203-3704\".\n#columns: schools.Phone, schools.Ext, schools.School\n#values: 'zip code 95203-3704' refer to schools.Zip = '95203-3704'\n#SELECT: \"the phone number\" refers to schools.Phone, \"extension number\" refers to schools.Ext, \"the school's name\" refers to schools.School\n#SQL-like: Show schools.Phone, schools.Ext, schools.School WHERE schools.Zip = '95203-3704'\n#SQL: SELECT Phone, Ext, School FROM schools WHERE Zip = '95203-3704'\n```"
    ],
    "626": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the total number of votes made in the year 2010, so the SQL SELECT will count the votes where the creation date falls within that year.\n#columns: votes.CreationDate\n#values: 'in 2010' refer to strftime('%Y', votes.CreationDate) = '2010'\n#SELECT: SELECT COUNT(*) refer to votes.Id\n#SQL-like: Show COUNT(*) FROM votes WHERE strftime('%Y', votes.CreationDate) = '2010'\n#SQL: SELECT COUNT(*) FROM votes WHERE strftime('%Y', votes.CreationDate) = '2010'\n```"
    ],
    "538": [
        "```\n#reason: The question wants to list the titles of the posts owned by the user csgillespie, so the SQL SELECT will retrieve the titles from the posts table where the owner is identified by the user's display name.\n#columns: posts.Title, users.DisplayName\n#values: 'csgillespie' refers to users.DisplayName = 'csgillespie'\n#SELECT: SELECT posts.Title refer to posts.Title. The order of columns in the SELECT clause must be the same as the order in the question.\n#SQL-like: Show posts.Title, WHERE users.DisplayName = 'csgillespie'\n#SQL: SELECT posts.Title FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie'\n```"
    ],
    "217": [
        "```\n#reason: The question wants to identify all the atoms that are connected to the atoms of the TR181 molecule, so the SQL SELECT will focus on the connected atoms based on the specified molecule_id.\n#columns: connected.atom_id, connected.atom_id2\n#values: TR181 molecule refers to molecule_id = 'TR181'\n#SELECT: SELECT content refers to connected.atom_id and connected.atom_id2\n#SQL-like: Show connected.atom_id, connected.atom_id2 WHERE connected.bond_id IN (SELECT bond.bond_id FROM bond WHERE bond.molecule_id = 'TR181')\n#SQL: SELECT T1.atom_id, T2.atom_id2 FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id2 = T2.atom_id WHERE T1.bond_id IN (SELECT bond.bond_id FROM bond WHERE bond.molecule_id = 'TR181')\n```"
    ],
    "7": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the phone number of the school that has the highest number of test takers with an SAT score of over 1500, so the SQL SELECT will include the phone number and filter based on the number of test takers.\n#columns: schools.Phone, satscores.NumTstTakr\n#values: highest number of test takers with an SAT score of over 1500 refers to satscores.NumTstTakr = (SELECT MAX(satscores.NumTstTakr) FROM satscores WHERE satscores.NumGE1500 > 0)\n#SELECT: SELECT schools.Phone refer to schools.Phone\n#SQL-like: Show schools.Phone WHERE satscores.NumTstTakr = (SELECT MAX(satscores.NumTstTakr) FROM satscores WHERE satscores.NumGE1500 > 0)\n#SQL: SELECT schools.Phone FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE satscores.NumTstTakr = (SELECT MAX(satscores.NumTstTakr) FROM satscores WHERE satscores.NumGE1500 > 0)\n```"
    ],
    "1450": [
        "```\n#reason: The question requires listing the city and country where events have more than forty incomes. \"more than forty incomes\" is a filtering condition.\n#columns: zip_code.city, zip_code.state\n#values: more than forty incomes refers to COUNT(income.income_id) > 40\n#SELECT: city and country refer to zip_code.city and zip_code.state\n#SQL-like: Show zip_code.city, zip_code.state, WHERE COUNT(income.income_id) > 40, GROUP BY zip_code.city, zip_code.state\n#SQL: SELECT T1.city, T2.state FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip GROUP BY T1.city, T2.state HAVING COUNT(T2.income_id) > 40\n```"
    ],
    "562": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the number of comments for a specific post identified by its view count, so the SQL SELECT will count comments from the comments table for the given post ID.\n#columns: comments.PostId, comments.Id\n#values: post with 1910 view counts refer to posts.ViewCount = 1910\n#SELECT: SELECT COUNT(comments.Id) refer to COUNT(comments.Id)\n#SQL-like: Show COUNT(comments.Id), WHERE posts.ViewCount = 1910\n#SQL: SELECT COUNT(c.Id) FROM comments AS c INNER JOIN posts AS p ON c.PostId = p.Id WHERE p.ViewCount = 1910\n```"
    ],
    "1062": [
        "```\n#reason: The question wants to list player names with an overall rating of over 80 from 2008 to 2010, so the SQL SELECT will filter players based on their overall rating and the date range.\n#columns: Player.player_name, Player_Attributes.overall_rating, Player_Attributes.date\n#values: overall_rating > 80 refers to Player_Attributes.overall_rating > 80, from 2008 to 2010 refers to strftime('%Y', Player_Attributes.date) BETWEEN '2008' AND '2010'\n#SELECT: SELECT player names refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.overall_rating > 80 AND strftime('%Y', Player_Attributes.date) BETWEEN '2008' AND '2010'\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.overall_rating > 80 AND strftime('%Y', T2.date) BETWEEN '2008' AND '2010'\n```"
    ],
    "1098": [
        "```\n#reason: The question wants to find Ajax's highest chance creation passing score and its classification, so the SQL SELECT will retrieve the maximum chance creation passing score and its classification for the team named 'Ajax'.\n#columns: Team_Attributes.chanceCreationPassing, Team_Attributes.chanceCreationPassingClass\n#values: 'Ajax' refers to Team.team_long_name = 'Ajax'\n#SELECT: SELECT MAX(Team_Attributes.chanceCreationPassing), Team_Attributes.chanceCreationPassingClass\n#SQL-like: Show MAX(Team_Attributes.chanceCreationPassing), Team_Attributes.chanceCreationPassingClass WHERE Team.team_long_name = 'Ajax'\n#SQL: SELECT MAX(TA.chanceCreationPassing), TA.chanceCreationPassingClass FROM Team AS T INNER JOIN Team_Attributes AS TA ON T.team_api_id = TA.team_api_id WHERE T.team_long_name = 'Ajax'\n```"
    ],
    "585": [
        "```\n#reason: The question wants to calculate the total bounty amount for posts that contain 'data' in their title, so the SQL SELECT will sum the bounty amounts associated with those posts.\n#columns: votes.BountyAmount, posts.Title\n#values: 'about data' refers to posts.Title LIKE '%data%'\n#SELECT: SELECT SUM(votes.BountyAmount) refer to votes.BountyAmount\n#SQL-like: Show SUM(votes.BountyAmount) WHERE posts.Title LIKE '%data%'\n#SQL: SELECT SUM(votes.BountyAmount) FROM votes INNER JOIN posts ON votes.PostId = posts.Id WHERE posts.Title LIKE '%data%'\n```"
    ],
    "1461": [
        "```\n#reason: The question wants to display the last names of students who are enrolled in the 'Elementary Education' major along with their phone numbers, so the SQL SELECT will include the last names from the member table and phone numbers from the same table filtered by the corresponding major name in the major table.\n#columns: member.last_name, member.phone\n#values: 'Elementary Education' refers to major.major_name = 'Elementary Education'\n#SELECT: SELECT member.last_name, member.phone\n#SQL-like: Show member.last_name, member.phone WHERE major.major_name = 'Elementary Education'\n#SQL: SELECT T1.last_name, T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Elementary Education'\n```"
    ],
    "1010": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question want to find the fastest lap time recorded by Lewis Hamilton in a Formula 1 race, so the SQL SELECT will retrieve the fastest lap time associated with his driverId.)\n#columns: lapTimes.time, drivers.driverId\n#values: Lewis Hamilton refers to drivers.driverRef = 'hamilton'\n#SELECT: SELECT the fastest lap time refer to lapTimes.time\n#SQL-like: Show lapTimes.time, WHERE drivers.driverRef = 'hamilton' ORDER BY lapTimes.time ASC LIMIT 1\n#SQL: SELECT T1.time FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.driverRef = 'hamilton' ORDER BY T1.time ASC LIMIT 1\n```"
    ],
    "316": [
        "```\n#reason: The question wants to identify molecules that contain the element \"c\" and are not carcinogenic, so the SQL SELECT will filter based on the element and the label.\n#columns: molecule.molecule_id, molecule.label, atom.element\n#values: 'contain \"c\" element' refers to atom.element = 'c', 'not carcinogenic' refers to molecule.label = '-'\n#SELECT: SELECT molecule.molecule_id, molecule.label, atom.element refer to molecule.molecule_id, molecule.label, atom.element\n#SQL-like: Show molecule.molecule_id, molecule.label, atom.element, WHERE atom.element = 'c' AND molecule.label = '-'\n#SQL: SELECT T1.molecule_id, T1.label, T2.element FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'c' AND T1.label = '-'\n```"
    ],
    "60": [
        "```\n#reason: The question wants to display the websites for all the partially virtual chartered schools located in San Joaquin, so the SQL SELECT will include the website column and apply filters for virtual status and charter status.\n#columns: schools.Website\n#values: 'partially virtual' refer to schools.Virtual = 'P', 'chartered schools' refer to schools.Charter = 1, 'located in San Joaquin' refer to schools.City = 'San Joaquin'\n#SELECT: SELECT schools.Website\n#SQL-like: Show schools.Website WHERE schools.Virtual = 'P' AND schools.Charter = 1 AND schools.City = 'San Joaquin'\n#SQL: SELECT schools.Website FROM schools WHERE schools.Virtual = 'P' AND schools.Charter = 1 AND schools.City = 'San Joaquin'\n```"
    ],
    "1013": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the fastest lap time recorded for the Austrian Grand Prix Circuit, so the SQL SELECT will focus on the lap time associated with the specific race.\n#columns: results.fastestLapTime, races.name\n#values: 'Austrian Grand Prix Circuit' refers to races.name = 'Austrian Grand Prix'\n#SELECT: SELECT fastest lap time refer to results.fastestLapTime\n#SQL-like: Show results.fastestLapTime WHERE races.name = 'Austrian Grand Prix'\n#SQL: SELECT T1.fastestLapTime FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'Austrian Grand Prix'\n```"
    ],
    "586": [
        "```\n#reason: The question wants to identify which user added a specific bounty amount to a post with a title that mentions a certain keyword, so the SQL SELECT will fetch the user's display name based on the bounty amount and post title conditions.\n#columns: users.DisplayName, votes.BountyAmount, posts.Title\n#values: 'bounty amount of 50' refer to votes.BountyAmount = 50, 'title mentioning variance' refer to posts.Title LIKE '%variance%'\n#SELECT: SELECT users.DisplayName\n#SQL-like: Show users.DisplayName WHERE votes.BountyAmount = 50 AND posts.Title LIKE '%variance%'\n#SQL: SELECT users.DisplayName FROM votes INNER JOIN posts ON votes.PostId = posts.Id INNER JOIN users ON votes.UserId = users.Id WHERE votes.BountyAmount = 50 AND posts.Title LIKE '%variance%'\n```"
    ],
    "1475": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of customers in the KAM segment with a consumption of less than 30,000 for the year 2012, so the SQL SELECT will count the distinct CustomerID from the yearmonth table where the consumption is less than 30,000 and the date falls within the specified range.\n#columns: yearmonth.CustomerID, yearmonth.Consumption\n#values: 'in KAM' refers to customers.Segment = 'KAM', 'consumption of less than 30,000' refers to yearmonth.Consumption < 30000, 'for the year 2012' refers to yearmonth.Date BETWEEN '201201' AND '201212'\n#SELECT: SELECT COUNT(DISTINCT yearmonth.CustomerID) refer to yearmonth.CustomerID\n#SQL-like: Show COUNT(DISTINCT yearmonth.CustomerID), WHERE yearmonth.Consumption < 30000 AND yearmonth.Date BETWEEN '201201' AND '201212' AND customers.Segment = 'KAM'\n#SQL: SELECT COUNT(DISTINCT yearmonth.CustomerID) FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE yearmonth.Consumption < 30000 AND yearmonth.Date BETWEEN '201201' AND '201212' AND customers.Segment = 'KAM'\n```"
    ],
    "1119": [
        "```\n#reason: The question wants to count the number of home team goals scored by Aaron Lennon, so the SQL SELECT will count the occurrences of home team goals where the player's name is 'Aaron Lennon'.\n#columns: Match.home_team_goal, Player.player_name\n#values: 'Aaron Lennon' refers to Player.player_name = 'Aaron Lennon'\n#SELECT: How many home team goals refer to COUNT(Match.home_team_goal)\n#SQL-like: Show COUNT(Match.home_team_goal), WHERE Player.player_name = 'Aaron Lennon'\n#SQL: SELECT COUNT(Match.home_team_goal) FROM Match INNER JOIN Player ON Match.home_player_1 = Player.player_api_id OR Match.home_player_2 = Player.player_api_id OR Match.home_player_3 = Player.player_api_id OR Match.home_player_4 = Player.player_api_id OR Match.home_player_5 = Player.player_api_id OR Match.home_player_6 = Player.player_api_id OR Match.home_player_7 = Player.player_api_id OR Match.home_player_8 = Player.player_api_id OR Match.home_player_9 = Player.player_api_id OR Match.home_player_10 = Player.player_api_id OR Match.home_player_11 = Player.player_api_id WHERE Player.player_name = 'Aaron Lennon'\n```"
    ],
    "47": [
        "```\n#reason: The question wants to find the average number of schools that opened monthly in 1980, focusing on the schools under the jurisdiction of the Elementary School District. So the SQL SELECT will count the schools that opened in 1980 and divide the count by 12 to get the monthly average.\n#columns: schools.OpenDate, schools.DOC\n#values: 'under the jurisdiction of the Elementary School District' refers to schools.DOC = '52', 'in 1980' refers to strftime('%Y', schools.OpenDate) = '1980'\n#SELECT: 'monthly average number of schools' refers to COUNT(schools.OpenDate) / 12\n#SQL-like: Show COUNT(schools.OpenDate) / 12, WHERE schools.DOC = '52' AND strftime('%Y', schools.OpenDate) = '1980'\n#SQL: SELECT COUNT(schools.OpenDate) / 12.0 FROM schools WHERE schools.DOC = '52' AND strftime('%Y', schools.OpenDate) = '1980'\n```"
    ],
    "852": [
        "```\n#reason: The question wants to count the number of races held in the year 2010 that are not in Asia or Europe, so the SQL SELECT will count races where the condition is determined by the country of the circuits.\n#columns: races.raceId, circuits.country\n#values: the year 2010 refers to races.year = 2010; outside Asia and Europe refers to 'Asia' not in circuits.country AND 'Europe' not in circuits.country\n#SELECT: SELECT COUNT(races.raceId) refer to COUNT(races.raceId)\n#SQL-like: Show COUNT(races.raceId), WHERE races.year = 2010 AND circuits.country NOT IN ('Asia', 'Europe')\n#SQL: SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T1.year = 2010 AND T2.country NOT IN ('Asia', 'Europe')\n```"
    ],
    "1196": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to identify the most common symptom associated with SLE disease, so the SQL SELECT will retrieve symptoms related to patients diagnosed with SLE and aggregate them to find the maximum count.)\n#columns: Examination.Symptoms, Examination.Diagnosis\n#values: 'SLE' refers to Examination.Diagnosis = 'SLE'\n#SELECT: SELECT Symptoms refer to Examination.Symptoms\n#SQL-like: Show Examination.Symptoms, Group By Examination.Symptoms, Order By COUNT(Examination.Symptoms) DESC LIMIT 1\n#SQL: SELECT Examination.Symptoms FROM Examination WHERE Examination.Diagnosis = 'SLE' GROUP BY Examination.Symptoms ORDER BY COUNT(Examination.Symptoms) DESC LIMIT 1\n```"
    ],
    "1468": [
        "```\n#reason: The question wants to display the hometown of Garrett Gerke, so the SQL SELECT will retrieve the city where the member named Garrett Gerke resides.\n#columns: zip_code.city\n#values: 'Garrett Gerke' refer to member.first_name = 'Garrett' AND member.last_name = 'Gerke'\n#SELECT: hometown refer to zip_code.city\n#SQL-like: Show zip_code.city, WHERE member.first_name = 'Garrett' AND member.last_name = 'Gerke'\n#SQL: SELECT T1.city FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T2.first_name = 'Garrett' AND T2.last_name = 'Gerke'\n```"
    ],
    "525": [
        "```\n#reason: The question wants to find the uuid of cards in which the old school format is restricted or banned, so the SQL SELECT will focus on retrieving the uuid by filtering on the format and status.\n#columns: cards.uuid, legalities.format, legalities.status\n#values: 'old school format' refers to legalities.format = 'oldschool', 'restricted or banned' refers to legalities.status IN ('Banned', 'Restricted')\n#SELECT: SELECT cards.uuid refer to cards.uuid\n#SQL-like: Show cards.uuid, WHERE legalities.format = 'oldschool' AND legalities.status IN ('Banned', 'Restricted')\n#SQL: SELECT cards.uuid FROM legalities INNER JOIN cards ON legalities.uuid = cards.uuid WHERE legalities.format = 'oldschool' AND legalities.status IN ('Banned', 'Restricted')\n```"
    ],
    "1082": [
        "```\n#reason: The question requires displaying \"leagues from Germany\". \"Germany\" is a filtering condition.\n#columns: League.name, Country.name\n#values: Germany refers to Country.name = 'Germany'\n#SELECT: leagues refer to League.name\n#SQL-like: Show League.name, WHERE Country.name = 'Germany'\n#SQL: SELECT T1.name FROM League AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T2.name = 'Germany'\n```"
    ],
    "1511": [
        "```\n#reason: The question requires displaying the \"average total price\" of the transactions for customers who paid in euro. The average total price is calculated using AVG(total price), which is derived from the product of Amount and Price. The filtering condition is customers.Currency = 'EUR'.\n#columns: transactions_1k.Price, transactions_1k.Amount, customers.Currency\n#values: 'paid in the euro' refers to customers.Currency = 'EUR'\n#SELECT: average total price refers to AVG(transactions_1k.Amount * transactions_1k.Price)\n#SQL-like: Show AVG(transactions_1k.Amount * transactions_1k.Price) WHERE customers.Currency = 'EUR'\n#SQL: SELECT AVG(T1.Amount * T1.Price) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR'\n```"
    ],
    "1330": [
        "```\n#reason: The question wants to identify the college that offers the major linked to the member named \"Tyler Hewitt\", so the SQL SELECT will target the college from the major table by joining with the member table based on the major's unique identifier.\n#columns: major.college, member.first_name, member.last_name\n#values: 'Tyler Hewitt' refers to member.first_name = 'Tyler' AND member.last_name = 'Hewitt'\n#SELECT: SELECT major.college\n#SQL-like: Show major.college WHERE member.first_name = 'Tyler' AND member.last_name = 'Hewitt'\n#SQL: SELECT M.college FROM major AS M INNER JOIN member AS M2 ON M.major_id = M2.link_to_major WHERE M2.first_name = 'Tyler' AND M2.last_name = 'Hewitt'\n```"
    ],
    "1309": [
        "```\n#reason: The question wants to list a patient's platelet level if it is within the normal range and if he or she is diagnosed with MCTD. The SQL SELECT will retrieve the platelet level where the platelet values are within the specified range and match the diagnosis condition stated.\n#columns: Laboratory.PLT, Patient.Diagnosis\n#values: platelet level is within the normal range refer to Laboratory.PLT > 100 AND Laboratory.PLT < 400, diagnosed with MCTD refers to Patient.Diagnosis = 'MCTD'\n#SELECT: platelet level refer to Laboratory.PLT\n#SQL-like: Show Laboratory.PLT WHERE Laboratory.PLT > 100 AND Laboratory.PLT < 400 AND Patient.Diagnosis = 'MCTD'\n#SQL: SELECT T1.PLT FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.PLT > 100 AND T1.PLT < 400 AND T2.Diagnosis = 'MCTD'\n```"
    ],
    "385": [
        "```\n#reason: The question wants to retrieve the ruling associated with the card named 'Beacon of Immortality', so the SQL SELECT will focus on the ruling text from the rulings table where the card name matches.\n#columns: rulings.text\n#values: 'Beacon of Immortality' refers to cards.name = 'Beacon of Immortality'\n#SELECT: SELECT rulings.text\n#SQL-like: Show rulings.text WHERE cards.name = 'Beacon of Immortality'\n#SQL: SELECT T1.text FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Beacon of Immortality'\n```"
    ],
    "1398": [
        "```\n#reason: The question wants to find the event with the highest amount spent on advertisement, so the SQL SELECT will retrieve the event name corresponding to the maximum spent amount filtered by the category 'Advertisement'.\n#columns: event.event_name, budget.spent\n#values: 'amount spent on advertisement' refers to budget.category = 'Advertisement'\n#SELECT: SELECT event.event_name refer to event.event_name\n#SQL-like: Show event.event_name, WHERE budget.category = 'Advertisement', ORDER BY budget.spent DESC LIMIT 1\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Advertisement' ORDER BY T2.spent DESC LIMIT 1\n```"
    ],
    "528": [
        "```\n#reason: The question wants to list the names of all the cards in the set \"Hour of Devastation\" and find the formats in which these cards are legal, so the SQL SELECT will include the card names and the legal formats, with filtering conditions based on the set name and legal status.\n#columns: sets.name, cards.name, legalities.status, legalities.format\n#values: 'Hour of Devastation' refers to sets.name = 'Hour of Devastation', 'Legal' refers to legalities.status = 'Legal'\n#SELECT: SELECT cards.name, legalities.format refer to cards.name, legalities.format\n#SQL-like: Show cards.name, legalities.format WHERE sets.name = 'Hour of Devastation' AND legalities.status = 'Legal'\n#SQL: SELECT cards.name, legalities.format FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid INNER JOIN sets ON legalities.uuid = cards.uuid WHERE sets.name = 'Hour of Devastation' AND legalities.status = 'Legal'\n```"
    ],
    "1463": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the event names which were budgeted for the food, so the SQL SELECT will pull the event names where the budget category is 'Food'.\n#columns: Event.event_name, Budget.category\n#values: budgeted for food refer to Budget.category = 'Food'\n#SELECT: SELECT event names refer to Event.event_name\n#SQL-like: Show Event.event_name, WHERE Budget.category = 'Food'\n#SQL: SELECT T1.event_name FROM Event AS T1 INNER JOIN Budget AS T2 ON T1.event_id = T2.link_to_event WHERE T2.category = 'Food'\n```"
    ],
    "1472": [
        "```\n#reason: The question requires identifying the entity with the least consumption in the segment LAM for the year 2012. Thus, we need to filter the year from the date and find the minimum consumption.\n#columns: yearmonth.CustomerID, yearmonth.Consumption\n#values: 'in LAM' refer to customers.Segment = 'LAM', 'in 2012' refer to yearmonth.Date BETWEEN '201201' AND '201212'\n#SELECT: SELECT yearmonth.CustomerID, yearmonth.Consumption\n#SQL-like: Show CustomerID, Consumption WHERE Segment = 'LAM' AND Date BETWEEN '201201' AND '201212' ORDER BY Consumption LIMIT 1\n#SQL: SELECT yearmonth.CustomerID, yearmonth.Consumption FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE customers.Segment = 'LAM' AND yearmonth.Date BETWEEN '201201' AND '201212' ORDER BY yearmonth.Consumption LIMIT 1\n```"
    ],
    "417": [
        "```\n#reason: The question wants to calculate the percentage of Japanese translated sets that are expansion sets, so the SQL SELECT will count the number of sets where the language is 'Japanese' and divide it by the total count of sets, multiplying by 100 to get the percentage.\n#columns: sets.type, set_translations.language\n#values: 'Japanese translated' refer to set_translations.language = 'Japanese', 'expansion sets' refer to sets.type = 'expansion'\n#SELECT: SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) refer to sets.type\n#SQL-like: Show CAST(SUM(CASE WHEN set_translations.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*), WHERE sets.type = 'expansion'\n#SQL: SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'\n```"
    ],
    "1469": [
        "```\n#reason: The question wants to find the student with a specific hometown and zip code, so the SQL SELECT will identify the student based on their first name, last name, and position using appropriate filters for city and state.\n#columns: member.first_name, member.last_name, member.position\n#values: hometown of Lincolnton, North Carolina refers to zip_code.city = 'Lincolnton' AND zip_code.state = 'North Carolina'\n#SELECT: SELECT member.first_name, member.last_name, member.position\n#SQL-like: Show member.first_name, member.last_name, member.position WHERE zip_code.city = 'Lincolnton' AND zip_code.state = 'North Carolina'\n#SQL: SELECT T1.first_name, T1.last_name, T1.position FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.city = 'Lincolnton' AND T2.state = 'North Carolina'\n```"
    ],
    "1137": [
        "```\n#reason: The question wants to determine the percentage of players with both strength and stamina scores above 80, so the SQL SELECT will count the players meeting these criteria and divide by the total number of players.\n#columns: Player_Attributes.stamina, Player_Attributes.strength\n#values: strength and stamina score of more than 80 refer to Player_Attributes.stamina > 80 AND Player_Attributes.strength > 80\n#SELECT: percentage of players refer to CAST(COUNT(CASE WHEN Player_Attributes.stamina > 80 AND Player_Attributes.strength > 80 THEN 1 END) AS REAL) * 100 / COUNT(*)\n#SQL-like: Show CAST(COUNT(CASE WHEN Player_Attributes.stamina > 80 AND Player_Attributes.strength > 80 THEN 1 END) AS REAL) * 100 / COUNT(*)\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.stamina > 80 AND T1.strength > 80 THEN 1 END) AS REAL) * 100 / COUNT(*) FROM Player_Attributes AS T1\n```"
    ],
    "964": [
        "```\n#reason: The question requires listing the \"code for drivers\" who have \"nationality in America\". The \"code\" refers to drivers.code, and \"nationality in America\" is defined by the condition drivers.nationality = 'American'.\n#columns: drivers.code, drivers.nationality\n#values: nationality in America refers to drivers.nationality = 'American'\n#SELECT: code for drivers refers to drivers.code\n#SQL-like: Show drivers.code, WHERE drivers.nationality = 'American'\n#SQL: SELECT drivers.code FROM drivers WHERE drivers.nationality = 'American'\n```"
    ],
    "1180": [
        "```\n#reason: The question wants to determine the sex of the patient whose ALT glutamic pyruvic transaminase status was 9 on 1992-06-12, so the SQL SELECT will filter based on the GPT value and the date.\n#columns: Patient.SEX, Laboratory.GPT, Laboratory.Date\n#values: 'on 1992-6-12' refers to Laboratory.Date = '1992-06-12', 'ALT glutamic pyruvic transaminase status got 9' refers to Laboratory.GPT = 9\n#SELECT: SELECT Patient.SEX refer to Patient.SEX\n#SQL-like: Show Patient.SEX, WHERE Laboratory.GPT = 9 AND Laboratory.Date = '1992-06-12'\n#SQL: SELECT T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GPT = 9 AND T2.Date = '1992-06-12'\n```"
    ],
    "1256": [
        "```\n#reason: The question wants to count how many patients have an abnormal C-reactive protein and do not have their data recorded, so the SQL SELECT will count the patients based on the specified conditions.\n#columns: Patient.ID, Laboratory.CRP, Patient.Description\n#values: abnormal C-reactive protein refers to Laboratory.CRP = '+', don't have data recorded refers to Patient.Description IS NULL\n#SELECT: How many patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID) WHERE Laboratory.CRP = '+' AND Patient.Description IS NULL\n#SQL: SELECT COUNT(Patient.ID) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.CRP = '+' AND Patient.Description IS NULL\n```"
    ],
    "903": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to know \"how many times\" Michael Schumacher won from races hosted in Sepang International Circuit, so the SQL SELECT will focus on counting the maximum points he achieved in those races.\n#columns: results.points, races.name, circuits.name, drivers.driverRef\n#values: 'Michael Schumacher' refers to drivers.driverRef = 'michael_schumacher' and 'Sepang International Circuit' refers to circuits.name = 'Sepang International Circuit'\n#SELECT: SELECT COUNT(results.points) refer to results.points\n#SQL-like: Show COUNT(results.points), WHERE drivers.driverRef = 'michael_schumacher' AND circuits.name = 'Sepang International Circuit'\n#SQL: SELECT COUNT(T1.points) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId INNER JOIN drivers AS T4 ON T1.driverId = T4.driverId WHERE T4.driverRef = 'michael_schumacher' AND T3.name = 'Sepang International Circuit'\n```"
    ],
    "1158": [
        "```\n#reason: The question wants to list all patients who were born in 1937 and whose total cholesterol was beyond the normal range, so the SQL SELECT will focus on filtering patients by their birth year and cholesterol values.\n#columns: Patient.Birthday, Laboratory.`T-CHO`\n#values: born in 1937 refers to strftime('%Y', Patient.Birthday) = '1937', total cholesterol was beyond the normal range refers to Laboratory.`T-CHO` >= 250\n#SELECT: SELECT * refer to Patient.Birthday, Laboratory.`T-CHO`\n#SQL-like: Show * WHERE strftime('%Y', Patient.Birthday) = '1937' AND Laboratory.`T-CHO` >= 250\n#SQL: SELECT Patient.Birthday, Laboratory.`T-CHO` FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', Patient.Birthday) = '1937' AND Laboratory.`T-CHO` >= 250\n```"
    ],
    "638": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the names of users that obtained the Organizer Badges, so the SQL SELECT will include users' DisplayName where badges.Name = 'Organizer'.\n#columns: users.DisplayName, badges.Name\n#values: Organizer Badges refer to badges.Name = 'Organizer'\n#SELECT: SELECT users.DisplayName\n#SQL-like: Show users.DisplayName WHERE badges.Name = 'Organizer'\n#SQL: SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Organizer'\n```"
    ],
    "1481": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the difference in annual average consumption between customer segments (SME, LAM, KAM) for those with the least consumption in 2013. The SQL SELECT includes calculations for annual averages and differences between segment averages.\n#columns: yearmonth.Consumption, yearmonth.CustomerID, customers.Segment\n#values: 'in 2013' refers to \"yearmonth.Date BETWEEN '201301' AND '201312'\"\n#SELECT: SELECT the difference in annual average consumption between SME and LAM, LAM and KAM, and KAM and SME refer to the calculated averages.\n#SQL-like: Show (CAST(SUM(CASE WHEN customers.Segment = 'SME' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'SME' THEN yearmonth.CustomerID END)) - (CAST(SUM(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.CustomerID END)), (CAST(SUM(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.CustomerID END)) - (CAST(SUM(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.CustomerID END)), (CAST(SUM(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.CustomerID END)) - (CAST(SUM(CASE WHEN customers.Segment = 'SME' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'SME' THEN yearmonth.CustomerID END)), WHERE yearmonth.Date BETWEEN '201301' AND '201312'\n#SQL: SELECT (CAST(SUM(CASE WHEN customers.Segment = 'SME' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'SME' THEN yearmonth.CustomerID END)) - (CAST(SUM(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.CustomerID END)), (CAST(SUM(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'LAM' THEN yearmonth.CustomerID END)) - (CAST(SUM(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.CustomerID END)), (CAST(SUM(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'KAM' THEN yearmonth.CustomerID END)) - (CAST(SUM(CASE WHEN customers.Segment = 'SME' THEN yearmonth.Consumption END) AS REAL) / COUNT(CASE WHEN customers.Segment = 'SME' THEN yearmonth.CustomerID END)) FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE yearmonth.Date BETWEEN '201301' AND '201312'\n```"
    ],
    "740": [
        "```\n#reason: The question wants to count the number of female superheroes who have a strength attribute value of 100, so the SQL SELECT will use COUNT(superhero.id) with the appropriate filtering conditions.\n#columns: superhero.id, gender.gender, hero_attribute.attribute_value, attribute.attribute_name\n#values: female refers to gender.gender = 'Female', strength value of 100 refers to attribute.attribute_name = 'Strength' AND hero_attribute.attribute_value = 100\n#SELECT: SELECT COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE gender.gender = 'Female' AND attribute.attribute_name = 'Strength' AND hero_attribute.attribute_value = 100\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN hero_attribute AS T3 ON T1.id = T3.hero_id INNER JOIN attribute AS T4 ON T3.attribute_id = T4.id WHERE T2.gender = 'Female' AND T4.attribute_name = 'Strength' AND T3.attribute_value = 100\n```"
    ],
    "1015": [
        "```\n#reason: The question wants to find the Formula_1 race where the lap record for the Austrian Grand Prix Circuit was set, so the SQL SELECT will retrieve the race name and the fastest lap time for that circuit.\n#columns: races.name, results.fastestLapTime\n#values: 'Austrian Grand Prix Circuit' refers to circuits.name = 'Austrian Grand Prix Circuit'\n#SELECT: SELECT races.name, results.fastestLapTime\n#SQL-like: Show races.name, results.fastestLapTime, WHERE circuits.name = 'Austrian Grand Prix Circuit'\n#SQL: SELECT T1.name, T2.fastestLapTime FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T1.circuitId = T3.circuitId WHERE T3.name = 'Austrian Grand Prix Circuit' ORDER BY T2.fastestLapTime ASC LIMIT 1\n```"
    ],
    "1050": [
        "```\n#reason: The question wants to display the \"preferred foot when attacking\" of the \"youngest football player\". \"youngest football player\" is determined by the latest birthday, and \"preferred foot when attacking\" refers to the column preferred_foot.\n#columns: Player.player_name, Player.birthday, Player_Attributes.preferred_foot\n#values: youngest football player refers to MAX(Player.birthday)\n#SELECT: SELECT preferred_foot FROM Player INNER JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id ORDER BY Player.birthday DESC LIMIT 1\n#SQL-like: Show Player_Attributes.preferred_foot WHERE ordered by Player.birthday DESC LIMIT 1\n#SQL: SELECT Player_Attributes.preferred_foot FROM Player INNER JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id ORDER BY Player.birthday DESC LIMIT 1\n```"
    ],
    "304": [
        "```\n#reason: The question wants to list all carcinogenic molecules and their elements, so the SQL SELECT will include the molecule's label and the corresponding elements.\n#columns: molecule.label, atom.element\n#values: label = '+' refers to molecule.label = '+'\n#SELECT: SELECT molecule.label, atom.element\n#SQL-like: Show molecule.label, atom.element WHERE molecule.label = '+'\n#SQL: SELECT T1.label, T2.element FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+'\n```"
    ],
    "454": [
        "```\n#reason: The question want to count how many cards have a white border color and unknown power, so the SQL SELECT COUNT(cards.id) and COUNT is used for calculating the total number of cards that meet the criteria.\n#columns: cards.id, cards.borderColor, cards.power\n#values: 'white border color' refers to cards.borderColor = 'white'; 'unknown power' refers to cards.power = '*' OR cards.power IS NULL\n#SELECT: SELECT COUNT(cards.id) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id), WHERE cards.borderColor = 'white' AND (cards.power = '*' OR cards.power IS NULL)\n#SQL: SELECT COUNT(cards.id) FROM cards WHERE cards.borderColor = 'white' AND (cards.power = '*' OR cards.power IS NULL)\n```"
    ],
    "727": [
        "```\n#reason: The question wants to display the publisher of a superhero identified by the name 'Sauron'. This requires the publisher_name from the publisher table, linked to the superhero table through the publisher_id.\n#columns: publisher.publisher_name, superhero.publisher_id\n#values: 'Sauron' refers to superhero.superhero_name = 'Sauron'\n#SELECT: publisher refers to publisher.publisher_name\n#SQL-like: Show publisher.publisher_name WHERE superhero.superhero_name = 'Sauron'\n#SQL: SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Sauron'\n```"
    ],
    "1382": [
        "```\n#reason: The question wants to find the students who majored in interior design and attended the Community Theater event, so the SQL SELECT will gather names from the member table and relevant event information from the attendance table.\n#columns: member.first_name, member.last_name, event.event_name\n#values: 'majored in interior design' refer to 'major.major_name = 'Interior Design'', 'Community Theater' refer to 'event.event_name = 'Community Theater''\n#SELECT: SELECT first name and last name of students who majored in interior design and attended the Community Theater event refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, WHERE major.major_name = 'Interior Design' AND attendance.link_to_event = event.event_id AND event.event_name = 'Community Theater'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.link_to_major = (SELECT major_id FROM major WHERE major_name = 'Interior Design') AND T3.event_name = 'Community Theater'\n```"
    ],
    "1385": [
        "```\n#reason: The question requires displaying \"Which student\" with \"generate income more than $40\". The filtering condition is \"income more than $40\".\n#columns: member.first_name, member.last_name, income.amount\n#values: generate income more than $40 refers to income.amount > 40\n#SELECT: SELECT full name of students refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, WHERE income.amount > 40\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN income AS T2 ON T1.member_id = T2.link_to_member WHERE T2.amount > 40\n```"
    ],
    "105": [
        "```\n#reason: The question wants to find the district Id of the branch where the loan was approved on a specific date, so the SQL SELECT will retrieve the district_id from the account table by joining it with the loan table based on account_id and filtering by the loan date.\n#columns: account.district_id, loan.date\n#values: 'approved in 1994/8/25' refer to loan.date = '1994-08-25'\n#SELECT: SELECT account.district_id refer to account.district_id\n#SQL-like: Show account.district_id WHERE loan.date = '1994-08-25'\n#SQL: SELECT T1.district_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.date = '1994-08-25'\n```"
    ],
    "637": [
        "```\n#reason: The question wants to list all the tags used by a specific user in their posts that do not have comments, so the SQL SELECT will include the relevant tags and apply filtering for the user and comment count.\n#columns: tags.TagName, posts.CommentCount, users.DisplayName\n#values: used by Mark Meckes refers to users.DisplayName = 'Mark Meckes', doesn't have comments refers to posts.CommentCount = 0\n#SELECT: tags refer to tags.TagName\n#SQL-like: Show tags.TagName WHERE users.DisplayName = 'Mark Meckes' AND posts.CommentCount = 0\n#SQL: SELECT T3.TagName FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id INNER JOIN users AS T3 ON T2.OwnerUserId = T3.Id WHERE T3.DisplayName = 'Mark Meckes' AND T2.CommentCount = 0\n```"
    ],
    "1234": [
        "```\n#reason: The question wants to list the patient ID, sex, and birthday of patients who have an abnormal white blood cell count, so the SQL SELECT will include these columns and filter based on the abnormal WBC values.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday\n#values: abnormal white blood cell count refers to Laboratory.WBC <= 3.5 or Laboratory.WBC >= 9.0\n#SELECT: SELECT Patient.ID, Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Birthday WHERE Laboratory.WBC <= 3.5 OR Laboratory.WBC >= 9.0 GROUP BY Patient.SEX ORDER BY strftime('%Y', 'now') - strftime('%Y', Patient.Birthday) ASC\n#SQL: SELECT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.WBC <= 3.5 OR T2.WBC >= 9.0 GROUP BY T1.SEX ORDER BY (strftime('%Y', 'now') - strftime('%Y', T1.Birthday)) ASC\n```"
    ],
    "720": [
        "```\n#reason: The question requires displaying \"the full names of all the superheroes\" with a filtering condition of having \"over 15 super powers\". This means we need to count the number of superpowers associated with each superhero and filter those with a count greater than 15.\n#columns: superhero.full_name\n#values: over 15 super powers refers to COUNT(superpower.id) > 15\n#SELECT: SELECT superhero.full_name\n#SQL-like: Show superhero.full_name, WHERE COUNT(superpower.id) > 15 GROUP BY superhero.id\n#SQL: SELECT T1.full_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id GROUP BY T1.id HAVING COUNT(T2.power_id) > 15\n```"
    ],
    "1496": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the client segment that consumed the least in September 2013, so the SQL SELECT will focus on the client segment and the total consumption for that month.\n#columns: yearmonth.CustomerID, yearmonth.Consumption, customers.Segment\n#values: September 2013 refers to yearmonth.Date = '201309'\n#SELECT: SELECT customers.Segment, SUM(yearmonth.Consumption) AS TotalConsumption refer to yearmonth.Consumption\n#SQL-like: Show customers.Segment, SUM(yearmonth.Consumption) WHERE yearmonth.Date = '201309' GROUP BY customers.Segment ORDER BY TotalConsumption ASC LIMIT 1\n#SQL: SELECT customers.Segment FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE yearmonth.Date = '201309' GROUP BY customers.Segment ORDER BY SUM(yearmonth.Consumption) ASC LIMIT 1\n```"
    ],
    "882": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the first year the Singapore Grand Prix was held, so the SQL SELECT will retrieve the minimum year from the races table where the race name is 'Singapore Grand Prix'.\n#columns: races.year\n#values: 'Singapore Grand Prix' refer to races.name = 'Singapore Grand Prix'\n#SELECT: SELECT the first year refer to races.year\n#SQL-like: Show MIN(year) WHERE name = 'Singapore Grand Prix'\n#SQL: SELECT MIN(year) FROM races WHERE name = 'Singapore Grand Prix'\n```"
    ],
    "926": [
        "```\n#reason: The question wants to retrieve the \"fastest lap time ever in a race for Lewis Hamilton\", so the SQL SELECT will focus on finding the minimum fastest lap time associated with Lewis Hamilton.\n#columns: results.fastestLapTime, drivers.driverId\n#values: 'for Lewis Hamilton' refers to drivers.driverRef = 'hamilton'\n#SELECT: SELECT fastestLapTime refer to results.fastestLapTime\n#SQL-like: Show fastestLapTime WHERE drivers.driverRef = 'hamilton' ORDER BY fastestLapTime ASC LIMIT 1\n#SQL: SELECT MIN(T1.fastestLapTime) FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.driverRef = 'hamilton'\n```"
    ],
    "289": [
        "```\n#reason: The question wants to determine if molecule TR151 is carcinogenic, so the SQL SELECT will check the label of the molecule.\n#columns: molecule.label, molecule.molecule_id\n#values: 'TR151 is carcinogenic' refer to molecule.molecule_id = 'TR151'\n#SELECT: SELECT content (format: 'Is carcinogenic' refer to molecule.label)\n#SQL-like: Show molecule.label WHERE molecule.molecule_id = 'TR151'\n#SQL: SELECT T1.label FROM molecule AS T1 WHERE T1.molecule_id = 'TR151'\n```"
    ],
    "1195": [
        "```\n#reason: The question wants to find the average blood albumin level for female patients with a PLT greater than 400 who have been diagnosed with SLE, so the SQL SELECT will calculate AVG(ALB) from the Laboratory table, filtering by SEX, PLT, and Diagnosis.\n#columns: Laboratory.ALB, Patient.SEX, Laboratory.PLT, Patient.Diagnosis\n#values: female refers to SEX = 'F', PLT greater than 400 refers to PLT > 400, diagnosed with SLE refers to Diagnosis = 'SLE'\n#SELECT: average blood albumin level refers to AVG(Laboratory.ALB)\n#SQL-like: Show AVG(Laboratory.ALB) WHERE Patient.SEX = 'F' AND Laboratory.PLT > 400 AND Patient.Diagnosis = 'SLE'\n#SQL: SELECT AVG(Laboratory.ALB) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.SEX = 'F' AND Laboratory.PLT > 400 AND Patient.Diagnosis = 'SLE'\n```"
    ],
    "1162": [
        "```\n#reason: The question wants to identify how many female patients came to the hospital in 1997 and were immediately followed at the outpatient clinic, so the SQL SELECT will count the number of patients where the sex is female, the year of the first recorded date is 1997, and the admission status indicates they were followed at the outpatient clinic.\n#columns: Patient.SEX, Patient.Description, Patient.Admission\n#values: female refers to Patient.SEX = 'F', came at the hospital in 1997 refers to strftime('%Y', Patient.Description) = '1997', immediately followed at the outpatient clinic refers to Patient.Admission = '-'\n#SELECT: How many female patients refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Patient.SEX = 'F' AND strftime('%Y', Patient.Description) = '1997' AND Patient.Admission = '-'\n#SQL: SELECT COUNT(Patient.ID) FROM Patient WHERE Patient.SEX = 'F' AND strftime('%Y', Patient.Description) = '1997' AND Patient.Admission = '-'\n```"
    ],
    "1107": [
        "```\n#reason: The question wants to find the first date when Kevin Constant had his highest crossing score, so the SQL SELECT will retrieve the date corresponding to the maximum crossing score for Kevin Constant.\n#columns: Player.player_name, Player_Attributes.crossing, Player_Attributes.date\n#values: 'Kevin Constant' refer to Player.player_name = 'Kevin Constant'\n#SELECT: SELECT MIN(Player_Attributes.date) referring to the date where Player_Attributes.crossing = (SELECT MAX(Player_Attributes.crossing) FROM Player_Attributes WHERE Player_Attributes.player_api_id = (SELECT Player.player_api_id FROM Player WHERE Player.player_name = 'Kevin Constant'))\n#SQL-like: Show MIN(Player_Attributes.date) WHERE Player_Attributes.crossing = (SELECT MAX(Player_Attributes.crossing) WHERE Player_Attributes.player_api_id = (SELECT Player.player_api_id FROM Player WHERE Player.player_name = 'Kevin Constant'))\n#SQL: SELECT MIN(Player_Attributes.date) FROM Player_Attributes WHERE Player_Attributes.crossing = (SELECT MAX(Player_Attributes.crossing) FROM Player_Attributes WHERE Player_Attributes.player_api_id = (SELECT Player.player_api_id FROM Player WHERE Player.player_name = 'Kevin Constant'))\n```"
    ],
    "1110": [
        "```\n#reason: The question wants to identify the \"build Up play passing class\" for the team \"FC Lorient\" on the specified date. Therefore, the SQL SELECT statement will need to retrieve the relevant class from the Team_Attributes table based on the given team name and date.\n#columns: Team.team_long_name, Team_Attributes.buildUpPlayPassingClass, Team_Attributes.date\n#values: 'FC Lorient' refer to Team.team_long_name = 'FC Lorient', 'on 2010/2/22' refer to Team_Attributes.date LIKE '2010-02-22%'\n#SELECT: SELECT buildUpPlayPassingClass refer to Team_Attributes.buildUpPlayPassingClass\n#SQL-like: Show buildUpPlayPassingClass WHERE Team.team_long_name = 'FC Lorient' AND Team_Attributes.date LIKE '2010-02-22%'\n#SQL: SELECT T2.buildUpPlayPassingClass FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T1.team_long_name = 'FC Lorient' AND T2.date LIKE '2010-02-22%'\n```"
    ],
    "642": [
        "```\n#reason: The question wants to count the number of posts created on a specific date, so the SQL SELECT will count the posts where the creation date falls within the specified range.\n#columns: posts.CreaionDate\n#values: created on 21st July, 2010 refers to CreationDate BETWEEN '2010-07-21 00:00:00' and '2010-07-21 23:59:59'\n#SELECT: How many posts refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE CreationDate BETWEEN '2010-07-21 00:00:00' and '2010-07-21 23:59:59'\n#SQL: SELECT COUNT(*) FROM posts WHERE CreationDate BETWEEN '2010-07-21 00:00:00' and '2010-07-21 23:59:59'\n```"
    ],
    "635": [
        "```\n#reason: The question wants to count the number of posts made by Matt Parker that have more than 4 votes, so the SQL SELECT will count the posts where the user's display name is 'Matt Parker' and the number of votes is greater than 4.\n#columns: posts.Id, votes.PostId\n#values: 'DisplayName = Matt Parker' refer to users.DisplayName = 'Matt Parker', 'more than 4 votes' refer to COUNT(votes.PostId) > 4\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id) WHERE users.DisplayName = 'Matt Parker' GROUP BY posts.Id HAVING COUNT(votes.PostId) > 4\n#SQL: SELECT COUNT(posts.Id) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id LEFT JOIN votes ON posts.Id = votes.PostId WHERE users.DisplayName = 'Matt Parker' GROUP BY posts.Id HAVING COUNT(votes.PostId) > 4\n```"
    ],
    "99": [
        "```\n#reason: The question wants to list accounts with the highest approved amount among those that have loan validity greater than 12 months and were opened in 1993, so the SQL SELECT will focus on account IDs with filtering conditions on loan duration and account opening date.\n#columns: account.account_id, loan.amount, account.date\n#values: 'loan validity more than 12 months' refer to loan.duration > 12, 'account opening date in 1993' refer to strftime('%Y', account.date) = '1993'\n#SELECT: accounts refer to account.account_id\n#SQL-like: Show account.account_id, WHERE loan.duration > 12 AND strftime('%Y', account.date) = '1993' ORDER BY loan.amount DESC LIMIT 1\n#SQL: SELECT T1.account_id FROM account AS T1 INNER JOIN loan AS T2 ON T1.account_id = T2.account_id WHERE T2.duration > 12 AND strftime('%Y', T1.date) = '1993' ORDER BY T2.amount DESC LIMIT 1\n```"
    ],
    "747": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the total number of superheroes who do not have a full name, so the SQL SELECT will count the superheroes where full_name is NULL.\n#columns: superhero.full_name\n#values: superheroes without full name refer to superhero.full_name IS NULL\n#SELECT: SELECT COUNT(superhero.full_name) refer to the total number of superheroes without full name.\n#SQL-like: Show COUNT(superhero.full_name), WHERE superhero.full_name IS NULL\n#SQL: SELECT COUNT(full_name) FROM superhero WHERE full_name IS NULL\n```"
    ],
    "1219": [
        "```\n#reason: The question wants to calculate the average UA index for male patients with uric acid less than 8.0 and female patients with uric acid less than 6.5, so the SQL SELECT will include AVG(UA) and filter based on the SEX and UA values.\n#columns: Laboratory.UA, Patient.SEX\n#values: normal uric acid refer to (Laboratory.UA < 8.0 AND Patient.SEX = 'M') OR (Laboratory.UA < 6.5 AND Patient.SEX = 'F')\n#SELECT: average UA index refer to AVG(Laboratory.UA)\n#SQL-like: Show AVG(Laboratory.UA) WHERE (Laboratory.UA < 8.0 AND Patient.SEX = 'M') OR (Laboratory.UA < 6.5 AND Patient.SEX = 'F')\n#SQL: SELECT AVG(Laboratory.UA) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE (Laboratory.UA < 8.0 AND Patient.SEX = 'M') OR (Laboratory.UA < 6.5 AND Patient.SEX = 'F')\n```"
    ],
    "1054": [
        "```\n#reason: The question wants to display the \"defensive work rate\" of the football player \"David Wilson\", so the SQL SELECT will involve filtering by the player's name \"David Wilson\".\n#columns: Player.player_name, Player_Attributes.defensive_work_rate\n#values: 'David Wilson' refer to Player.player_name = 'David Wilson'\n#SELECT: defensive work rate refer to Player_Attributes.defensive_work_rate \n#SQL-like: Show Player_Attributes.defensive_work_rate, WHERE Player.player_name = 'David Wilson'\n#SQL: SELECT T2.defensive_work_rate FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'David Wilson'\n```"
    ],
    "892": [
        "```\n#reason: The question wants to find the driver with the most points scored, so the SQL SELECT will retrieve the driver's full name and points based on the maximum points scored.\n#columns: drivers.forename, drivers.surname, driverStandings.points\n#values: most points scored refers to driverStandings.points = (SELECT MAX(points) FROM driverStandings)\n#SELECT: SELECT drivers.forename, drivers.surname, driverStandings.points\n#SQL-like: Show drivers.forename, drivers.surname, driverStandings.points WHERE driverStandings.points = (SELECT MAX(points) FROM driverStandings)\n#SQL: SELECT drivers.forename, drivers.surname, driverStandings.points FROM driverStandings INNER JOIN drivers ON driverStandings.driverId = drivers.driverId WHERE driverStandings.points = (SELECT MAX(points) FROM driverStandings)\n```"
    ],
    "691": [
        "```\n#reason: The question wants to identify the number of adult users who have cast over 5000 upvotes, so the SQL SELECT will count the distinct user IDs from the users table where the age falls within the adult range and the upvotes exceed 5000.\n#columns: users.Id, users.Age, users.UpVotes\n#values: adult users refer to Age BETWEEN 19 AND 65, over 5000 upvotes refer to UpVotes > 5000\n#SELECT: SELECT COUNT(Id) refer to users.Id\n#SQL-like: Show COUNT(Id), WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000\n#SQL: SELECT COUNT(Id) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000\n```"
    ],
    "485": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question asks for the ruling creation date for the card 'Reminisce', so the SQL SELECT will retrieve the ruling date based on the card name.\n#columns: rulings.date, cards.name\n#values: 'Reminisce' refer to name = 'Reminisce'\n#SELECT: SELECT rulings.date refer to rulings.date\n#SQL-like: Show rulings.date WHERE cards.name = 'Reminisce'\n#SQL: SELECT T1.date FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Reminisce'\n```"
    ],
    "26": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to state the names and full communication address of high schools in Monterey which has more than 800 free or reduced price meals for ages 15-17, so the SQL SELECT will include the names and address components from the relevant tables with appropriate filtering conditions.)\n#columns: schools.School, schools.Street, schools.City, schools.State, schools.Zip, frpm.`Free Meal Count (Ages 5-17)`\n#values: 'Monterey' refer to schools.County = 'Monterey' AND 'more than 800' refer to frpm.`Free Meal Count (Ages 5-17)` > 800\n#SELECT: SELECT schools.School, schools.Street, schools.City, schools.State, schools.Zip\n#SQL-like: Show schools.School, schools.Street, schools.City, schools.State, schools.Zip WHERE schools.County = 'Monterey' AND frpm.`Free Meal Count (Ages 5-17)` > 800\n#SQL: SELECT T1.School, T1.Street, T1.City, T1.State, T1.Zip FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.County = 'Monterey' AND T2.`Free Meal Count (Ages 5-17)` > 800\n```"
    ],
    "544": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the display name of the user who last edited a specific post, so the SQL SELECT will include the user's display name filtered by the last editor's user ID corresponding to the post title.\n#columns: posts.Title, posts.LastEditorUserId, users.DisplayName\n#values: 'Examples for teaching: Correlation does not mean causation' refer to posts.Title = 'Examples for teaching: Correlation does not mean causation'\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName WHERE posts.Title = 'Examples for teaching: Correlation does not mean causation'\n#SQL: SELECT T3.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'\n```"
    ],
    "66": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine \"how many directly funded schools\" opened within a specific date range in the county of Stanislaus. This involves filtering based on the funding type and the opening date.\n#columns: schools.FundingType, schools.OpenDate, schools.County\n#values: 'opened between 1/1/2000 and 12/31/2005' refer to schools.OpenDate BETWEEN '2000-01-01' AND '2005-12-31', 'directly funded schools' refer to schools.FundingType = 'Directly funded', 'in the county of Stanislaus' refers to schools.County = 'Stanislaus'\n#SELECT: how many schools refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE schools.FundingType = 'Directly funded' AND schools.OpenDate BETWEEN '2000-01-01' AND '2005-12-31' AND schools.County = 'Stanislaus'\n#SQL: SELECT COUNT(*) FROM schools WHERE FundingType = 'Directly funded' AND OpenDate BETWEEN '2000-01-01' AND '2005-12-31' AND County = 'Stanislaus'\n```"
    ],
    "1373": [
        "```\n#reason: The question want to count how many members' hometowns are from Maryland state, so the SQL SELECT will count the distinct hometowns based on the state condition.\n#columns: member.zip, zip_code.state\n#values: 'Maryland' refer to zip_code.state = 'Maryland'\n#SELECT: SELECT COUNT(DISTINCT member.zip) refer to member.zip\n#SQL-like: Show COUNT(DISTINCT member.zip), WHERE zip_code.state = 'Maryland'\n#SQL: SELECT COUNT(DISTINCT T1.zip) FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T2.state = 'Maryland'\n```"
    ],
    "1103": [
        "```\n#reason: The question wants to display the overall rating for Aaron Mooy on a specific date, so the SQL SELECT will retrieve the overall rating from the Player_Attributes table where the player's name matches 'Aaron Mooy' and the date matches '2016-02-04'.\n#columns: Player_Attributes.overall_rating\n#values: 'Aaron Mooy' refer to Player.player_name = 'Aaron Mooy', 'on 2016/2/4' refer to Player_Attributes.date LIKE '2016-02-04%'\n#SELECT: overall rating refer to Player_Attributes.overall_rating\n#SQL-like: Show Player_Attributes.overall_rating, WHERE Player.player_name = 'Aaron Mooy' AND Player_Attributes.date LIKE '2016-02-04%'\n#SQL: SELECT T1.overall_rating FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.player_name = 'Aaron Mooy' AND T2.date LIKE '2016-02-04%'\n```"
    ],
    "1348": [
        "```\n#reason: The question wants to count how many budgets for the event \"November Meeting\" had exceeded the budget, so the SQL SELECT will count the budgets where the remaining amount is less than 0.\n#columns: budget.remaining, event.event_name\n#values: 'November Meeting' refers to event.event_name = 'November Meeting', remaining < 0 refers to budget.remaining < 0\n#SELECT: SELECT COUNT(*) refer to budget.remaining\n#SQL-like: Show COUNT(*) FROM budget WHERE remaining < 0 AND link_to_event IN (SELECT event_id FROM event WHERE event_name = 'November Meeting')\n#SQL: SELECT COUNT(*) FROM budget WHERE remaining < 0 AND link_to_event IN (SELECT event_id FROM event WHERE event_name = 'November Meeting')\n```"
    ],
    "446": [
        "```\n#reason: The question wants to calculate the percentage of cards with a converted Mana Cost of 10 among all cards, specifically for the card named 'Abyssal Horror'. This involves counting the instances of the filtered condition and calculating the percentage from the total. \n#columns: cards.convertedManaCost, cards.name\n#values: 'set of Abyssal Horror' refer to cards.name = 'Abyssal Horror', 'converted Mana Cost of 10' refer to cards.convertedManaCost = 10\n#SELECT: SELECT (COUNT(convertedManaCost = 10) * 100 / COUNT(convertedManaCost)) refer to cards.convertedManaCost\n#SQL-like: Show (COUNT(convertedManaCost = 10) * 100 / COUNT(convertedManaCost)), WHERE cards.name = 'Abyssal Horror'\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.convertedManaCost) FROM cards AS T1 WHERE T1.name = 'Abyssal Horror'\n```"
    ],
    "1007": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the longest time that Lewis Hamilton had spent at a pit stop, so the SQL SELECT will focus on the MAX(duration) for the driver identified as Lewis Hamilton.\n#columns: pitStops.duration\n#values: longest time refers to MAX(duration) for the driver with driverRef 'hamilton' refer to drivers.driverRef = 'hamilton'.\n#SELECT: longest time refers to MAX(pitStops.duration)\n#SQL-like: Show MAX(pitStops.duration), WHERE drivers.driverRef = 'hamilton'\n#SQL: SELECT MAX(pitStops.duration) FROM pitStops INNER JOIN drivers ON pitStops.driverId = drivers.driverId WHERE drivers.driverRef = 'hamilton'\n```"
    ],
    "365": [
        "```\n#reason: The question wants to display the \"type of card\" for the card named \"Benalish Knight\", so the SQL SELECT will retrieve the type from the cards table where the name matches 'Benalish Knight'.\n#columns: cards.type\n#values: 'Benalish Knight' refers to cards.name = 'Benalish Knight'\n#SELECT: SELECT type refer to cards.type\n#SQL-like: Show cards.type, WHERE cards.name = 'Benalish Knight'\n#SQL: SELECT T1.type FROM cards AS T1 WHERE T1.name = 'Benalish Knight'\n```"
    ],
    "1471": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the ratio of customers who pay in EUR against those who pay in CZK, so the SQL SELECT will count the customers based on their currency.\n#columns: customers.Currency\n#values: 'customers who pay in EUR' refer to customers.Currency = 'EUR', 'customers who pay in CZK' refer to customers.Currency = 'CZK'\n#SELECT: ratio of customers who pay in EUR against customers who pay in CZK refer to DIVIDE(COUNT(Currency = 'EUR'), COUNT(Currency = 'CZK'))\n#SQL-like: Show DIVIDE(COUNT(Currency = 'EUR'), COUNT(Currency = 'CZK'))\n#SQL: SELECT CAST(SUM(CASE WHEN Currency = 'EUR' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN Currency = 'CZK' THEN 1 ELSE 0 END) FROM customers\n```"
    ],
    "300": [
        "```\n#reason: The question wants to display the atoms that comprise the molecule with ID TR186, so the SQL SELECT will include the relevant atom details linked to molecule ID TR186.\n#columns: atom.atom_id, atom.element, atom.molecule_id\n#values: 'TR186' refer to atom.molecule_id = 'TR186'\n#SELECT: SELECT atom.atom_id, atom.element refer to atoms that comprise TR186. \n#SQL-like: Show atom.atom_id, atom.element, WHERE atom.molecule_id = 'TR186'\n#SQL: SELECT atom.atom_id, atom.element FROM atom WHERE atom.molecule_id = 'TR186'\n```"
    ],
    "1295": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of patients with total bilirubin over the normal range who also have a peripheral pattern in the ANA examination, so the SQL SELECT will count the patients based on the specified filters.\n#columns: COUNT(Patient.ID), Examination.`ANA Pattern`\n#values: total bilirubin is over the normal range refers to Laboratory.`T-BIL` >= 2.0; peripheral pattern observed in the sheet of ANA examination refers to Examination.`ANA Pattern` LIKE '%P%'\n#SELECT: COUNT(Patient.ID) refer to COUNT(Patient.ID). \n#SQL-like: Show COUNT(Patient.ID), WHERE Laboratory.`T-BIL` >= 2.0 AND Examination.`ANA Pattern` LIKE '%P%'\n#SQL: SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID INNER JOIN Examination AS T3 ON T1.ID = T3.ID WHERE T2.`T-BIL` >= 2.0 AND T3.`ANA Pattern` LIKE '%P%'\n```"
    ],
    "1285": [
        "```\n#reason: The question wants to find the date when the latest patient's medical data was recorded, filtered by patients having an abnormal level of lactate dehydrogenase. The SQL SELECT clause will focus on finding the maximum 'First Date' of such patients.\n#columns: Patient.`First Date`, Laboratory.LDH\n#values: abnormal level of lactate dehydrogenase refers to Laboratory.LDH >= 500\n#SELECT: SELECT MAX(Patient.`First Date`) refer to Patient.`First Date`\n#SQL-like: Show MAX(Patient.`First Date`), WHERE Laboratory.LDH >= 500\n#SQL: SELECT MAX(Patient.`First Date`) FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.LDH >= 500\n```"
    ],
    "242": [
        "```\n#reason: The question wants to list all the molecules that are carcinogenic among all the atoms from 21 to 25, so the SQL SELECT will filter the atom_id based on the specified range and join with the molecule table based on the molecule_id to check the label.\n#columns: molecule.molecule_id\n#values: atoms from 21 to 25 refer to SUBSTR(atom.atom_id, 7, 2) BETWEEN '21' AND '25' AND label = '+' refer to molecule.label = '+'\n#SELECT: SELECT DISTINCT molecule.molecule_id refer to molecule.molecule_id\n#SQL-like: Show DISTINCT molecule.molecule_id, WHERE SUBSTR(atom.atom_id, 7, 2) BETWEEN '21' AND '25' AND molecule.label = '+'\n#SQL: SELECT DISTINCT m.molecule_id FROM atom AS a INNER JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE SUBSTR(a.atom_id, 7, 2) BETWEEN '21' AND '25' AND m.label = '+'\n```"
    ],
    "118": [
        "```\n#reason: The question wants to calculate the percentage of accounts with a loan amount less than USD100,000 that are still running with no issues. Therefore, the SQL SELECT will count the accounts with status 'C' and divide it by the total number of accounts with loan amounts less than USD100,000, then multiply by 100 to get the percentage.\n#columns: loan.amount, loan.status, loan.account_id\n#values: loan amount less than USD100,000 refers to loan.amount < 100000, status = 'C' refers to loan.status = 'C'\n#SELECT: SELECT (COUNT(loan.account_id WHERE loan.status = 'C') * 100.0 / COUNT(loan.account_id)) \n#SQL-like: Show (COUNT(loan.account_id WHERE loan.status = 'C') * 100.0 / COUNT(loan.account_id)), WHERE loan.amount < 100000\n#SQL: SELECT CAST(COUNT(CASE WHEN loan.status = 'C' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(loan.account_id) FROM loan WHERE loan.amount < 100000\n```"
    ],
    "958": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the driver with the fastest lap time, so the SQL SELECT will pull the forenames and surnames of that driver.\n#columns: drivers.forename, drivers.surname, results.fastestLapTime\n#values: fastest lap time refers to MIN(results.fastestLapTime)\n#SELECT: SELECT content refers to drivers.forename, drivers.surname \n#SQL-like: Show drivers.forename, drivers.surname, WHERE results.fastestLapTime is the minimum value\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.fastestLapTime = (SELECT MIN(fastestLapTime) FROM results)\n```"
    ],
    "1123": [
        "```\n#reason: The question requires displaying the \"name of players\" with the \"highest potential\". The highest potential is defined as MAX(potential).\n#columns: Player.player_name, Player_Attributes.potential\n#values: highest potential refers to MAX(Player_Attributes.potential)\n#SELECT: name of players refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.potential = MAX(Player_Attributes.potential)\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.potential = (SELECT MAX(potential) FROM Player_Attributes)\n```"
    ],
    "905": [
        "```\n#reason: The question requires displaying \"Eddie Irvine's average points scored\" in the year 2000. The average points is calculated as AVG(points) with the filtering condition that the year is 2000 and the driver's name is 'Eddie Irvine'.\n#columns: results.points, races.year, drivers.forename, drivers.surname\n#values: 'year 2000' refer to races.year = 2000, 'Eddie Irvine' refer to drivers.forename = 'Eddie' AND drivers.surname = 'Irvine'\n#SELECT: average points refer to AVG(points)\n#SQL-like: Show AVG(points), WHERE races.year = 2000 AND drivers.forename = 'Eddie' AND drivers.surname = 'Irvine'\n#SQL: SELECT CAST(AVG(T1.points) AS REAL) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T1.driverId = T3.driverId WHERE T2.year = 2000 AND T3.forename = 'Eddie' AND T3.surname = 'Irvine'\n```"
    ],
    "1487": [
        "```\n#reason: The question wants to identify the LAM customer who used Euro as their currency and had the highest consumption in October 2013, so the SQL SELECT will filter by customer segment, currency, and date, and will order by consumption to find the maximum.\n#columns: customers.CustomerID, yearmonth.Consumption\n#values: 'LAM customer' refers to customers.Segment = 'LAM', 'used the Euro' refers to customers.Currency = 'EUR', 'in October 2013' refers to yearmonth.Date = '201310'\n#SELECT: SELECT customers.CustomerID, yearmonth.Consumption\n#SQL-like: Show customers.CustomerID, yearmonth.Consumption WHERE customers.Segment = 'LAM' AND customers.Currency = 'EUR' AND yearmonth.Date = '201310' ORDER BY yearmonth.Consumption DESC LIMIT 1\n#SQL: SELECT T1.CustomerID, T2.Consumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'LAM' AND T1.Currency = 'EUR' AND T2.Date = '201310' ORDER BY T2.Consumption DESC LIMIT 1\n```"
    ],
    "188": [
        "```\n#reason: The question wants to list accounts that have a loan validity of more than 24 months, the lowest approved amount, and an account opening date before 1997, so the SQL SELECT will include those conditions.\n#columns: account.account_id, loan.amount, account.date\n#values: 'loan validity more than 24 months' refers to loan.duration > 24; 'approved amount' refers to loan.amount as the value to filter for the lowest; 'account opening date before 1997' refers to account.date < '1997-01-01'\n#SELECT: SELECT account.account_id, loan.amount, account.date\n#SQL-like: Show account.account_id, loan.amount WHERE loan.duration > 24 AND loan.amount = (SELECT MIN(amount) FROM loan WHERE duration > 24) AND account.date < '1997-01-01'\n#SQL: SELECT account.account_id, loan.amount, account.date FROM account INNER JOIN loan ON account.account_id = loan.account_id WHERE loan.duration > 24 AND loan.amount = (SELECT MIN(amount) FROM loan WHERE duration > 24) AND account.date < '1997-01-01'\n```"
    ],
    "950": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display constructor names with 0 points at race 291, so the SQL SELECT will include the constructor names and filter based on raceId and points.\n#columns: constructors.name, results.points, results.raceId\n#values: race at 291 refers to results.raceId = 291 and points = 0 refers to results.points = 0\n#SELECT: SELECT constructors.name refer to constructors.name\n#SQL-like: Show constructors.name, WHERE results.raceId = 291 AND results.points = 0\n#SQL: SELECT T1.name FROM constructors AS T1 INNER JOIN results AS T2 ON T1.constructorId = T2.constructorId WHERE T2.raceId = 291 AND T2.points = 0\n```"
    ],
    "1470": [
        "```\n#reason: The question requires display in order: \"How many gas stations\". \"in CZE has Premium gas\" is a filtering condition.\n#columns: gasstations.GasStationID, gasstations.Country, gasstations.Segment\n#values: 'CZE' refer to gasstations.Country = 'CZE', 'Premium' refer to gasstations.Segment = 'Premium'\n#SELECT: How many gas stations refer to COUNT(GasStationID)\n#SQL-like: Show COUNT(GasStationID), WHERE gasstations.Country = 'CZE' AND gasstations.Segment = 'Premium'\n#SQL: SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Premium'\n```"
    ],
    "301": [
        "```\n#reason: The question wants to identify the bond type for a specific bond ID 'TR007_4_19', so the SQL SELECT will retrieve the bond_type from the bond table where the bond_id matches 'TR007_4_19'.\n#columns: bond.bond_type\n#values: bond_id = 'TR007_4_19' refers to bond.bond_id = 'TR007_4_19'\n#SELECT: bond type refers to bond.bond_type\n#SQL-like: Show bond.bond_type, WHERE bond.bond_id = 'TR007_4_19'\n#SQL: SELECT bond.bond_type FROM bond WHERE bond.bond_id = 'TR007_4_19'\n```"
    ],
    "267": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list down the bond type for molecules with IDs ranging from TR000 to TR050, so the SQL SELECT will involve the bond_type column and filtering on the molecule_id.\n#columns: bond.bond_type, bond.molecule_id\n#values: molecules from TR000 to TR050 refer to bond.molecule_id BETWEEN 'TR000' AND 'TR050'\n#SELECT: bond type refer to bond.bond_type\n#SQL-like: Show bond.bond_type, WHERE bond.molecule_id BETWEEN 'TR000' AND 'TR050'\n#SQL: SELECT bond.bond_type FROM bond WHERE bond.molecule_id BETWEEN 'TR000' AND 'TR050'\n```"
    ],
    "870": [
        "```\n#reason: The question wants to display \"Lucas di Grassi's Q1 result\" in race No. 345, which implies retrieving his qualifying time in Q1 from the qualifying table, with a filtering condition based on the raceId.\n#columns: qualifying.q1, drivers.driverId, drivers.forename, drivers.surname\n#values: race No. 345 refers to qualifying.raceId = 345 and Lucas di Grassi refers to drivers.driverRef = 'grassi'\n#SELECT: SELECT qualifying.q1 \n#SQL-like: Show qualifying.q1 WHERE qualifying.raceId = 345 AND drivers.driverRef = 'grassi'\n#SQL: SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 345 AND T2.driverRef = 'grassi'\n```"
    ],
    "762": [
        "```\n#reason: The question requires determining which power superheroes have the most of, meaning we need to count the occurrences of each power and find the maximum count. \n#columns: superpower.power_name\n#values: None (no filtering conditions exist since we're looking for the maximum count)\n#SELECT: SELECT power that superheroes have the most refer to superpower.power_name\n#SQL-like: Show superpower.power_name, GROUP BY superpower.power_name ORDER BY COUNT(hero_power.power_id) DESC LIMIT 1\n#SQL: SELECT T1.power_name FROM superpower AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.power_id GROUP BY T1.power_name ORDER BY COUNT(T2.hero_id) DESC LIMIT 1\n```"
    ],
    "1323": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all event names that had attendance over 20 students but were not fundraisers, so the SQL SELECT will count the number of attendees and filter by event type.\n#columns: event.event_name, attendance.link_to_event\n#values: attendance of over 20 students refers to COUNT(attendance.link_to_event) > 20, not fundraisers refers to event.type <> 'Fundraising'\n#SELECT: SELECT event.event_name refer to event.event_name\n#SQL-like: Show event.event_name FROM event INNER JOIN attendance ON event.event_id = attendance.link_to_event GROUP BY event.event_id HAVING COUNT(attendance.link_to_event) > 20 AND event.type <> 'Fundraising'\n#SQL: SELECT event.event_name FROM event INNER JOIN attendance ON event.event_id = attendance.link_to_event GROUP BY event.event_id HAVING COUNT(attendance.link_to_event) > 20 AND event.type <> 'Fundraising'\n```"
    ],
    "443": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"code of sets\" where the type is \"expansion\". \n#columns: sets.code\n#values: 'expansion type' refers to sets.type = 'expansion'\n#SELECT: code of sets refers to sets.code\n#SQL-like: Show sets.code, WHERE sets.type = 'expansion'\n#SQL: SELECT code FROM sets WHERE type = 'expansion'\n```"
    ],
    "406": [
        "```\n#reason: The question wants to list all Creature-type cards with legal status, so the SQL SELECT will include the ID of the cards and filter by legal status and type.\n#columns: cards.id, cards.types, legalities.status\n#values: legal status refers to legalities.status = 'Legal', Creature-type cards refer to cards.types = 'Creature'\n#SELECT: SELECT cards.id refer to cards.id\n#SQL-like: Show cards.id WHERE legalities.status = 'Legal' AND cards.types = 'Creature'\n#SQL: SELECT cards.id FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'Legal' AND cards.types = 'Creature'\n```"
    ],
    "981": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the year of the youngest driver's first qualifying race, along with the driver's name, race date, and time. The youngest driver is determined by the maximum value of drivers.dob, and the first qualifying race is identified by the minimum value of races.date.\n#columns: drivers.forename, drivers.surname, races.date, races.time\n#values: youngest driver refers to MAX(drivers.dob), first qualifying race refers to MIN(races.date)\n#SELECT: SELECT year of the first qualifying race refer to strftime('%Y', races.date), name refer to drivers.forename, drivers.surname, date refer to races.date, time refer to races.time\n#SQL-like: Show strftime('%Y', races.date), drivers.forename, drivers.surname, races.date, races.time, ORDER BY drivers.dob DESC, races.date LIMIT 1\n#SQL: SELECT strftime('%Y', T3.date), T2.forename, T2.surname, T3.date, T3.time FROM drivers AS T2 INNER JOIN qualifying AS T1 ON T2.driverId = T1.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId ORDER BY T2.dob DESC, T3.date LIMIT 1\n```"
    ],
    "3": [
        "```\n#reason: The question wants to find the unabbreviated mailing street address of the school with the highest FRPM count for K-12 students, so the SQL SELECT will retrieve the mailing street address and filter for the maximum FRPM count.\n#columns: schools.MailStreet, frpm.`FRPM Count (K-12)`\n#values: highest FRPM count for K-12 students refers to MAX(frpm.`FRPM Count (K-12)`)\n#SELECT: SELECT schools.MailStreet refer to schools.MailStreet\n#SQL-like: Show schools.MailStreet, WHERE frpm.`FRPM Count (K-12)` = (SELECT MAX(frpm.`FRPM Count (K-12)`) FROM frpm)\n#SQL: SELECT T1.MailStreet FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.`FRPM Count (K-12)` = (SELECT MAX(`FRPM Count (K-12)`) FROM frpm)\n```"
    ],
    "51": [
        "```\n#reason: The question wants to find \"the mailing street address\" and the school's name for the school with the lowest average score in reading, so the SQL SELECT will retrieve the mailing street address and school name where the average score in reading is minimum.\n#columns: schools.MailStreet, schools.School\n#values: lowest average score in reading refers to satscores.AvgScrRead = (SELECT MIN(Average) FROM satscores).\n#SELECT: SELECT schools.MailStreet, schools.School\n#SQL-like: Show schools.MailStreet, schools.School WHERE satscores.AvgScrRead = (SELECT MIN(satscores.AvgScrRead) FROM satscores)\n#SQL: SELECT schools.MailStreet, schools.School FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE satscores.AvgScrRead = (SELECT MIN(AvgScrRead) FROM satscores)\n```"
    ],
    "130": [
        "```\n#reason: The question wants to determine the number of account holders in South Bohemia who do not own credit cards, so the SQL SELECT will count the distinct account holders from the account table that do not have a corresponding entry in the card table.\n#columns: account.account_id, account.district_id, client.client_id\n#values: 'South Bohemia' refers to district.A3 = 'south Bohemia', 'do not own credit cards' refers to card.card_id IS NULL\n#SELECT: SELECT COUNT(DISTINCT account.account_id) refer to account.account_id\n#SQL-like: Show COUNT(DISTINCT account.account_id) WHERE district.A3 = 'south Bohemia' AND card.card_id IS NULL\n#SQL: SELECT COUNT(DISTINCT T1.account_id) FROM account AS T1 INNER JOIN client AS T2 ON T1.district_id = T2.district_id LEFT JOIN card AS T3 ON T1.account_id = T3.disp_id WHERE T2.district_id IN (SELECT district_id FROM district WHERE A3 = 'south Bohemia') AND T3.card_id IS NULL\n```"
    ],
    "1430": [
        "```\n#reason: The question wants to identify the last name and position of the student who incurred an expense for pizza on a specific date, so the SQL SELECT will include the member's last name and position, and will filter based on the expense description and expense date.\n#columns: member.last_name, member.position\n#values: 'bought pizza on 09/10/2019' refers to expense.expense_description = 'Pizza' AND expense.expense_date = '2019-09-10'\n#SELECT: SELECT member.last_name, member.position\n#SQL-like: Show member.last_name, member.position WHERE expense.expense_description = 'Pizza' AND expense.expense_date = '2019-09-10'\n#SQL: SELECT T1.last_name, T1.position FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_description = 'Pizza' AND T2.expense_date = '2019-09-10'\n```"
    ],
    "113": [
        "```\n#reason: The question want to find out the birthday of the client who applied for a specific loan amount on a specific date, so the SQL SELECT will join the loan and client tables and filter based on the loan amount and date.\n#columns: client.birth_date\n#values: '98832 USD' loan amount refer to loan.amount = 98832, '1996/1/3' applied date refer to loan.date = '1996-01-03'\n#SELECT: SELECT client.birth_date\n#SQL-like: Show client.birth_date, WHERE loan.amount = 98832 AND loan.date = '1996-01-03'\n#SQL: SELECT client.birth_date FROM client INNER JOIN loan ON client.client_id = loan.account_id WHERE loan.amount = 98832 AND loan.date = '1996-01-03'\n```"
    ],
    "1449": [
        "```\n#reason: The question wants to display the \"name and major of members\" where the \"spend more than a hundred dollars on an expense\" is the filtering condition. \"name\" refers to the combination of first_name and last_name, and \"major\" refers to major_name. The filtering condition translates to cost > 100.\n#columns: member.first_name, member.last_name, major.major_name\n#values: spend more than a hundred dollars on an expense refers to expense.cost > 100\n#SELECT: SELECT member.first_name, member.last_name, major.major_name refer to member.first_name, member.last_name, major.major_name.\n#SQL-like: Show member.first_name, member.last_name, major.major_name WHERE expense.cost > 100\n#SQL: SELECT T1.first_name, T1.last_name, T3.major_name FROM expense AS T2 INNER JOIN member AS T1 ON T2.link_to_member = T1.member_id INNER JOIN major AS T3 ON T1.link_to_major = T3.major_id WHERE T2.cost > 100\n```"
    ],
    "819": [
        "```\n#reason: The question wants to calculate the difference between the number of superheroes with blue eyes and those with no eye color among superheroes with missing weight data. The SQL SELECT statement will count the superheroes with blue eyes (where eye_colour_id corresponds to the color id for blue) and those with no eye color (where eye_colour_id corresponds to the color id for no color), filtering for missing weight data. \n#columns: superhero.weight_kg, superhero.eye_colour_id, colour.id\n#values: missing weight data refers to superhero.weight_kg = 0 OR superhero.weight_kg IS NULL; blue eyes refers to colour.id = 7; no eye color refers to colour.id = 1\n#SELECT: difference between the number of superheroes with blue eyes and no eye color refer to SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1))\n#SQL-like: Show SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)), WHERE superhero.weight_kg = 0 OR superhero.weight_kg IS NULL\n#SQL: SELECT SUM(CASE WHEN T1.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.eye_colour_id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 WHERE T1.weight_kg = 0 OR T1.weight_kg IS NULL\n```"
    ],
    "751": [
        "```\n#reason: The question wants to list down at least five superpowers of male superheroes, so the SQL SELECT will retrieve the superpower names associated with male superheroes.\n#columns: superpower.power_name\n#values: male refers to superhero.gender_id = (SELECT id FROM gender WHERE gender = 'Male')\n#SELECT: SELECT DISTINCT superpower.power_name\n#SQL-like: Show DISTINCT superpower.power_name, WHERE superhero.gender_id = (SELECT id FROM gender WHERE gender = 'Male')\n#SQL: SELECT DISTINCT sp.power_name FROM superhero AS s INNER JOIN hero_power AS hp ON s.id = hp.hero_id INNER JOIN superpower AS sp ON hp.power_id = sp.id WHERE s.gender_id = (SELECT id FROM gender WHERE gender = 'Male') LIMIT 5\n```"
    ],
    "215": [
        "```\n#reason: The question wants to count distinct atoms that have iodine and sulfur type elements in single bond molecules, so the SQL SELECT will count distinct atom IDs based on the filtering conditions for elements and bond types.\n#columns: atom.atom_id, atom.element, bond.bond_type, molecule.molecule_id\n#values: iodine refers to atom.element = 'i', sulfur refers to atom.element = 's', single type bond refers to bond.bond_type = '-'\n#SELECT: SELECT COUNT(DISTINCT atom.atom_id) refer to COUNT(DISTINCT atom.atom_id)\n#SQL-like: Show COUNT(DISTINCT atom.atom_id) WHERE atom.element IN ('i', 's') AND bond.bond_type = '-' AND atom.molecule_id = molecule.molecule_id\n#SQL: SELECT COUNT(DISTINCT atom.atom_id) FROM atom INNER JOIN bond ON atom.molecule_id = bond.molecule_id WHERE atom.element IN ('i', 's') AND bond.bond_type = '-'\n```"
    ],
    "1228": [
        "```\n#reason: The question wants to list patients and their diagnosis with triglyceride index greater than 100 of the normal range, so the SQL SELECT will include Patient.ID and Patient.Diagnosis.\n#columns: Patient.ID, Patient.Diagnosis\n#values: triglyceride (TG) index greater than 100 of the normal range refers to Laboratory.TG > 300\n#SELECT: SELECT Patient.ID, Patient.Diagnosis refer to Patient.ID, Patient.Diagnosis\n#SQL-like: Show Patient.ID, Patient.Diagnosis WHERE Laboratory.TG > 300\n#SQL: SELECT P.ID, P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.TG > 300\n```"
    ],
    "193": [
        "```\n#reason: The question wants to list all ID and district for clients that can only have the right to issue permanent orders or apply for loans, so the SQL SELECT will include client.client_id and client.district_id where disp.type = 'OWNER'.\n#columns: client.client_id, client.district_id\n#values: owner accounts refer to disp.type = 'OWNER'\n#SELECT: SELECT client.client_id, client.district_id\n#SQL-like: Show client.client_id, client.district_id WHERE disp.type = 'OWNER'\n#SQL: SELECT T1.client_id, T1.district_id FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id WHERE T2.type = 'OWNER'\n```"
    ],
    "1239": [
        "```\n#reason: The question wants to identify patients who have had two or more laboratory examinations with hematocrit levels exceeding the normal range, so the SQL SELECT will count the number of examinations and filter based on the hematocrit level and calculate the age.\n#columns: Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday))\n#values: 'hematocrit level exceeded the normal range' refers to 'Laboratory.HCT >= 52', 'patient with two or more laboratory examinations' refers to 'COUNT(Laboratory.ID) > 2'\n#SELECT: SELECT Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday)) AS age\n#SQL-like: Show Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday)), WHERE Laboratory.HCT >= 52, GROUP BY Patient.ID HAVING COUNT(Laboratory.ID) > 2\n#SQL: SELECT Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday)) AS age FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.HCT >= 52 GROUP BY Patient.ID HAVING COUNT(Laboratory.ID) > 2\n```"
    ],
    "965": [
        "```\n#reason: The question wants to list out the Id number of races which were held in 2009, so the SQL SELECT will filter the races based on the year 2009.\n#columns: races.raceId, races.year\n#values: 'held in 2009' refer to races.year = 2009\n#SELECT: Id number of races refer to races.raceId\n#SQL-like: Show races.raceId, WHERE races.year = 2009\n#SQL: SELECT raceId FROM races WHERE year = 2009\n```"
    ],
    "717": [
        "```\n#reason: The question wants to list all the superpowers of \"3-D Man\", so the SQL SELECT will retrieve the power names related to this superhero.\n#columns: superpower.power_name\n#values: '3-D Man' refer to superhero.superhero_name = '3-D Man'\n#SELECT: SELECT superpower.power_name refer to superpower.power_name.\n#SQL-like: Show superpower.power_name, WHERE superhero.superhero_name = '3-D Man'\n#SQL: SELECT T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id WHERE T1.superhero_name = '3-D Man'\n```"
    ],
    "0": [
        "```\n#reason: The question wants to find the highest eligible free rate for K-12 students in Alameda County, so the SQL SELECT will involve calculating the eligible free rate using `Free Meal Count (K-12)` divided by `Enrollment (K-12)` and filtering for schools in Alameda County.\n#columns: frpm.`Free Meal Count (K-12)`, frpm.`Enrollment (K-12)`\n#values: the filter in SQL (\"schools in Alameda County\") refer to \"frpm.`County Name` = 'Alameda'\"\n#SELECT: SELECT MAX(CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL)) \n#SQL-like: Show MAX(CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL)), WHERE frpm.`County Name` = 'Alameda'\n#SQL: SELECT MAX(CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL)) FROM frpm WHERE frpm.`County Name` = 'Alameda'\n```"
    ],
    "724": [
        "```\n#reason: The question wants to list the superhero names of all the superheroes that have blue eyes and blond hair, so the SQL SELECT will include superhero.superhero_name and apply filters for eye_colour_id and hair_colour_id based on the specified colors.\n#columns: superhero.superhero_name, colour.colour\n#values: 'blue eyes' refer to colour = 'Blue' and eye_colour_id = colour.id, 'blond hair' refer to colour = 'Blond' and hair_colour_id = colour.id\n#SELECT: SELECT superhero.superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name, WHERE colour.colour = 'Blue' AND superhero.eye_colour_id = colour.id AND colour.colour = 'Blond' AND superhero.hair_colour_id = colour.id\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id INNER JOIN colour AS T3 ON T1.hair_colour_id = T3.id WHERE T2.colour = 'Blue' AND T3.colour = 'Blond'\n```"
    ],
    "1274": [
        "```\n#reason: The question wants to count the number of patients whose anti-SSB are normal and have other symptoms observed in their examination, so the SQL SELECT will count distinct patients where SSB is normal and Symptoms is not null.\n#columns: Laboratory.SSB, Examination.Symptoms, Examination.ID\n#values: anti-SSB are normal refers to Laboratory.SSB IN ('negative', '0'), have other symptoms refers to Examination.Symptoms IS NOT NULL\n#SELECT: how many patients refer to COUNT(DISTINCT Examination.ID)\n#SQL-like: Show COUNT(DISTINCT Examination.ID), WHERE Laboratory.SSB IN ('negative', '0') AND Examination.Symptoms IS NOT NULL\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.SSB IN ('negative', '0') AND T1.Symptoms IS NOT NULL\n```"
    ],
    "700": [
        "```\n#reason: The question wants to identify the number of posts that offer a bounty amount over 30, so the SQL SELECT will count the posts where the bounty amount is greater than or equal to 30.\n#columns: votes.BountyAmount\n#values: bounty amount over 30 refers to votes.BountyAmount >= 30\n#SELECT: the number of posts refer to COUNT(*)\n#SQL-like: Show COUNT(*) WHERE votes.BountyAmount >= 30\n#SQL: SELECT COUNT(*) FROM votes WHERE BountyAmount >= 30\n```"
    ],
    "1008": [
        "```\n#reason: The question wants to identify the lap during which Lewis Hamilton took a pit stop in the 2011 Australian Grand Prix, so the SQL SELECT will focus on the lap number from the pitStops table filtered by the driver's name and the race name.\n#columns: pitStops.lap\n#values: 'Lewis Hamilton' refers to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'; '2011 Australian Grand Prix' refers to races.name = 'Australian Grand Prix' AND races.year = 2011\n#SELECT: SELECT pitStops.lap\n#SQL-like: Show pitStops.lap, WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND races.name = 'Australian Grand Prix' AND races.year = 2011\n#SQL: SELECT T1.lap FROM pitStops AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.name = 'Australian Grand Prix' AND T3.year = 2011\n```"
    ],
    "580": [
        "```\n#reason: The question wants to find the names of users who have been awarded the badge 'Necromancer', so the SQL SELECT will retrieve the DisplayName from the users table and join it with the badges table to filter by the badge name.\n#columns: users.DisplayName, badges.Name\n#values: badge name 'Necromancer' refer to badges.Name = 'Necromancer'\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE badges.Name = 'Necromancer'\n#SQL: SELECT T1.DisplayName FROM users AS T1 INNER JOIN badges AS T2 ON T1.Id = T2.UserId WHERE T2.Name = 'Necromancer' LIMIT 10\n```"
    ],
    "480": [
        "```\n#reason: The question wants to display the Italian flavor text of the card \"Ancestor's Chosen\", so the SQL SELECT should retrieve flavorText from the foreign_data table where the language is 'Italian' and the name of the card is 'Ancestor''s Chosen'.\n#columns: foreign_data.flavorText, cards.name\n#values: language = 'Italian' refer to foreign_data.language = 'Italian', name = 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen'\n#SELECT: Italian flavor text refer to foreign_data.flavorText\n#SQL-like: Show foreign_data.flavorText, WHERE foreign_data.language = 'Italian' AND cards.name = 'Ancestor''s Chosen'\n#SQL: SELECT T1.flavorText FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T1.language = 'Italian' AND T2.name = 'Ancestor''s Chosen'\n```"
    ],
    "578": [
        "```\n#reason: The question wants to identify the user who made a specific post and also display their reputation, so the SQL SELECT will need to join the posts and users tables based on the user's ID and the post's owner ID.\n#columns: users.DisplayName, users.Reputation\n#values: 'Understanding what Dassault iSight is doing?' refer to posts.Title = 'Understanding what Dassault iSight is doing?'\n#SELECT: user refer to users.DisplayName, reputation refer to users.Reputation\n#SQL-like: Show users.DisplayName, users.Reputation WHERE posts.Title = 'Understanding what Dassault iSight is doing?'\n#SQL: SELECT T1.DisplayName, T2.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Title = 'Understanding what Dassault iSight is doing?'\n```"
    ],
    "566": [
        "```\n#reason: The question wants to find the reputation points of the owner user of a specific post, so the SQL SELECT will retrieve the reputation from the users table where the post's owner user ID matches the specified post ID.\n#columns: users.Reputation\n#values: post no. 65041 refers to posts.Id = 65041\n#SELECT: reputation points refer to users.Reputation\n#SQL-like: Show users.Reputation, WHERE posts.Id = 65041\n#SQL: SELECT T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 65041\n```"
    ],
    "778": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to display the names of superheroes who have the adaptation power, so the SQL SELECT will pull superhero.superhero_name and filter based on superpower.power_name for 'Adaptation'.)\n#columns: superhero.superhero_name\n#values: 'adaptation power' refers to superpower.power_name = 'Adaptation'\n#SELECT: SELECT superhero.superhero_name\n#SQL-like: Show superhero.superhero_name WHERE superpower.power_name = 'Adaptation'\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Adaptation'\n```"
    ],
    "1434": [
        "```\n#reason: The question wants to identify the zip codes that have post office boxes in the county of San Juan Municipio whose state is Puerto Rico, so the SQL SELECT will filter the zip code by state and county while specifying the type as 'PO Box'.\n#columns: zip_code.zip_code, zip_code.county, zip_code.state, zip_code.type\n#values: 'San Juan Municipio' refer to zip_code.county = 'San Juan Municipio', 'Puerto Rico' refer to zip_code.state = 'Puerto Rico', 'PO Box' refer to zip_code.type = 'PO Box'\n#SELECT: SELECT zip_code.zip_code refer to zip_code.zip_code\n#SQL-like: Show zip_code.zip_code WHERE zip_code.county = 'San Juan Municipio' AND zip_code.state = 'Puerto Rico' AND zip_code.type = 'PO Box'\n#SQL: SELECT T1.zip_code FROM zip_code AS T1 WHERE T1.county = 'San Juan Municipio' AND T1.state = 'Puerto Rico' AND T1.type = 'PO Box'\n```"
    ],
    "592": [
        "```\n#reason: The question wants to find the count of users who have been awarded more than 5 badges, so the SQL SELECT will count the distinct UserId where the count of badges exceeds 5.\n#columns: badges.UserId, badges.Name\n#values: more than 5 badges refer to COUNT(Name) > 5\n#SELECT: How many users refer to COUNT(DISTINCT UserId)\n#SQL-like: Show COUNT(DISTINCT UserId), WHERE COUNT(Name) > 5, GROUP BY UserId\n#SQL: SELECT COUNT(DISTINCT UserId) FROM badges GROUP BY UserId HAVING COUNT(Name) > 5\n```"
    ],
    "271": [
        "```\n#reason: The question wants to check if bond id TR001_1_8 has both elements chlorine and carbon, so the SQL SELECT will check for the presence of both elements in the atoms connected by the bond.\n#columns: atom.element, bond.bond_id\n#values: 'chlorine' refer to element = 'cl', 'carbon' refer to element = 'c', 'bond id TR001_1_8' refer to bond.bond_id = 'TR001_1_8'\n#SELECT: SELECT COUNT(DISTINCT atom.element) FROM atom INNER JOIN connected ON atom.atom_id = connected.atom_id INNER JOIN bond ON connected.bond_id = bond.bond_id WHERE bond.bond_id = 'TR001_1_8' AND (atom.element = 'cl' OR atom.element = 'c')\n#SQL-like: Show COUNT(DISTINCT atom.element), WHERE bond.bond_id = 'TR001_1_8' AND (atom.element = 'cl' OR atom.element = 'c')\n#SQL: SELECT COUNT(DISTINCT atom.element) FROM atom INNER JOIN connected ON atom.atom_id = connected.atom_id INNER JOIN bond ON connected.bond_id = bond.bond_id WHERE bond.bond_id = 'TR001_1_8' AND (atom.element = 'cl' OR atom.element = 'c')\n```"
    ],
    "1126": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the name of players\" from the country \"Belgium\", so the SQL SELECT will fetch the player_name where the country is 'Belgium'.\n#columns: Player.player_name, Country.name\n#values: 'Belgium' refer to Country.name = 'Belgium'\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Country.name = 'Belgium'\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Country AS T2 ON T1.country_id = T2.id WHERE T2.name = 'Belgium'\n```"
    ],
    "407": [
        "```\n#reason: The question wants to list all types of cards in German, so the SQL SELECT will filter for language and ensure that both subtypes and supertypes are not null.\n#columns: cards.subtypes, cards.supertypes\n#values: 'German' refer to foreign_data.language = 'German', subtypes is not null refer to cards.subtypes IS NOT NULL, supertypes is not null refer to cards.supertypes IS NOT NULL\n#SELECT: SELECT content refer to cards.subtypes, cards.supertypes\n#SQL-like: Show cards.subtypes, cards.supertypes, WHERE foreign_data.language = 'German' AND cards.subtypes IS NOT NULL AND cards.supertypes IS NOT NULL\n#SQL: SELECT cards.subtypes, cards.supertypes FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'German' AND cards.subtypes IS NOT NULL AND cards.supertypes IS NOT NULL\n```"
    ],
    "1250": [
        "```\n#reason: The question wants to identify the patient with a normal proteinuria level who is diagnosed with SLE, so the SQL SELECT will filter based on the proteinuria level and the diagnosis.\n#columns: Patient.ID, Laboratory.`U-PRO`, Patient.Diagnosis\n#values: normal proteinuria level refers to 0 < `U-PRO` < 30 and diagnosed with SLE refers to Patient.Diagnosis = 'SLE'\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID, WHERE 0 < Laboratory.`U-PRO` < 30 AND Patient.Diagnosis = 'SLE'\n#SQL: SELECT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.`U-PRO` > 0 AND T2.`U-PRO` < 30 AND T1.Diagnosis = 'SLE'\n```"
    ],
    "314": [
        "```\n#reason: The question requires display in order: \"How many single bonds\". \"single bond\" is a filtering condition.\n#columns: bond.bond_type\n#values: single bond refers to bond.bond_type = '-'\n#SELECT: How many single bonds refer to COUNT(bond.bond_id)\n#SQL-like: Show COUNT(bond.bond_id), WHERE bond.bond_type = '-'\n#SQL: SELECT COUNT(bond_id) FROM bond WHERE bond_type = '-'\n```"
    ],
    "854": [
        "```\n#reason: The question wants to display the coordinates location of the circuits for the Australian Grand Prix, so the SQL SELECT will retrieve the latitude and longitude from the circuits table where the circuitId matches the raceId of the Australian Grand Prix.\n#columns: circuits.lat, circuits.lng\n#values: circuits for Australian grand prix refers to races.name = 'Australian Grand Prix' and circuits.circuitId = races.circuitId\n#SELECT: SELECT circuits.lat, circuits.lng refer to circuits.lat, circuits.lng\n#SQL-like: Show circuits.lat, circuits.lng WHERE races.name = 'Australian Grand Prix'\n#SQL: SELECT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Australian Grand Prix'\n```"
    ],
    "495": [
        "```\n#reason: The question wants to find the release date for the set which card \"Evacuation\" is in, so the SQL SELECT will retrieve the release date from the sets table by joining it with the cards table based on the card's set code.\n#columns: sets.releaseDate, cards.name\n#values: 'Evacuation' refer to cards.name = 'Evacuation'\n#SELECT: release date refers to sets.releaseDate\n#SQL-like: Show sets.releaseDate, WHERE cards.name = 'Evacuation'\n#SQL: SELECT T2.releaseDate FROM sets AS T1 INNER JOIN cards AS T2 ON T1.code = T2.setCode WHERE T2.name = 'Evacuation'\n```"
    ],
    "1533": [
        "```\n#reason: The question wants to identify the consumption status of customers who paid more than 29.00 per unit for a specific product. The SQL SELECT will retrieve the consumption status for those customers in August 2012, where the price per unit is calculated as Price / Amount.\n#columns: yearmonth.Consumption, transactions_1k.Price, transactions_1k.Amount, transactions_1k.ProductID\n#values: paid more than 29.00 per unit refers to (transactions_1k.Price / transactions_1k.Amount) > 29.00, August of 2012 refers to yearmonth.Date = '201208'\n#SELECT: SELECT yearmonth.Consumption refer to yearmonth.Consumption\n#SQL-like: Show yearmonth.Consumption WHERE (transactions_1k.Price / transactions_1k.Amount) > 29.00 AND yearmonth.Date = '201208'\n#SQL: SELECT T1.Consumption FROM yearmonth AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE (T2.Price / T2.Amount) > 29.00 AND T1.Date = '201208'\n```"
    ],
    "713": [
        "```\n#reason: The question wants to find the up vote number of the user who made a specific comment, so the SQL SELECT will retrieve the user's up vote number based on the comment text.\n#columns: users.UpVotes, comments.UserId\n#values: commented \"R is also lazy evaluated.\" refer to comments.Text = 'R is also lazy evaluated.'\n#SELECT: SELECT users.UpVotes refer to users.UpVotes, comments.UserId refer to comments.UserId\n#SQL-like: Show users.UpVotes, WHERE comments.Text = 'R is also lazy evaluated.'\n#SQL: SELECT users.UpVotes FROM users INNER JOIN comments ON users.Id = comments.UserId WHERE comments.Text = 'R is also lazy evaluated.'\n```"
    ],
    "949": [
        "```\n#reason: The question wants to identify the constructor with the highest points, so the SQL SELECT will filter for the highest value in the points column.\n#columns: constructors.name, constructorStandings.points\n#values: highest points refer to ORDER BY constructorStandings.points DESC LIMIT 1\n#SELECT: SELECT constructor name refer to constructors.name\n#SQL-like: Show constructors.name, ORDER BY constructorStandings.points DESC LIMIT 1\n#SQL: SELECT T1.name FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId ORDER BY T2.points DESC LIMIT 1\n```"
    ],
    "718": [
        "```\n#reason: The question wants to count the number of superheroes who have the superpower \"Super Strength\", so the SQL SELECT COUNT(superhero.id) and GROUP BY power_name will be used.\n#columns: superhero.id, superpower.power_name\n#values: super power of \"Super Strength\" refer to superpower.power_name = 'Super Strength'\n#SELECT: SELECT COUNT(superhero.id) refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE superpower.power_name = 'Super Strength'\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength'\n```"
    ],
    "862": [
        "```\n#reason: The question wants to find out \"how many drivers not finished the game\" for the \"Bahrain Grand Prix in 2007\". This involves filtering for the race name and checking for drivers whose finish time is null.\n#columns: results.raceId, results.time\n#values: Bahrain Grand Prix refers to races.name = 'Bahrain Grand Prix'; not finished refers to results.time IS NULL; in 2007 refers to races.year = 2007\n#SELECT: COUNT(results.raceId) refer to results.raceId\n#SQL-like: Show COUNT(results.raceId), WHERE results.time IS NULL AND races.name = 'Bahrain Grand Prix' AND races.year = 2007\n#SQL: SELECT COUNT(T1.raceId) FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T1.time IS NULL AND T2.name = 'Bahrain Grand Prix' AND T2.year = 2007\n```"
    ],
    "488": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the code for the set\". \"released on 2017/7/14\" is a filtering condition.\n#columns: sets.code\n#values: '2017/7/14' refer to sets.releaseDate = '2017-07-14'\n#SELECT: SELECT sets.code refer to sets.code\n#SQL-like: Show sets.code, WHERE sets.releaseDate = '2017-07-14'\n#SQL: SELECT sets.code FROM sets WHERE sets.releaseDate = '2017-07-14'\n```"
    ],
    "483": [
        "```\n#reason: The question wants to list the Italian text ruling of all the cards in the set Coldsnap, so the SQL SELECT will include the foreign_data.text for cards associated with the set named 'Coldsnap' and filtered by the language 'Italian'.\n#columns: foreign_data.text\n#values: 'set Coldsnap' refer to sets.name = 'Coldsnap', 'Italian' refers to foreign_data.language = 'Italian'\n#SELECT: SELECT foreign_data.text\n#SQL-like: Show foreign_data.text, WHERE sets.name = 'Coldsnap' AND foreign_data.language = 'Italian'\n#SQL: SELECT foreign_data.text FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND foreign_data.language = 'Italian'\n```"
    ],
    "347": [
        "```\n#reason: The question wants to find all cards illustrated by Stephen Daniele and describe the text of the ruling of these cards while stating if these cards have missing or degraded properties and values. Therefore, the SQL SELECT will include the card id and the ruling text, along with the content warning status.\n#columns: cards.id, rulings.text, cards.hasContentWarning\n#values: 'Stephen Daniele' refers to cards.artist = 'Stephen Daniele', 'has missing or degraded properties and values' refers to cards.hasContentWarning = 1\n#SELECT: SELECT cards.id, rulings.text, cards.hasContentWarning\n#SQL-like: Show cards.id, rulings.text, cards.hasContentWarning WHERE cards.artist = 'Stephen Daniele' AND cards.hasContentWarning = 1\n#SQL: SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele' AND T1.hasContentWarning = 1\n```"
    ],
    "851": [
        "```\n#reason: The question wants to display the \"positions\" of the circuits built by the constructor Renault, so the SQL SELECT will include the positions from the races table joined with the constructors table where the constructor name is Renault.\n#columns: races.position\n#values: 'Renault' refer to constructors.name = 'Renault'\n#SELECT: SELECT races.position refer to races.position\n#SQL-like: Show races.position WHERE constructors.name = 'Renault'\n#SQL: SELECT T1.position FROM races AS T1 INNER JOIN constructorResults AS T2 ON T1.raceId = T2.raceId INNER JOIN constructors AS T3 ON T2.constructorId = T3.constructorId WHERE T3.name = 'Renault'\n```"
    ],
    "781": [
        "```\n#reason: The question wants to provide the heights of the heroes whose eye colours are amber, so the SQL SELECT will retrieve the height_cm from the superhero table where the eye_colour_id matches the id in the colour table for the colour 'Amber'.\n#columns: superhero.height_cm\n#values: 'eye colours are amber' refer to colour.colour = 'Amber' WHERE superhero.eye_colour_id = colour.id\n#SELECT: SELECT height_cm refer to superhero.height_cm\n#SQL-like: Show height_cm WHERE colour.colour = 'Amber'\n#SQL: SELECT T1.height_cm FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Amber'\n```"
    ],
    "1328": [
        "```\n#reason: The question wants to list the last name of all the students who majored in Law and Constitutional Studies, so the SQL SELECT will retrieve the last name from the member table where the member's major corresponds to the specified major name.\n#columns: member.last_name, major.major_name\n#values: 'Law and Constitutional Studies' refer to major.major_name = 'Law and Constitutional Studies'\n#SELECT: SELECT member.last_name refer to member.last_name\n#SQL-like: Show member.last_name, WHERE major.major_name = 'Law and Constitutional Studies'\n#SQL: SELECT T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Law and Constitutional Studies'\n```"
    ],
    "1341": [
        "```\n#reason: The question wants to display the location for the event named 'Spring Budget Review', so the SQL SELECT will retrieve the location from the event table where the event name matches 'Spring Budget Review'.\n#columns: event.location\n#values: 'Spring Budget Review' refer to event.event_name = 'Spring Budget Review'\n#SELECT: SELECT location refer to event.location\n#SQL-like: Show event.location WHERE event.event_name = 'Spring Budget Review'\n#SQL: SELECT location FROM event WHERE event_name = 'Spring Budget Review'\n```"
    ],
    "153": [
        "```\n#reason: The question wants to find the number of 'classic' cards that are eligible for loan, so the SQL SELECT will count the number of 'classic' cards where the account type is 'OWNER'.\n#columns: card.type, disp.type, loan.account_id\n#values: 'classic' refers to card.type = 'classic', 'OWNER' refers to disp.type = 'OWNER'\n#SELECT: COUNT(loan.account_id) refer to loan.account_id\n#SQL-like: Show COUNT(loan.account_id), WHERE card.type = 'classic' AND disp.type = 'OWNER'\n#SQL: SELECT COUNT(T1.account_id) FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T1.type = 'classic' AND T2.type = 'OWNER'\n```"
    ],
    "1100": [
        "```\n#reason: The question wants to find the highest overall rating received by Dorlan Pabon, so the SQL SELECT will retrieve the maximum overall rating for the player with the name 'Dorlan Pabon'.\n#columns: Player_Attributes.overall_rating\n#values: 'Dorlan Pabon' refers to Player.player_name = 'Dorlan Pabon'\n#SELECT: SELECT MAX(overall_rating) refer to Player_Attributes.overall_rating\n#SQL-like: Show MAX(Player_Attributes.overall_rating) WHERE Player.player_name = 'Dorlan Pabon'\n#SQL: SELECT MAX(T1.overall_rating) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Dorlan Pabon'\n```"
    ],
    "1289": [
        "```\n#reason: The question wants to determine the number of patients diagnosed with SJS who have a normal level of total protein, so the SQL SELECT will count the patients that meet these conditions.\n#columns: Patient.Diagnosis, Laboratory.TP, Patient.ID\n#values: diagnosed with SJS refer to Patient.Diagnosis = 'SJS', normal level of total protein refers to Laboratory.TP > 6.0 AND Laboratory.TP < 8.5\n#SELECT: SELECT COUNT(Patient.ID) refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Patient.Diagnosis = 'SJS' AND Laboratory.TP > 6.0 AND Laboratory.TP < 8.5\n#SQL: SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Diagnosis = 'SJS' AND T2.TP > 6.0 AND T2.TP < 8.5\n```"
    ],
    "68": [
        "```\n#reason: The question wants to identify \"which county reported the most number of school closures in the 1980s\" with the condition that the school ownership code belongs to Youth Authority Facilities (CEA). This means we need to filter by the years between 1980 and 1989 and the SOC code of 11.\n#columns: schools.County, schools.SOC, schools.ClosedDate\n#values: 1980s refers to \"strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989'\" and Youth Authority Facilities (CEA) refers to \"SOC = '11'\"\n#SELECT: SELECT county refers to schools.County\n#SQL-like: Show schools.County, WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND SOC = '11', GROUP BY schools.County, ORDER BY COUNT(schools.ClosedDate) DESC LIMIT 1\n#SQL: SELECT schools.County FROM schools WHERE strftime('%Y', ClosedDate) BETWEEN '1980' AND '1989' AND SOC = '11' GROUP BY schools.County ORDER BY COUNT(ClosedDate) DESC LIMIT 1\n```"
    ],
    "1353": [
        "```\n#reason: The question wants to display \"Christof Nielson's zip code type\", so the SQL SELECT will retrieve the zip code type based on the member's first and last name.\n#columns: zip_code.type, member.first_name, member.last_name\n#values: 'Christof Nielson' refer to member.first_name = 'Christof' AND member.last_name = 'Nielson'\n#SELECT: zip code type refer to zip_code.type\n#SQL-like: Show zip_code.type, WHERE member.first_name = 'Christof' AND member.last_name = 'Nielson'\n#SQL: SELECT T2.type FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T2.first_name = 'Christof' AND T2.last_name = 'Nielson'\n```"
    ],
    "1357": [
        "```\n#reason: The question wants to state the date Connor Hilton paid his/her dues, so the SQL SELECT will retrieve the date_received from the income table where the member's name matches the given first and last names and the source of the income is 'Dues'.\n#columns: income.date_received\n#values: 'Connor Hilton' refers to income.link_to_member in relation to the member table and the conditions first_name = 'Connor' AND last_name = 'Hilton'; 'source = Dues' refers to income.source = 'Dues'\n#SELECT: SELECT date_received refer to income.date_received\n#SQL-like: Show income.date_received, WHERE income.source = 'Dues' AND member.first_name = 'Connor' AND member.last_name = 'Hilton'\n#SQL: SELECT income.date_received FROM income INNER JOIN member ON income.link_to_member = member.member_id WHERE income.source = 'Dues' AND member.first_name = 'Connor' AND member.last_name = 'Hilton'\n```"
    ],
    "865": [
        "```\n#reason: The question wants to find the oldest driver who finished the race No. 592, so the SQL SELECT will filter drivers based on their finish time and order them by date of birth in ascending order.\n#columns: drivers.dob, drivers.driverId\n#values: finished the race refers to time IS NOT NULL and race number refers to results.raceId = 592\n#SELECT: SELECT drivers.driverId refer to drivers.driverId\n#SQL-like: Show drivers.driverId, WHERE time IS NOT NULL AND results.raceId = 592, ORDER BY drivers.dob ASC LIMIT 1\n#SQL: SELECT T1.driverId FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.time IS NOT NULL AND T2.raceId = 592 ORDER BY T1.dob ASC LIMIT 1\n```"
    ],
    "652": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question want to list the post IDs and badge names of the user Samuel in 2013, so the SQL SELECT postHistory.PostId, badges.Name and ...)\n#columns: postHistory.PostId, badges.Name\n#values: 'Samuel' refer to users.DisplayName = 'Samuel', 'in 2013' refers to strftime('%Y', postHistory.CreationDate) = '2013' AND strftime('%Y', badges.Date) = '2013'\n#SELECT: SELECT postHistory.PostId, badges.Name\n#SQL-like: Show postHistory.PostId, badges.Name WHERE users.DisplayName = 'Samuel' AND strftime('%Y', postHistory.CreationDate) = '2013' AND strftime('%Y', badges.Date) = '2013'\n#SQL: SELECT T1.PostId, T2.Name FROM postHistory AS T1 INNER JOIN users AS T3 ON T1.UserDisplayName = T3.DisplayName INNER JOIN badges AS T2 ON T2.UserId = T3.Id WHERE T3.DisplayName = 'Samuel' AND strftime('%Y', T1.CreationDate) = '2013' AND strftime('%Y', T2.Date) = '2013'\n```"
    ],
    "693": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the number of posts and comments left by the user with the latest created user account, so the SQL SELECT will count the posts and comments grouped by the user.\n#columns: users.Id, COUNT(posts.Id), COUNT(comments.Id)\n#values: latest created user account refers to users.CreationDate = (SELECT MAX(CreationDate) FROM users)\n#SELECT: SELECT users.Id, COUNT(posts.Id) AS post_count, COUNT(comments.Id) AS comment_count\n#SQL-like: Show users.Id, COUNT(posts.Id), COUNT(comments.Id), WHERE users.CreationDate = (SELECT MAX(CreationDate) FROM users) GROUP BY users.Id\n#SQL: SELECT users.Id, COUNT(posts.Id) AS post_count, COUNT(comments.Id) AS comment_count FROM users LEFT JOIN posts ON users.Id = posts.OwnerUserId LEFT JOIN comments ON users.Id = comments.UserId WHERE users.CreationDate = (SELECT MAX(CreationDate) FROM users) GROUP BY users.Id\n```"
    ],
    "567": [
        "```\n#reason: The question wants to count the number of posts owned by the user with the display name \"Tiago Pasqualini\", so the SQL SELECT COUNT(posts.Id) and the filtering condition is based on the user's display name.\n#columns: posts.Id, users.DisplayName\n#values: 'Tiago Pasqualini' refer to users.DisplayName = 'Tiago Pasqualini'\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id), WHERE users.DisplayName = 'Tiago Pasqualini'\n#SQL: SELECT COUNT(T1.Id) FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName = 'Tiago Pasqualini'\n```"
    ],
    "668": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the display name of the user who has acquired the highest amount of badges, which refers to finding the user with the maximum count of badges. \n#columns: badges.UserId, badges.Name, users.DisplayName\n#values: highest amount of badges refers to MAX(COUNT(badges.Name))\n#SELECT: display name of the user who acquired the highest amount of badges refers to users.DisplayName\n#SQL-like: Show users.DisplayName, where the count of badges is the highest (ORDER BY COUNT(badges.Name) DESC)\n#SQL: SELECT T2.DisplayName FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id GROUP BY T1.UserId ORDER BY COUNT(T1.Name) DESC LIMIT 1\n```"
    ],
    "1047": [
        "```\n#reason: The question wants to find the heading accuracy of the football player Francois Affolter, and this is specifically for the date of 18/09/2014.\n#columns: Player.player_name, Player_Attributes.heading_accuracy, Player_Attributes.date\n#values: 'Francois Affolter' refer to Player.player_name = 'Francois Affolter', '18/09/2014' refer to Player_Attributes.date = '2014-09-18 00:00:00'\n#SELECT: SELECT Player_Attributes.heading_accuracy refer to Player_Attributes.heading_accuracy\n#SQL-like: Show Player_Attributes.heading_accuracy WHERE Player.player_name = 'Francois Affolter' AND Player_Attributes.date = '2014-09-18 00:00:00'\n#SQL: SELECT T1.heading_accuracy FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Francois Affolter' AND T1.date = '2014-09-18 00:00:00'\n```"
    ],
    "783": [
        "```\n#reason: The question wants to provide the \"eye colours of the heroes\" based on the condition that the \"skin colours are gold\". The \"skin colours are gold\" refers to colour.colour = 'Gold' where skin_colour_id = colour.id, and \"eye colours\" refers to superhero.eye_colour_id. \n#columns: superhero.eye_colour_id, colour.colour\n#values: skin colours are gold refer to colour.colour = 'Gold' \n#SELECT: SELECT superhero.eye_colour_id refer to superhero.eye_colour_id.\n#SQL-like: Show superhero.eye_colour_id, WHERE colour.colour = 'Gold' \n#SQL: SELECT T1.eye_colour_id FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.skin_colour_id = T2.id WHERE T2.colour = 'Gold'\n```"
    ],
    "896": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of races where Hamilton was not in the 1st position since 2010. Thus, the SQL SELECT will count raceId considering the conditions and compute the percentage based on the counts.\n#columns: driverStandings.position, results.raceId, drivers.surname, races.year\n#values: surname = 'Hamilton' refers to drivers.surname = 'Hamilton', year >= 2010 refers to races.year >= 2010\n#SELECT: percentage refer to (COUNT(raceId) WHERE surname = 'Hamilton' AND position > 1), (COUNT(raceId) WHERE surname = 'Hamilton')\n#SQL-like: Show DIVIDE(COUNT(raceId WHERE surname = 'Hamilton' AND position > 1), COUNT(raceId WHERE surname = 'Hamilton')), WHERE year >= 2010\n#SQL: SELECT CAST(COUNT(CASE WHEN T3.position > 1 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T3.raceId) FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId INNER JOIN results AS T3 ON T2.raceId = T3.raceId INNER JOIN races AS T4 ON T3.raceId = T4.raceId WHERE T1.surname = 'Hamilton' AND T4.year >= 2010\n```"
    ],
    "730": [
        "```\n#reason: The question wants to list the superheroes from Marvel Comics who have the super power of 'Super Strength', so the SQL SELECT will filter superheroes based on the publisher and the superpower.\n#columns: superhero.superhero_name, publisher.publisher_name, superpower.power_name\n#values: 'the superheroes from Marvel Comics' refer to publisher.publisher_name = 'Marvel Comics', 'super power of \"Super Strength\"' refer to superpower.power_name = 'Super Strength'\n#SELECT: SELECT superhero_name, publisher_name, power_name refer to superhero.superhero_name, publisher.publisher_name, superpower.power_name\n#SQL-like: Show superhero.superhero_name, publisher.publisher_name, superpower.power_name, WHERE publisher.publisher_name = 'Marvel Comics' AND superpower.power_name = 'Super Strength'\n#SQL: SELECT T1.superhero_name, T2.publisher_name, T3.power_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN hero_power AS T4 ON T1.id = T4.hero_id INNER JOIN superpower AS T3 ON T4.power_id = T3.id WHERE T2.publisher_name = 'Marvel Comics' AND T3.power_name = 'Super Strength'\n```"
    ],
    "874": [
        "```\n#reason: Analyze how to generate SQL based on the question. (The question wants to find out who finished second in the San Marino Grand Prix in 2006, so the SQL SELECT will retrieve the driver's name who finished in position 2 for that specific race.)\n#columns: drivers.forename, drivers.surname, results.position\n#values: 'San Marino Grand Prix' refers to races.name = 'San Marino Grand Prix', '2006' refers to races.year = 2006, 'finished second' refers to results.position = 2\n#SELECT: SELECT drivers.forename, drivers.surname refer to drivers.forename, drivers.surname\n#SQL-like: Show drivers.forename, drivers.surname WHERE results.position = 2 AND races.name = 'San Marino Grand Prix' AND races.year = 2006\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T2.position = 2 AND T3.name = 'San Marino Grand Prix' AND T3.year = 2006\n```"
    ],
    "1442": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of events that went over budget, so the SQL SELECT will count the number of events where the remaining budget is less than 0 and divide that by the total number of events, multiplied by 100.\n#columns: budget.remaining, budget.budget_id, event.event_id\n#values: went over budget refers to remaining < 0\n#SELECT: percentage of events that went over budget\n#SQL-like: Show DIVIDE(SUM(remaining < 0), COUNT(event_id)) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN remaining < 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(event_id) FROM budget\n```"
    ],
    "1420": [
        "```\n#reason: The question wants to identify the major that a member with the position of 'Vice President' has joined, so the SQL SELECT will retrieve the major name associated with that member's position.\n#columns: major.major_name, member.position\n#values: 'Vice President' refer to member.position = 'Vice President'\n#SELECT: SELECT major.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'\n#SQL-like: Show major.major_name WHERE member.position = 'Vice President'\n#SQL: SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'\n```"
    ],
    "667": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"title of the post\" associated with the \"oldest post link\", defined as the minimum creation date of the post link. Therefore, the SQL SELECT will retrieve the title from the posts table based on the minimum creation date from the postLinks table.\n#columns: posts.Title, postLinks.CreationDate\n#values: oldest post link refers to MIN(postLinks.CreationDate)\n#SELECT: title of the post refers to posts.Title\n#SQL-like: Show posts.Title, WHERE postLinks.CreationDate is the oldest (MIN(CreationDate))\n#SQL: SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.PostId ORDER BY T2.CreationDate LIMIT 1\n```"
    ],
    "834": [
        "```\n#reason: The question wants to calculate the percentage of female superheroes created by George Lucas, so the SQL SELECT will count the number of female superheroes and divide it by the total number of superheroes created by George Lucas, multiplying by 100.\n#columns: publisher.publisher_name, superhero.gender_id, superhero.id\n#values: created by George Lucas refers to publisher.publisher_name = 'George Lucas'\n#SELECT: SELECT MULTIPLY(DIVIDE(SUM(gender.gender = 'Female'), COUNT(superhero.id)), 100.0) refer to superhero.gender_id\n#SQL-like: Show MULTIPLY(DIVIDE(SUM(gender.gender = 'Female'), COUNT(superhero.id)), 100.0), WHERE publisher.publisher_name = 'George Lucas'\n#SQL: SELECT CAST(SUM(CASE WHEN T3.gender = 'Female' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'\n```"
    ],
    "894": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to find the best lap time, so the SQL SELECT will retrieve the driver and race associated with the minimum lap time in milliseconds)\n#columns: drivers.forename, drivers.surname, races.name\n#values: the best lap time refers to lapTimes.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes)\n#SELECT: SELECT drivers.forename, drivers.surname, races.name refer to drivers.forename, drivers.surname, races.name\n#SQL-like: Show drivers.forename, drivers.surname, races.name WHERE lapTimes.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes)\n#SQL: SELECT T1.forename, T1.surname, T2.name FROM lapTimes AS T3 INNER JOIN drivers AS T1 ON T3.driverId = T1.driverId INNER JOIN races AS T2 ON T3.raceId = T2.raceId WHERE T3.milliseconds = (SELECT MIN(milliseconds) FROM lapTimes)\n```"
    ],
    "998": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the number of victories acquired by the driver who ranked 91st in terms of points, so the SQL SELECT will fetch the number of wins based on the driver's ranking.\n#columns: driverStandings.wins\n#values: 'rank is 91st' refers to 'driverStandings.position = 91'\n#SELECT: SELECT wins refer to driverStandings.wins\n#SQL-like: Show wins WHERE driverStandings.position = 91\n#SQL: SELECT wins FROM driverStandings WHERE position = 91\n```"
    ],
    "369": [
        "```\n#reason: The question wants to count the number of cards illustrated in German that have been reprinted, so the SQL SELECT will count the cards where the language is German and the reprint status is 1.\n#columns: cards.id, cards.isReprint, foreign_data.language\n#values: 'German' refer to foreign_data.language = 'German', 'reprinted' refer to cards.isReprint = 1\n#SELECT: SELECT COUNT(cards.id) refer to cards.id\n#SQL-like: Show COUNT(cards.id), WHERE foreign_data.language = 'German' AND cards.isReprint = 1\n#SQL: SELECT COUNT(cards.id) FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'German' AND cards.isReprint = 1\n```"
    ],
    "1523": [
        "```\n#reason: The question requires determining the \"country\" of the card owner with a specific card number. The card number '667467' is the filtering condition.\n#columns: gasstations.Country, transactions_1k.CardID, transactions_1k.CustomerID\n#values: card owner refers to transactions_1k.CardID = 667467\n#SELECT: country refers to gasstations.Country\n#SQL-like: Show gasstations.Country WHERE transactions_1k.CardID = 667467\n#SQL: SELECT T1.Country FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.CardID = 667467\n```"
    ],
    "76": [
        "```\n#reason: The question wants to display the \"city location\" of the \"high school level school\" with \"Lunch Provision 2\" whose \"lowest grade is 9\" and \"highest grade is 12\" in the \"county of Merced\". The filtering conditions are based on the values of the columns in the database.\n#columns: schools.City, schools.EILCode, frpm.`NSLP Provision Status`, schools.GSoffered\n#values: 'county of Merced' refers to schools.County = 'Merced', 'Lunch Provision 2' refers to frpm.`NSLP Provision Status` = 'Lunch Provision 2', 'lowest grade is 9' refers to schools.GSoffered LIKE '9-%', 'highest grade is 12' refers to schools.GSoffered LIKE '%-12', 'high school level school' refers to schools.EILCode = 'HS'\n#SELECT: SELECT schools.City\n#SQL-like: Show schools.City WHERE schools.County = 'Merced' AND frpm.`NSLP Provision Status` = 'Lunch Provision 2' AND schools.EILCode = 'HS' AND schools.GSoffered LIKE '9-%' AND schools.GSoffered LIKE '%-12'\n#SQL: SELECT schools.City FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.County = 'Merced' AND frpm.`NSLP Provision Status` = 'Lunch Provision 2' AND schools.EILCode = 'HS' AND schools.GSoffered LIKE '9-%' AND schools.GSoffered LIKE '%-12'\n```"
    ],
    "93": [
        "```\n#reason: The question wants to determine the number of male customers living in North Bohemia with an average salary greater than 8000, so the SQL SELECT will count the clients based on the specified conditions.\n#columns: client.gender, district.A3, district.A11\n#values: male customers refer to client.gender = 'M', living in North Bohemia refers to district.A3 = 'north Bohemia', average salary greater than 8000 refers to district.A11 > 8000\n#SELECT: SELECT COUNT(client.client_id) refer to client.client_id\n#SQL-like: Show COUNT(client.client_id), WHERE client.gender = 'M' AND district.A3 = 'north Bohemia' AND district.A11 > 8000\n#SQL: SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'M' AND T2.A3 = 'north Bohemia' AND T2.A11 > 8000\n```"
    ],
    "520": [
        "```\n#reason: The question wants to identify the illustrator who has illustrated the least amount of cards and to display the format of play of those cards. This involves counting the number of cards for each illustrator, determining the minimum count, and selecting the corresponding format of play for that illustrator. \n#columns: cards.artist, legalities.format\n#values: the least amount of cards refers to (SELECT artist COUNT(cards.id)) GROUP BY artist\n#SELECT: SELECT legalities.format \n#SQL-like: Show legalities.format WHERE artist is the one with least count of cards ORDER BY COUNT(cards.id) LIMIT 1\n#SQL: SELECT T2.format FROM cards AS T1 INNER JOIN legalities ON T1.uuid = legalities.uuid GROUP BY T1.artist HAVING COUNT(T1.id) = (SELECT MIN(card_count) FROM (SELECT COUNT(id) AS card_count FROM cards GROUP BY artist))\n```"
    ],
    "1224": [
        "```\n#reason: The question wants to find the highest total bilirubin level recorded and the details of the patient associated with that level, so the SQL SELECT will retrieve the patient's ID, sex, and birthday along with the maximum total bilirubin.\n#columns: Laboratory.`T-BIL`, Patient.ID, Patient.SEX, Patient.Birthday\n#values: the highest total bilirubin level refers to Laboratory.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory)\n#SELECT: SELECT Patient.ID, Patient.SEX, Patient.Birthday refer to Patient.ID, Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Birthday WHERE Laboratory.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory)\n#SQL: SELECT P.ID, P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory)\n```"
    ],
    "63": [
        "```\n#reason: The question wants to display the names of all the administrators, the name of the school, and the city to which it belongs for chartered schools with charter number 00D2, so the SQL SELECT will include the administrators' names, school name, and city, with filtering conditions for charter number and charter status.\n#columns: schools.AdmFName1, schools.AdmLName1, schools.School, schools.City\n#values: chartered schools refer to schools.Charter = 1 AND charter number 00D2 refers to schools.CharterNum = '00D2'\n#SELECT: SELECT administrators' first name, administrators' last name, school name, city refer to schools.AdmFName1, schools.AdmLName1, schools.School, schools.City\n#SQL-like: Show schools.AdmFName1, schools.AdmLName1, schools.School, schools.City WHERE schools.Charter = 1 AND schools.CharterNum = '00D2'\n#SQL: SELECT schools.AdmFName1, schools.AdmLName1, schools.School, schools.City FROM schools WHERE schools.Charter = 1 AND schools.CharterNum = '00D2'\n```"
    ],
    "501": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the card name in a specific set with the highest converted mana cost, so the SQL SELECT should include the card name and filter by the set name while finding the maximum converted mana cost.\n#columns: cards.name, cards.convertedManaCost\n#values: set 'Journey into Nyx Hero's Path' refers to 'name = ''Journey into Nyx Hero''s Path'''\n#SELECT: SELECT cards.name refer to the card name with the highest converted mana cost.\n#SQL-like: Show cards.name WHERE cards.setCode = 'Journey into Nyx Hero''s Path' ORDER BY cards.convertedManaCost DESC LIMIT 1\n#SQL: SELECT name FROM cards WHERE setCode = 'Journey into Nyx Hero''s Path' ORDER BY convertedManaCost DESC LIMIT 1\n```"
    ],
    "1502": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the chains of gas stations that have transactions in euro, so the SQL SELECT will involve joining the gasstations and transactions_1k tables based on GasStationID and filtering for customers with currency 'EUR'.\n#columns: gasstations.Segment, gasstations.ChainID\n#values: 'transactions in euro' refer to customers.Currency = 'EUR'\n#SELECT: SELECT DISTINCT gasstations.Segment, gasstations.ChainID refer to gasstations.Segment, gasstations.ChainID\n#SQL-like: Show DISTINCT gasstations.Segment, gasstations.ChainID WHERE transactions_1k.CustomerID IN (SELECT CustomerID FROM customers WHERE Currency = 'EUR')\n#SQL: SELECT DISTINCT g.Segment, g.ChainID FROM gasstations AS g INNER JOIN transactions_1k AS t ON g.GasStationID = t.GasStationID INNER JOIN customers AS c ON t.CustomerID = c.CustomerID WHERE c.Currency = 'EUR'\n```"
    ],
    "649": [
        "```\n#reason: The question wants to describe the post history counts and last edit date of the post titled \"What is the best introductory Bayesian statistics textbook?\", so the SQL SELECT will include the post history counts and the last edit date of the corresponding post.\n#columns: postHistory.PostId, postHistory.UserId, posts.LastEditDate\n#values: 'What is the best introductory Bayesian statistics textbook?' refer to posts.Title = 'What is the best introductory Bayesian statistics textbook.'\n#SELECT: post history counts refer to COUNT(postHistory.PostId), last edit date refer to posts.LastEditDate\n#SQL-like: Show COUNT(postHistory.PostId), posts.LastEditDate, WHERE posts.Title = 'What is the best introductory Bayesian statistics textbook.'\n#SQL: SELECT COUNT(T1.PostId), T2.LastEditDate FROM postHistory AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'What is the best introductory Bayesian statistics textbook.'\n```"
    ],
    "1446": [
        "```\n#reason: The question wants to calculate the percentage of zip codes that are PO boxes, so the SQL SELECT will count the number of PO Box types and divide it by the total count of zip codes.\n#columns: zip_code.type, zip_code.zip_code\n#values: type = 'PO Box' refers to zip_code.type = 'PO Box'\n#SELECT: percentage of zip codes that are PO boxes refer to DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100\n#SQL-like: Show DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100\n#SQL: SELECT CAST(SUM(CASE WHEN T1.type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.zip_code) FROM zip_code AS T1\n```"
    ],
    "776": [
        "```\n#reason: The question wants to provide the hero name and race of Charles Chandler, so the SQL SELECT will include superhero_name and race based on the filtering condition of the full name being 'Charles Chandler'.\n#columns: superhero.superhero_name, race.race\n#values: Charles Chandler refers to superhero.full_name = 'Charles Chandler'\n#SELECT: SELECT superhero_name, race refer to superhero.superhero_name, race.race\n#SQL-like: Show superhero.superhero_name, race.race WHERE superhero.full_name = 'Charles Chandler'\n#SQL: SELECT T1.superhero_name, T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.full_name = 'Charles Chandler'\n```"
    ],
    "913": [
        "```\n#reason: The question wants to find the country where the circuit with the highest altitude is located, so the SQL SELECT will retrieve the country and the maximum altitude of the circuit.\n#columns: circuits.country, circuits.alt\n#values: highest altitude refers to max(alt) \n#SELECT: country refer to circuits.country, circuit refer to max(alt) refer to circuits.alt\n#SQL-like: Show circuits.country, max(circuits.alt)\n#SQL: SELECT circuits.country, MAX(circuits.alt) FROM circuits GROUP BY circuits.country ORDER BY MAX(circuits.alt) DESC LIMIT 1\n```"
    ],
    "610": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question want to find the name of the badge that users who have the highest reputation obtained, so the SQL SELECT will find the badge names by joining users and badges on UserId and filtering them by the highest reputation.)\n#columns: badges.Name, users.Reputation\n#values: highest reputation refers to Reputation = (SELECT MAX(Reputation) FROM users)\n#SELECT: SELECT badges.Name refer to badges.Name\n#SQL-like: Show badges.Name WHERE users.Reputation = MAX(Reputation)\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Reputation = (SELECT MAX(Reputation) FROM users)\n```"
    ],
    "963": [
        "```\n#reason: The question wants to count the number of French drivers who have a lap time of less than 02:00.00, so the SQL SELECT will count the drivers based on the specified conditions.\n#columns: drivers.driverId, lapTimes.time\n#values: French drivers refer to drivers.nationality = 'French', lap time less than 02:00.00 refers to CAST(SUBSTR(lapTimes.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(lapTimes.time, 4, 2) AS INTEGER) < 120\n#SELECT: COUNT(drivers.driverId) refer to COUNT(drivers.driverId)\n#SQL-like: Show COUNT(drivers.driverId), WHERE drivers.nationality = 'French' AND CAST(SUBSTR(lapTimes.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(lapTimes.time, 4, 2) AS INTEGER) < 120\n#SQL: SELECT COUNT(T1.driverId) FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T1.nationality = 'French' AND CAST(SUBSTR(T2.time, 1, 2) AS INTEGER) * 60 + CAST(SUBSTR(T2.time, 4, 2) AS INTEGER) < 120\n```"
    ],
    "1342": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the cost for the \"Posters\" on 2019/9/4, so the SQL SELECT will retrieve the cost from the expense table where the expense description matches \"Posters\" and the expense date is '2019-09-04'.\n#columns: expense.cost, expense.expense_date, expense.expense_description\n#values: 'Posters' refer to expense.expense_description = 'Posters', '2019/9/4' refer to expense.expense_date = '2019-09-04'\n#SELECT: cost refer to expense.cost\n#SQL-like: Show expense.cost, WHERE expense.expense_description = 'Posters' AND expense.expense_date = '2019-09-04'\n#SQL: SELECT T1.cost FROM expense AS T1 WHERE T1.expense_description = 'Posters' AND T1.expense_date = '2019-09-04'\n```"
    ],
    "891": [
        "```\n#reason: The question requires displaying \"all drivers\" in the \"2010 Singapore Grand Prix\" ordered by their \"position stands\". \n#columns: drivers.driverId, drivers.forename, drivers.surname, results.position\n#values: 2010 Singapore Grand Prix refers to races.year = 2010 AND races.name = 'Singapore Grand Prix'\n#SELECT: SELECT driverId, forename, surname, position refer to drivers.driverId, drivers.forename, drivers.surname, results.position\n#SQL-like: Show drivers.driverId, drivers.forename, drivers.surname, results.position WHERE races.year = 2010 AND races.name = 'Singapore Grand Prix' ORDER BY results.position\n#SQL: SELECT T1.driverId, T2.forename, T2.surname, T3.position FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T3.year = 2010 AND T3.name = 'Singapore Grand Prix' ORDER BY T3.position\n```"
    ],
    "837": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the hero ID of the superhero with the lowest attribute value, so the SQL SELECT statement will focus on obtaining the hero_id where the attribute_value is minimized.\n#columns: hero_attribute.hero_id, hero_attribute.attribute_value\n#values: lowest attribute value refers to attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute)\n#SELECT: SELECT hero ID refer to hero_attribute.hero_id\n#SQL-like: Show hero_attribute.hero_id, WHERE hero_attribute.attribute_value is the minimum\n#SQL: SELECT hero_id FROM hero_attribute WHERE attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute)\n```"
    ],
    "641": [
        "```\n#reason: The question wants to count the number of users who received the commentator badge in 2014, so the SQL SELECT COUNT(UserId) and the filtering conditions are based on the badge name and the year of the date.\n#columns: badges.UserId, badges.Name, badges.Date\n#values: 'Commentator' refer to badges.Name = 'Commentator', 'year(Date) = 2014' refer to strftime('%Y', badges.Date) = '2014'\n#SELECT: SELECT COUNT(UserId) refer to COUNT(badges.UserId)\n#SQL-like: Show COUNT(UserId), WHERE badges.Name = 'Commentator' AND strftime('%Y', badges.Date) = '2014'\n#SQL: SELECT COUNT(UserId) FROM badges WHERE badges.Name = 'Commentator' AND strftime('%Y', badges.Date) = '2014'\n```"
    ],
    "1254": [
        "```\n#reason: The question wants to determine how many patients have a normal Ig A level and came to the hospital after a specific date, so the SQL SELECT will count the distinct patients based on the filtering conditions.\n#columns: Patient.ID, Laboratory.IGA, Patient.`First Date`\n#values: normal Ig A level refers to Laboratory.IGA > 80 AND Laboratory.IGA < 500, came to the hospital after 1990/1/1 refers to strftime('%Y', Patient.`First Date`) >= '1990'\n#SELECT: How many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.IGA > 80 AND Laboratory.IGA < 500 AND strftime('%Y', Patient.`First Date`) >= '1990'\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.IGA > 80 AND T2.IGA < 500 AND strftime('%Y', T1.`First Date`) >= '1990'\n```"
    ],
    "1166": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the symptoms observed by the youngest patient who has undergone a medical examination, so the SQL SELECT will retrieve the symptoms and diagnosis of the patient with the maximum birthday value.\n#columns: Patient.Symptoms, Patient.Diagnosis\n#values: youngest patient refers to MAX(Patient.Birthday)\n#SELECT: SELECT Patient.Symptoms, Patient.Diagnosis\n#SQL-like: Show Patient.Symptoms, Patient.Diagnosis, where Patient.Birthday is maximized\n#SQL: SELECT T1.Symptoms, T1.Diagnosis FROM Patient AS T1 WHERE T1.Birthday = (SELECT MAX(Birthday) FROM Patient)\n```"
    ],
    "684": [
        "```\n#reason: The question wants to identify the percentage of teenage users, so the SQL SELECT will count the number of users whose age is between 13 and 18 and divide it by the total number of users.\n#columns: users.Id, users.Age\n#values: 'teenage users' refer to users.Age BETWEEN 13 AND 18\n#SELECT: SELECT DIVIDE(COUNT(Id WHERE Age BETWEEN 13 AND 18), COUNT(Id)) as percentage refer to users.Id\n#SQL-like: Show DIVIDE(COUNT(Id WHERE Age BETWEEN 13 AND 18), COUNT(Id)) as percentage\n#SQL: SELECT CAST(COUNT(CASE WHEN Age BETWEEN 13 AND 18 THEN 1 END) AS REAL) * 100 / COUNT(Id) FROM users\n```"
    ],
    "594": [
        "```\n#reason: The question wants to identify the user who created a specific post (post ID 1) and to retrieve the reputation of that user, so the SQL SELECT will include the user's display name and reputation. \n#columns: users.DisplayName, users.Reputation\n#values: post ID 1 refers to posts.Id = 1\n#SELECT: SELECT user who created post refers to users.DisplayName and reputation refers to users.Reputation.\n#SQL-like: Show users.DisplayName, users.Reputation WHERE posts.Id = 1\n#SQL: SELECT T1.DisplayName, T1.Reputation FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.Id = 1\n```"
    ],
    "155": [
        "```\n#reason: The question wants to calculate the percentage of 'Gold' cards that were issued prior to 1998, so the SQL SELECT will count the type where it is 'gold' and issued date is less than 1998 and divide it by the count of all cards, multiplying by 100.\n#columns: card.type, card.issued\n#values: 'issued prior to 1998' refer to STRFTIME('%Y', card.issued) < '1998'\n#SELECT: percent of Gold cards issued prior to 1998 refer to (COUNT(CASE WHEN card.type = 'gold' AND STRFTIME('%Y', card.issued) < '1998' THEN 1 END) / COUNT(*)) * 100\n#SQL-like: Show (COUNT(CASE WHEN card.type = 'gold' AND STRFTIME('%Y', card.issued) < '1998' THEN 1 END) / COUNT(*)) * 100, WHERE card.type = 'gold' AND STRFTIME('%Y', card.issued) < '1998'\n#SQL: SELECT CAST(COUNT(CASE WHEN card.type = 'gold' AND STRFTIME('%Y', card.issued) < '1998' THEN 1 END) AS REAL) * 100 / COUNT(*) FROM card\n```"
    ],
    "216": [
        "```\n#reason: The question wants to identify all connected atoms with a triple bond, so the SQL SELECT will retrieve the connected atoms based on the bond type condition.\n#columns: connected.connected.atom_id, connected.connected.atom_id2\n#values: triple bond refers to bond.bond_type = '#'\n#SELECT: all connected atoms refer to connected.atom_id, connected.atom_id2\n#SQL-like: Show connected.atom_id and connected.atom_id2, WHERE bond.bond_type = '#'\n#SQL: SELECT T1.atom_id, T2.atom_id2 FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_type = '#'\n```"
    ],
    "1498": [
        "```\n#reason: The question wants to find the highest monthly consumption in the year 2012, so the SQL SELECT will filter the year from the Date column and then find the maximum of the Consumption column.\n#columns: yearmonth.Consumption, yearmonth.Date\n#values: 'in the year 2012' refer to 'SUBSTR(yearmonth.Date, 1, 4) = '2012''\n#SELECT: SELECT MAX(Consumption) refer to yearmonth.Consumption\n#SQL-like: Show MAX(Consumption) WHERE SUBSTR(Date, 1, 4) = '2012'\n#SQL: SELECT MAX(Consumption) FROM yearmonth WHERE SUBSTR(Date, 1, 4) = '2012'\n```"
    ],
    "615": [
        "```\n#reason: The question wants to calculate the percentage of users who obtained the \"Organizer\" badge and are teenagers. Therefore, the SQL SELECT counts the number of users who meet the age criteria and divides it by the total number of users with the badge, multiplying by 100 for percentage representation.\n#columns: badges.Name, users.Age, badges.UserId, users.Id\n#values: 'Organizer' refer to badges.Name = 'Organizer', 'teenager' refer to users.Age BETWEEN 13 AND 18\n#SELECT: SELECT Divide(Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) * 100 refer to badges.UserId, users.Age\n#SQL-like: Show Divide(Count(UserId where Age BETWEEN 13 AND 18), Count(UserId)) * 100 WHERE badges.Name = 'Organizer'\n#SQL: SELECT CAST(SUM(CASE WHEN U.Age BETWEEN 13 AND 18 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(B.UserId) FROM badges AS B INNER JOIN users AS U ON B.UserId = U.Id WHERE B.Name = 'Organizer'\n```"
    ],
    "221": [
        "```\n#reason: The question wants to retrieve the atoms that are bonded in a specific molecule identified by the molecule ID 'TR001' and the bond ID 'TR001_2_6', so the SQL SELECT will focus on joining the atom and connected tables based on the bond ID and filtering on the molecule ID.\n#columns: atom.atom_id, connected.atom_id2\n#values: 'TR001' refer to connected.bond_id = 'TR001_2_6' AND atom.molecule_id = 'TR001'\n#SELECT: SELECT atom.atom_id, connected.atom_id2 refer to atom.atom_id, connected.atom_id2\n#SQL-like: Show atom.atom_id, connected.atom_id2 WHERE connected.bond_id = 'TR001_2_6'\n#SQL: SELECT T1.atom_id, T2.atom_id2 FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR001_2_6' AND T1.molecule_id = 'TR001'\n```"
    ],
    "448": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the foreign name of the card with the abzan watermark and the type of the card, so the SQL SELECT will include foreign_data.name and cards.type.\n#columns: foreign_data.name, cards.type\n#values: 'abzan watermark' refer to cards.watermark = 'abzan'\n#SELECT: SELECT foreign_data.name, cards.type\n#SQL-like: Show foreign_data.name, cards.type WHERE cards.watermark = 'abzan'\n#SQL: SELECT foreign_data.name, cards.type FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.watermark = 'abzan'\n```"
    ],
    "821": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list down Ajax's superpowers, so the SQL SELECT will retrieve the superpower names associated with the superhero named Ajax.\n#columns: superpower.power_name\n#values: Ajax refers to superhero_name = 'Ajax'\n#SELECT: SELECT superpower.power_name refer to superpower.power_name\n#SQL-like: Show power_name, WHERE superhero_name = 'Ajax'\n#SQL: SELECT T2.power_name FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T1.superhero_name = 'Ajax'\n```"
    ],
    "1321": [
        "```\n#reason: The question wants to count the number of events attended by Sacha Harrison in 2019, so the SQL SELECT will count the events where the event date is in 2019 and the member is Sacha Harrison.\n#columns: attendance.link_to_event, attendance.link_to_member, event.event_date, member.first_name, member.last_name\n#values: 'events attended in 2019' refer to strftime('%Y', event.event_date) = '2019' and 'Sacha Harrison' refer to member.first_name = 'Sacha' AND member.last_name = 'Harrison'\n#SELECT: SELECT COUNT(attendance.link_to_event) refer to COUNT(attendance.link_to_event)\n#SQL-like: Show COUNT(attendance.link_to_event), WHERE strftime('%Y', event.event_date) = '2019' AND member.first_name = 'Sacha' AND member.last_name = 'Harrison'\n#SQL: SELECT COUNT(T1.link_to_event) FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE strftime('%Y', T2.event_date) = '2019' AND T3.first_name = 'Sacha' AND T3.last_name = 'Harrison'\n```"
    ],
    "1192": [
        "```\n#reason: The question wants to list all patients who were followed up at the outpatient clinic, underwent a laboratory test in October 1991, and had a total blood bilirubin level within the normal range. So the SQL SELECT will include filtering conditions for Admission, Date, and T-BIL.\n#columns: Patient.ID, Patient.Admission, Laboratory.Date, Laboratory.`T-BIL`\n#values: followed up at the outpatient clinic refers to Admission = '-', laboratory test in October 1991 refers to Laboratory.Date like '1991-10%', blood bilirubin level within the normal range refers to Laboratory.`T-BIL` < 2.0\n#SELECT: SELECT Patient.ID, Patient.Admission, Laboratory.Date, Laboratory.`T-BIL`\n#SQL-like: Show Patient.ID, Patient.Admission, Laboratory.Date, Laboratory.`T-BIL` WHERE Patient.Admission = '-' AND Laboratory.Date like '1991-10%' AND Laboratory.`T-BIL` < 2.0\n#SQL: SELECT T1.ID, T1.Admission, T2.Date, T2.`T-BIL` FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.Date like '1991-10%' AND T2.`T-BIL` < 2.0\n```"
    ],
    "1178": [
        "```\n#reason: The question wants to find the gender of the first patient diagnosed with AORTITIS, so the SQL SELECT will retrieve the SEX of the patient filtered by the Diagnosis being AORTITIS.\n#columns: Patient.SEX, Patient.Diagnosis\n#values: AORTITIS refers to Patient.Diagnosis = 'AORTITIS'\n#SELECT: SELECT Patient.SEX refer to Patient.SEX\n#SQL-like: Show Patient.SEX WHERE Patient.Diagnosis = 'AORTITIS'\n#SQL: SELECT T1.SEX FROM Patient AS T1 WHERE T1.Diagnosis = 'AORTITIS'\n```"
    ],
    "32": [
        "```\n#reason: The question wants to calculate the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66, so the SQL SELECT will compute the ratio of `FRPM Count (K-12)` to `Enrollment (K-12)` and order the results by `FRPM Count (K-12)` in descending order limited to the top 5.\n#columns: frpm.`FRPM Count (K-12)`, frpm.`Enrollment (K-12)`\n#values: ownership code 66 refers to schools.SOC = '66'\n#SELECT: SELECT (CAST(frpm.`FRPM Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL)) AS eligible_free_or_reduced_price_meal_rate\n#SQL-like: Show (CAST(frpm.`FRPM Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL)) AS eligible_free_or_reduced_price_meal_rate WHERE schools.SOC = '66' ORDER BY frpm.`FRPM Count (K-12)` DESC LIMIT 5\n#SQL: SELECT (CAST(frpm.`FRPM Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL)) AS eligible_free_or_reduced_price_meal_rate FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.SOC = '66' ORDER BY frpm.`FRPM Count (K-12)` DESC LIMIT 5\n```"
    ],
    "959": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the fastest lap number of the champion in 2009, so the SQL SELECT will retrieve the fastest lap number where the year is 2009 and the result indicates the champion.\n#columns: results.fastestLap, results.raceId, races.year\n#values: in 2009 refers to races.year = 2009\n#SELECT: fastest lap number refers to results.fastestLap\n#SQL-like: Show results.fastestLap WHERE races.year = 2009 AND results.positionOrder = 1\n#SQL: SELECT T1.fastestLap FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2009 AND T1.positionOrder = 1\n```"
    ],
    "1001": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the full name of the racer ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008, so the SQL SELECT will involve joining qualifying, races, and drivers to get the relevant information while applying filters for the ranking, circuit, and year.\n#columns: drivers.forename, drivers.surname, qualifying.q3, races.name\n#values: 'ranked 1st' refers to qualifying.position = 1, 'in the 3rd qualifying race' refers to qualifying.number = 3, 'held in the Marina Bay Street Circuit' refers to races.name = 'Marina Bay Street Circuit', '2008' refers to races.year = 2008\n#SELECT: SELECT full name of the racer refers to drivers.forename, drivers.surname\n#SQL-like: Show drivers.forename, drivers.surname WHERE qualifying.position = 1 AND qualifying.number = 3 AND races.name = 'Marina Bay Street Circuit' AND races.year = 2008\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T2.position = 1 AND T2.number = 3 AND T3.name = 'Marina Bay Street Circuit' AND T3.year = 2008\n```"
    ],
    "212": [
        "```\n#reason: The question wants to find \"which element is the least numerous in non-carcinogenic molecules\", so the SQL SELECT will count the occurrences of each element in non-carcinogenic molecules and select the element with the minimum count.\n#columns: atom.element, molecule.label\n#values: label = '-' means molecules are non-carcinogenic refer to molecule.label = '-'\n#SELECT: SELECT atom.element refer to atom.element\n#SQL-like: Show atom.element, GROUP BY atom.element, ORDER BY COUNT(atom.element) ASC LIMIT 1\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(T1.element) ASC LIMIT 1\n```"
    ],
    "268": [
        "```\n#reason: The question requires identifying the elements for a specific bond id. \"bond id TR001_10_11\" is the filtering condition.\n#columns: atom.element\n#values: bond id TR001_10_11 refers to bond.bond_id = 'TR001_10_11'\n#SELECT: elements refer to atom.element\n#SQL-like: Show atom.element WHERE bond.bond_id = 'TR001_10_11'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_id = 'TR001_10_11'\n```"
    ],
    "214": [
        "```\n#reason: The question asks for the type of label that is not associated with molecules containing tin atoms. Therefore, the SQL SELECT will filter for molecules that do not have the element 'sn' and retrieve their labels.\n#columns: molecule.label, atom.element, molecule.molecule_id\n#values: label = negative (non-carcinogenic) refers to molecule.label = '-', atom is tin refers to atom.element <> 'sn'\n#SELECT: SELECT molecule.label refer to molecule.label\n#SQL-like: Show molecule.label WHERE atom.element <> 'sn'\n#SQL: SELECT DISTINCT T1.label FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element <> 'sn'\n```"
    ],
    "606": [
        "```\n#reason: The question wants to display the name of badges that users obtained on a specific date, so the SQL SELECT will filter by the date and retrieve the badge names.\n#columns: badges.Name\n#values: on 7/19/2010 7:39:08 PM refers to badges.Date = '2010-07-19 19:39:08.0'\n#SELECT: name of badges refers to badges.Name\n#SQL-like: Show badges.Name, WHERE badges.Date = '2010-07-19 19:39:08.0'\n#SQL: SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0'\n```"
    ],
    "1495": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify \"which client ID consumed the most\", so the SQL SELECT will involve the customer IDs and their corresponding consumption values, aggregated to find the maximum.\n#columns: yearmonth.CustomerID, yearmonth.Consumption\n#values: September 2013 refers to yearmonth.Date = '201309'\n#SELECT: SELECT client ID refer to yearmonth.CustomerID\n#SQL-like: Show yearmonth.CustomerID, WHERE yearmonth.Date = '201309', ORDER BY yearmonth.Consumption DESC LIMIT 1\n#SQL: SELECT T1.CustomerID FROM yearmonth AS T1 WHERE T1.Date = '201309' ORDER BY T1.Consumption DESC LIMIT 1\n```"
    ],
    "968": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the reference name of Robert Kubica, so the SQL SELECT will retrieve the driverRef for the driver with the specified name.\n#columns: drivers.driverRef\n#values: 'Robert Kubica' refer to drivers.forename = 'Robert' and drivers.surname = 'Kubica'\n#SELECT: reference name refer to drivers.driverRef\n#SQL-like: Show drivers.driverRef, WHERE drivers.forename = 'Robert' AND drivers.surname = 'Kubica'\n#SQL: SELECT T1.driverRef FROM drivers AS T1 WHERE T1.forename = 'Robert' AND T1.surname = 'Kubica'\n```"
    ],
    "253": [
        "```\n#reason: The question wants to list \"the elements\" of all the triple bonds, so the SQL SELECT will retrieve the elements associated with bonds that have a bond type of '#'.\n#columns: atom.element\n#values: triple bond refers to bond.bond_type = '#'\n#SELECT: SELECT atom.element refer to atom.element\n#SQL-like: Show atom.element, WHERE bond.bond_type = '#'\n#SQL: SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#'\n```"
    ],
    "524": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the artists who illustrated cards with black borders available only in arena, so the SQL SELECT will retrieve the artist from the cards table filtered by the specified conditions.\n#columns: cards.artist\n#values: black borders refer to cards.borderColor = 'black', available only in arena refers to cards.availability = 'arena'\n#SELECT: SELECT content refers to cards.artist\n#SQL-like: Show DISTINCT cards.artist WHERE cards.borderColor = 'black' AND cards.availability = 'arena'\n#SQL: SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability = 'arena'\n```"
    ],
    "924": [
        "```\n#reason: The question wants to list the dates on which a Formula 1 race took place on the Barcelona-Catalunya circuit, so the SQL SELECT will retrieve the race dates from the races table that are associated with the Circuit de Barcelona-Catalunya.\n#columns: races.date\n#values: The Barcelona-Catalunya circuit refers to circuits.name = 'Circuit de Barcelona-Catalunya'.\n#SELECT: SELECT races.date refer to races.date\n#SQL-like: Show races.date, WHERE circuits.name = 'Circuit de Barcelona-Catalunya'\n#SQL: SELECT T1.date FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Circuit de Barcelona-Catalunya'\n```"
    ],
    "799": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of superheroes with no associated publisher, so the SQL SELECT will count the superhero IDs where the publisher_id is NULL.\n#columns: superhero.id\n#values: didn't have any publisher refers to superhero.publisher_id IS NULL\n#SELECT: How many superheroes refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.publisher_id IS NULL\n#SQL: SELECT COUNT(id) FROM superhero WHERE publisher_id IS NULL\n```"
    ],
    "48": [
        "```\n#reason: The question wants to calculate the ratio of merged Unified School District schools to merged Elementary School District schools in Orange County, so the SQL SELECT will count the number of schools for each type and divide them.\n#columns: schools.DOC, schools.County\n#values: 'merged Unified School District schools' refer to schools.DOC = '54', 'merged Elementary School District schools' refer to schools.DOC = '52' and 'in Orange County' refer to schools.County = 'Orange'\n#SELECT: SELECT CAST(COUNT(CASE WHEN schools.DOC = '54' THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN schools.DOC = '52' THEN 1 END), 0) \n#SQL-like: Show ratio of COUNT(CASE WHEN schools.DOC = '54' THEN 1 END) to COUNT(CASE WHEN schools.DOC = '52' THEN 1 END), WHERE schools.County = 'Orange'\n#SQL: SELECT CAST(COUNT(CASE WHEN schools.DOC = '54' THEN 1 END) AS REAL) / NULLIF(COUNT(CASE WHEN schools.DOC = '52' THEN 1 END), 0) FROM schools WHERE schools.County = 'Orange'\n```"
    ],
    "1447": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"name and location of events that underspend its budget\". \"name\" refers to event_name, and \"underspend its budget\" refers to the condition where remaining > 0.\n#columns: event.event_name, event.location, budget.remaining\n#values: underspend its budget refers to budget.remaining > 0\n#SELECT: name of event refers to event.event_name, location refers to event.location\n#SQL-like: Show event.event_name, event.location, WHERE budget.remaining > 0\n#SQL: SELECT event.event_name, event.location FROM event INNER JOIN budget ON event.event_id = budget.link_to_event WHERE budget.remaining > 0\n```"
    ],
    "1508": [
        "```\n#reason: The question wants to count the number of transactions, so the SQL SELECT will count the TransactionID from the transactions_1k table where the gas station is in the Czech Republic and the price is over 1000.\n#columns: transactions_1k.TransactionID, transactions_1k.Price, gasstations.Country\n#values: gas station in the Czech Republic refers to gasstations.Country = 'CZE', price of over 1000 refers to transactions_1k.Price > 1000\n#SELECT: SELECT COUNT(transactions_1k.TransactionID) refer to transactions_1k.TransactionID\n#SQL-like: Show COUNT(transactions_1k.TransactionID), WHERE gasstations.Country = 'CZE' AND transactions_1k.Price > 1000\n#SQL: SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Price > 1000\n```"
    ],
    "1080": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the number of players whose preferred foot is left and who would remain in their position when the team attacked, so the SQL SELECT will count the players satisfying these conditions.\n#columns: Player_Attributes.preferred_foot, Player_Attributes.attacking_work_rate\n#values: preferred foot when attacking was the left refer to preferred_foot = 'left', players who would remain in his position when the team attacked refer to attacking_work_rate = 'low'\n#SELECT: How many players refer to COUNT(Player_Attributes.preferred_foot)\n#SQL-like: Show COUNT(Player_Attributes.preferred_foot), WHERE Player_Attributes.preferred_foot = 'left' AND Player_Attributes.attacking_work_rate = 'low'\n#SQL: SELECT COUNT(T1.preferred_foot) FROM Player_Attributes AS T1 WHERE T1.preferred_foot = 'left' AND T1.attacking_work_rate = 'low'\n```"
    ],
    "515": [
        "```\n#reason: The question requires displaying \"When\" and \"legal play formats\". \"The oldest card\" refers to MIN(originalReleaseDate) and \"mythic card\" is a filtering condition with rarity = 'mythic'. \"Legal play\" refers to a status filter with status = 'Legal' and play format refers to format in legalities.\n#columns: cards.originalReleaseDate, legalities.format\n#values: the oldest card refers to MIN(originalReleaseDate), mythic card refers to rarity = 'mythic', legal play refers to legalities.status = 'Legal'\n#SELECT: SELECT cards.originalReleaseDate, legalities.format\n#SQL-like: Show cards.originalReleaseDate, legalities.format WHERE rarity = 'mythic' AND legalities.status = 'Legal' ORDER BY cards.originalReleaseDate ASC LIMIT 1\n#SQL: SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate ASC LIMIT 1\n```"
    ],
    "245": [
        "```\n#reason: The question wants to calculate the average number of bonds for atoms with the element iodine, so the SQL SELECT will count the bonds and divide by the count of atoms with that element.\n#columns: bond.bond_id, atom.atom_id, atom.element\n#values: atoms with the element iodine refers to atom.element = 'i'\n#SELECT: average number of bonds refers to DIVIDE(COUNT(bond.bond_id), COUNT(atom.atom_id))\n#SQL-like: Show DIVIDE(COUNT(bond.bond_id), COUNT(atom.atom_id)), WHERE atom.element = 'i'\n#SQL: SELECT CAST(COUNT(T1.bond_id) AS REAL) / COUNT(T2.atom_id) FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'i'\n```"
    ],
    "565": [
        "```\n#reason: The question requires finding out if the post is \"well-finished\" based on the creation date of the comment and whether the post is closed. The filtering conditions include the specific user ID and the comment creation date, as well as checking if the post's closed date is NULL.\n#columns: posts.ClosedDate, comments.CreationDate, comments.UserId\n#values: User No.23853 refers to comments.UserId = 23853, at 9:08:18 on 2013/7/12 refers to comments.CreationDate = '2013-07-12 09:08:18.0'\n#SELECT: whether the post is well-finished refers to posts.ClosedDate\n#SQL-like: Show posts.ClosedDate, WHERE comments.UserId = 23853 AND comments.CreationDate = '2013-07-12 09:08:18.0'\n#SQL: SELECT T1.ClosedDate FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.UserId = 23853 AND T2.CreationDate = '2013-07-12 09:08:18.0'\n```"
    ],
    "183": [
        "```\n#reason: The question wants to count the number of accounts opened in Beroun after 1996, so the SQL SELECT will count the account IDs where the district is Beroun and the date is after 1996.\n#columns: account.account_id, account.date, district.A2\n#values: 'opened after 1996' refers to account.date > '1996-12-31', 'in Beroun' refers to district.A2 = 'Beroun'\n#SELECT: SELECT COUNT(account.account_id) refer to account.account_id\n#SQL-like: Show COUNT(account.account_id), WHERE account.date > '1996-12-31' AND district.A2 = 'Beroun'\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.date > '1996-12-31' AND T2.A2 = 'Beroun'\n```"
    ],
    "56": [
        "```\n#reason: The question wants to determine \"how many schools\" that are \"active\" and located in \"San Joaquin city\". The filtering conditions are \"mailing state address in California\" and \"active status\".\n#columns: schools.StatusType, schools.City\n#values: 'active in San Joaquin city' refer to schools.StatusType = 'Active' AND schools.City = 'San Joaquin'\n#SELECT: How many schools refer to COUNT(schools.City)\n#SQL-like: Show COUNT(schools.City), WHERE schools.StatusType = 'Active' AND schools.City = 'San Joaquin' AND schools.MailState = 'CA'\n#SQL: SELECT COUNT(*) FROM schools WHERE StatusType = 'Active' AND City = 'San Joaquin' AND MailState = 'CA'\n```"
    ],
    "1185": [
        "```\n#reason: The question wants to find the decrease rate of total cholesterol for a specific patient over two months in 1981. Thus, the SQL SELECT will sum the total cholesterol for November and December and calculate the decrease rate based on that sum.\n#columns: Laboratory.`T-CHO`, Laboratory.Date, Patient.Birthday\n#values: 'born on 1959/2/18' refer to Patient.Birthday = '1959-02-18', 'November' refer to Laboratory.Date LIKE '1981-11-%', 'December' refer to Laboratory.Date LIKE '1981-12-%'\n#SELECT: decrease rate for total cholesterol refers to SUBTRACT(SUM(CASE WHEN Laboratory.Date LIKE '1981-11-%' THEN Laboratory.`T-CHO` END), SUM(CASE WHEN Laboratory.Date LIKE '1981-12-%' THEN Laboratory.`T-CHO` END)) \n#SQL-like: Show SUBTRACT(SUM(CASE WHEN Laboratory.Date LIKE '1981-11-%' THEN Laboratory.`T-CHO` END), SUM(CASE WHEN Laboratory.Date LIKE '1981-12-%' THEN Laboratory.`T-CHO` END)), WHERE Patient.Birthday = '1959-02-18'\n#SQL: SELECT (SELECT SUM(CASE WHEN Laboratory.Date LIKE '1981-11-%' THEN Laboratory.`T-CHO` END) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.Birthday = '1959-02-18') - (SELECT SUM(CASE WHEN Laboratory.Date LIKE '1981-12-%' THEN Laboratory.`T-CHO` END) FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.Birthday = '1959-02-18')\n```"
    ],
    "952": [
        "```\n#reason: The question wants to identify the constructors that have been ranked 1, so the SQL SELECT will focus on the constructors' names and their rankings.\n#columns: constructors.name, constructorStandings.position\n#values: ranked 1 refers to constructorStandings.position = 1\n#SELECT: SELECT constructors.name\n#SQL-like: Show constructors.name WHERE constructorStandings.position = 1\n#SQL: SELECT constructors.name FROM constructors INNER JOIN constructorStandings ON constructors.constructorId = constructorStandings.constructorId WHERE constructorStandings.position = 1\n```"
    ],
    "1296": [
        "```\n#reason: The question wants to identify the anti-nucleus antibody concentration of the patient with the highest total bilirubin in the normal range, so the SQL SELECT will retrieve the ANA column for the patient whose total bilirubin meets the specified condition.\n#columns: Examination.ANA, Laboratory.`T-BIL`\n#values: total bilirubin is the highest in the normal range refers to Laboratory.`T-BIL` < 2.0\n#SELECT: SELECT Examination.ANA\n#SQL-like: Show Examination.ANA WHERE Laboratory.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory WHERE `T-BIL` < 2.0)\n#SQL: SELECT E.ANA FROM Examination AS E INNER JOIN Laboratory AS L ON E.ID = L.ID WHERE L.`T-BIL` = (SELECT MAX(`T-BIL`) FROM Laboratory WHERE `T-BIL` < 2.0)\n```"
    ],
    "721": [
        "```\n#reason: The question wants to count the number of superheroes with blue eyes, so the SQL SELECT will count the superheroes where the eye_colour_id corresponds to the blue color.\n#columns: superhero.id, colour.colour\n#values: blue eyes refer to colour = 'Blue' and eye_colour_id = colour.id\n#SELECT: SELECT COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.eye_colour_id = (SELECT id FROM colour WHERE colour = 'Blue')\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 WHERE T1.eye_colour_id = (SELECT T2.id FROM colour AS T2 WHERE T2.colour = 'Blue')\n```"
    ],
    "213": [
        "```\n#reason: The question wants to identify the type of bond between two specific atoms, so the SQL SELECT will retrieve the bond_type based on the connection between the specified atom IDs.\n#columns: bond.bond_type, connected.atom_id, connected.atom_id2\n#values: atoms TR004_8 and TR004_20 refer to connected.atom_id = 'TR004_8' AND connected.atom_id2 = 'TR004_20' OR connected.atom_id = 'TR004_20' AND connected.atom_id2 = 'TR004_8'\n#SELECT: type of bond refers to bond.bond_type\n#SQL-like: Show bond.bond_type, WHERE (connected.atom_id = 'TR004_8' AND connected.atom_id2 = 'TR004_20') OR (connected.atom_id = 'TR004_20' AND connected.atom_id2 = 'TR004_8')\n#SQL: SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE (T2.atom_id = 'TR004_8' AND T2.atom_id2 = 'TR004_20') OR (T2.atom_id = 'TR004_20' AND T2.atom_id2 = 'TR004_8')\n```"
    ],
    "956": [
        "```\n#reason: The question wants to display the forenames and surnames of drivers who were born after 1975 and have been ranked 2. The filtering condition is \"born after 1975\" which corresponds to year(dob) > 1975 and \"ranked 2\" refers to driverStandings.position = 2.\n#columns: drivers.forename, drivers.surname, drivers.dob, driverStandings.position\n#values: born after 1975 refers to year(drivers.dob) > 1975, ranked 2 refers to driverStandings.position = 2\n#SELECT: SELECT drivers.forename, drivers.surname refer to drivers.forename, drivers.surname\n#SQL-like: Show drivers.forename, drivers.surname WHERE year(drivers.dob) > 1975 AND driverStandings.position = 2\n#SQL: SELECT T1.forename, T1.surname FROM drivers AS T1 INNER JOIN driverStandings AS T2 ON T1.driverId = T2.driverId WHERE year(T1.dob) > 1975 AND T2.position = 2\n```"
    ],
    "1512": [
        "```\n#reason: The question wants to identify the customer who made the highest payment on a specific date, so the SQL SELECT will retrieve the customer details based on the maximum payment amount for that date.\n#columns: customers.CustomerID, customers.Currency, transactions_1k.Amount\n#values: 'paid the most in 2012/8/25' refer to 'transactions_1k.Date = \"2012-08-25\"'\n#SELECT: SELECT content refers to 'customer' which is represented by customers.CustomerID and the payment amount transactions_1k.Amount.\n#SQL-like: Show customers.CustomerID, transactions_1k.Amount WHERE transactions_1k.Date = '2012-08-25' ORDER BY transactions_1k.Amount DESC LIMIT 1\n#SQL: SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date = '2012-08-25' ORDER BY T1.Amount DESC LIMIT 1\n```"
    ],
    "1034": [
        "```\n#reason: The question wants to list the players' api id who had the highest above average overall ratings in 2010, so the SQL SELECT will filter for the year 2010 and find the maximum overall rating above the average overall rating for that year.\n#columns: Player_Attributes.player_api_id, Player_Attributes.overall_rating\n#values: in 2010 refers to substr(Player_Attributes.date,1,4) = '2010'\n#SELECT: SELECT Player_Attributes.player_api_id refer to Player_Attributes.player_api_id\n#SQL-like: Show Player_Attributes.player_api_id, WHERE Player_Attributes.overall_rating > (SELECT AVG(overall_rating) FROM Player_Attributes WHERE substr(date,1,4) = '2010') AND substr(Player_Attributes.date,1,4) = '2010' ORDER BY Player_Attributes.overall_rating DESC LIMIT 1\n#SQL: SELECT Player_Attributes.player_api_id FROM Player_Attributes WHERE overall_rating > (SELECT AVG(overall_rating) FROM Player_Attributes WHERE substr(date,1,4) = '2010') AND substr(date,1,4) = '2010' ORDER BY overall_rating DESC LIMIT 1\n```"
    ],
    "1242": [
        "```\n#reason: The question wants to list all patients below 50 years old with normal platelet level from laboratory examinations taken in 1984, so the SQL SELECT will include patient identification and birthday along with laboratory platelet level.\n#columns: Patient.ID, Patient.Birthday, Laboratory.PLT\n#values: laboratory examinations take in 1984 refers to YEAR(Laboratory.Date) = '1984', below 50 years old refers to (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', Patient.Birthday)) < 50, normal platelet level refers to Laboratory.PLT BETWEEN 100 AND 400\n#SELECT: SELECT Patient.ID, Patient.Birthday, Laboratory.PLT\n#SQL-like: Show Patient.ID, Patient.Birthday, Laboratory.PLT WHERE YEAR(Laboratory.Date) = '1984' AND (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', Patient.Birthday)) < 50 AND Laboratory.PLT BETWEEN 100 AND 400\n#SQL: SELECT T1.ID, T1.Birthday, T2.PLT FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE strftime('%Y', T2.Date) = '1984' AND (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday)) < 50 AND T2.PLT BETWEEN 100 AND 400\n```"
    ],
    "420": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of cards that are oversized, reprinted, and printed for promotions, so the SQL SELECT will count the cards based on the specified conditions.\n#columns: cards.isOversized, cards.isReprint, cards.isPromo\n#values: oversized refers to isOversized = 1, reprinted refers to isReprint = 1, printed for promotions refers to isPromo = 1\n#SELECT: SELECT COUNT(id) refer to cards.id\n#SQL-like: Show COUNT(cards.id), WHERE cards.isOversized = 1 AND cards.isReprint = 1 AND cards.isPromo = 1\n#SQL: SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1\n```"
    ],
    "305": [
        "```\n#reason: The question wants to name all bonds with single bond types and identify the atoms connected to the molecules, so the SQL SELECT will include the bond information and the connected atoms.\n#columns: bond.bond_id, bond.bond_type, connected.atom_id, connected.atom_id2\n#values: single bond refers to bond.bond_type = '-'\n#SELECT: SELECT bond.bond_id, bond.bond_type, connected.atom_id, connected.atom_id2\n#SQL-like: Show bond.bond_id, bond.bond_type, connected.atom_id, connected.atom_id2, WHERE bond.bond_type = '-'\n#SQL: SELECT T1.bond_id, T1.bond_type, T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '-'\n```"
    ],
    "349": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the card and artist with the most ruling information, which is defined as the maximum count of rulings. Additionally, it requires checking if the card is a promotional printing. \n#columns: cards.name, cards.artist, cards.isPromo\n#values: the most ruling information refers to ORDER BY COUNT(rulings.uuid) DESC LIMIT 1, isPromo = 1 refers to cards.isPromo = 1\n#SELECT: SELECT cards.name, cards.artist, cards.isPromo\n#SQL-like: Show cards.name, cards.artist, cards.isPromo, WHERE cards.isPromo = 1, GROUP BY cards.name, cards.artist ORDER BY COUNT(rulings.uuid) DESC LIMIT 1\n#SQL: SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 GROUP BY T1.name, T1.artist ORDER BY COUNT(T2.uuid) DESC LIMIT 1\n```"
    ],
    "178": [
        "```\n#reason: The question wants to find out the type of credit card associated with a specific client number. Therefore, the SQL SELECT statement will retrieve the credit card type linked to the client with ID 9.\n#columns: card.type, disp.client_id\n#values: client number 9 refers to disp.client_id = 9\n#SELECT: SELECT card.type refer to card.type\n#SQL-like: Show card.type, WHERE disp.client_id = 9\n#SQL: SELECT T1.type FROM card AS T1 INNER JOIN disp AS T2 ON T1.disp_id = T2.disp_id WHERE T2.client_id = 9\n```"
    ],
    "355": [
        "```\n#reason: The question wants to find the keywords associated with the card named 'Angel of Mercy', so the SQL SELECT will retrieve keywords from the cards table where the name matches 'Angel of Mercy'.\n#columns: cards.keywords\n#values: 'Angel of Mercy' refers to cards.name = 'Angel of Mercy'\n#SELECT: SELECT cards.keywords refer to cards.keywords\n#SQL-like: Show cards.keywords WHERE cards.name = 'Angel of Mercy'\n#SQL: SELECT keywords FROM cards WHERE name = 'Angel of Mercy'\n```"
    ],
    "1429": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"name of the social event\" that was attended by the \"vice president\" of the Student_Club located at \"900 E. Washington St.\". The filtering conditions include the event type being 'Social', the member's position being 'Vice President', and the event location being '900 E. Washington St.'.\n#columns: event.event_name, member.position, event.location\n#values: 'Social' refers to event.type = 'Social', 'Vice President' refers to member.position = 'Vice President', '900 E. Washington St.' refers to event.location = '900 E. Washington St.'\n#SELECT: SELECT event.event_name refer to event.event_name\n#SQL-like: Show event.event_name WHERE event.type = 'Social' AND member.position = 'Vice President' AND event.location = '900 E. Washington St.'\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T1.type = 'Social' AND T3.position = 'Vice President' AND T1.location = '900 E. Washington St.'\n```"
    ],
    "1204": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine how long it took after the patient number 821298 arrived at the hospital for the first time before her evaluation began, so the SQL SELECT will calculate the difference between the `Examination Date` and `First Date` for the specific patient number.\n#columns: Examination.`Examination Date`, Patient.`First Date`\n#values: patient number 821298 refers to Patient.ID = 821298\n#SELECT: DATEDIFF(Examination.`Examination Date`, Patient.`First Date`) refer to DATEDIFF(Examination.`Examination Date`, Patient.`First Date`)\n#SQL-like: Show DATEDIFF(Examination.`Examination Date`, Patient.`First Date`) WHERE Patient.ID = 821298\n#SQL: SELECT DATEDIFF(T1.`Examination Date`, T2.`First Date`) FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.ID = 821298\n```"
    ],
    "731": [
        "```\n#reason: The question wants to display \"How many superheroes\". \"DC Comics\" is a filtering condition based on publisher_name.\n#columns: superhero.id, publisher.publisher_name\n#values: 'DC Comics' refers to publisher.publisher_name = 'DC Comics'\n#SELECT: SELECT COUNT(*) refers to superhero.id\n#SQL-like: Show COUNT(*), WHERE publisher.publisher_name = 'DC Comics'\n#SQL: SELECT COUNT(*) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics'\n```"
    ],
    "840": [
        "```\n#reason: The question requires displaying the \"attribute value\" of the superhero named \"Aquababy\". \"Aquababy\" is the filtering condition based on the superhero's name.\n#columns: hero_attribute.attribute_value, superhero.superhero_name\n#values: 'Aquababy' refers to superhero.superhero_name = 'Aquababy'\n#SELECT: SELECT hero_attribute.attribute_value refer to hero_attribute.attribute_value\n#SQL-like: Show hero_attribute.attribute_value, WHERE superhero.superhero_name = 'Aquababy'\n#SQL: SELECT T1.attribute_value FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Aquababy'\n```"
    ],
    "1217": [
        "```\n#reason: The question wants to determine if the albumin levels of patients born in 1982 are within the normal range, so the SQL SELECT will check the year of the Birthday and the range of the ALB values.\n#columns: Patient.Birthday, Laboratory.ALB\n#values: Year(Birthday) = '1982' refers to strftime('%Y', Patient.Birthday) = '1982', albumin is within normal range refers to Laboratory.ALB BETWEEN 3.5 AND 5.5\n#SELECT: SELECT Patient.Birthday, CASE WHEN Laboratory.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range' ELSE 'Out of Normal Range' END AS Albumin_Status\n#SQL-like: Show Patient.Birthday, CASE WHEN Laboratory.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range' ELSE 'Out of Normal Range' END, WHERE strftime('%Y', Patient.Birthday) = '1982'\n#SQL: SELECT Patient.Birthday, CASE WHEN Laboratory.ALB BETWEEN 3.5 AND 5.5 THEN 'Within Normal Range' ELSE 'Out of Normal Range' END AS Albumin_Status FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE strftime('%Y', Patient.Birthday) = '1982'\n```"
    ],
    "974": [
        "```\n#reason: The question wants to identify the racing year which has the fastest lap time, so the SQL SELECT will find the year with the minimum fastestLapTime for the respective races.\n#columns: races.year, results.fastestLapTime\n#values: fastest lap time refers to MIN(results.fastestLapTime) in the results table by grouping with races.\n#SELECT: racing year refers to races.year\n#SQL-like: Show races.year, WHERE results.fastestLapTime IS NOT NULL, ORDER BY results.fastestLapTime ASC LIMIT 1\n#SQL: SELECT T1.year FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId WHERE T2.fastestLapTime IS NOT NULL ORDER BY T2.fastestLapTime ASC LIMIT 1\n```"
    ],
    "1424": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of members with an extra large t-shirt size, so the SQL SELECT will count the member IDs where the position is 'Member' and the t-shirt size is 'X-Large'.\n#columns: member.member_id, member.position, member.t_shirt_size\n#values: position = 'Member' refer to member.position = 'Member', t_shirt_size = 'X-Large' refer to member.t_shirt_size = 'X-Large'\n#SELECT: COUNT(member.member_id) refer to how many members\n#SQL-like: Show COUNT(member.member_id) WHERE member.position = 'Member' AND member.t_shirt_size = 'X-Large'\n#SQL: SELECT COUNT(member.member_id) FROM member WHERE member.position = 'Member' AND member.t_shirt_size = 'X-Large'\n```"
    ],
    "170": [
        "```\n#reason: The question wants to count the number of credit card withdrawals recorded after 1995, so the SQL SELECT will count the records where the operation is 'VYBER KARTOU' and the date is after '1995-01-01'.\n#columns: trans.operation, trans.date\n#values: 'after 1995' refers to trans.date > '1995-01-01'\n#SELECT: SELECT COUNT(*) refer to trans.operation\n#SQL-like: Show COUNT(*) WHERE trans.operation = 'VYBER KARTOU' AND trans.date > '1995-01-01'\n#SQL: SELECT COUNT(*) FROM trans WHERE trans.operation = 'VYBER KARTOU' AND trans.date > '1995-01-01'\n```"
    ],
    "85": [
        "```\n#reason: The question wants to find the district code of the school and the Percent (%) Eligible Free (K-12) for a specific administrator, so the SQL SELECT will fetch these two columns while applying the necessary conditions.\n#columns: schools.District, CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL) * 100 AS PercentEligibleFreeK12\n#values: 'administrator's first name is Alusine' refer to schools.AdmFName1 = 'Alusine'\n#SELECT: SELECT schools.District, CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL) * 100 AS PercentEligibleFreeK12\n#SQL-like: Show schools.District, CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL) * 100 AS PercentEligibleFreeK12 WHERE schools.AdmFName1 = 'Alusine'\n#SQL: SELECT schools.District, CAST(frpm.`Free Meal Count (K-12)` AS REAL) / CAST(frpm.`Enrollment (K-12)` AS REAL) * 100 AS PercentEligibleFreeK12 FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.AdmFName1 = 'Alusine'\n```"
    ],
    "463": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count translations for the set that includes the card \"Angel of Mercy\", so the SQL SELECT will count the distinct set translations associated with the card name.\n#columns: sets.id, set_translations.translation\n#values: 'name is Angel of Mercy' refer to 'cards.name = \"Angel of Mercy\"'\n#SELECT: SELECT COUNT(DISTINCT set_translations.translation) refer to sets.id. \n#SQL-like: Show COUNT(DISTINCT set_translations.translation), WHERE cards.name = 'Angel of Mercy' INNER JOIN sets ON cards.id = sets.id INNER JOIN set_translations ON sets.code = set_translations.setCode\n#SQL: SELECT COUNT(DISTINCT ST.translation) FROM cards AS C INNER JOIN sets AS S ON C.id = S.id INNER JOIN set_translations AS ST ON S.code = ST.setCode WHERE C.name = 'Angel of Mercy'\n```"
    ],
    "1528": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of the \"premium\" segment against the overall segment in the country \"SVK\", so the SQL SELECT will count the number of \"premium\" segments and divide it by the total number of segments in the specified country.\n#columns: gasstations.Segment, gasstations.Country\n#values: 'premium' refer to gasstations.Segment = 'Premium', 'SVK' refer to gasstations.Country = 'SVK'\n#SELECT: percentage of \"premium\" against the overall segment refer to CAST(SUM(gasstations.Segment = 'Premium') AS REAL) * 100 / COUNT(*) \n#SQL-like: Show CAST(SUM(gasstations.Segment = 'Premium') AS REAL) * 100 / COUNT(*), WHERE gasstations.Country = 'SVK'\n#SQL: SELECT CAST(SUM(CASE WHEN Segment = 'Premium' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM gasstations WHERE Country = 'SVK'\n```"
    ],
    "912": [
        "```\n#reason: The question wants to display the \"reference name\" for the \"Marina Bay Street Circuit\". So the SQL SELECT will retrieve the circuitRef from the circuits table where the name matches 'Marina Bay Street Circuit'.\n#columns: circuits.circuitRef, circuits.name\n#values: 'Marina Bay Street Circuit' refers to circuits.name = 'Marina Bay Street Circuit'\n#SELECT: SELECT circuits.circuitRef\n#SQL-like: Show circuits.circuitRef WHERE circuits.name = 'Marina Bay Street Circuit'\n#SQL: SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit'\n```"
    ],
    "75": [
        "```\n#reason: The question requires displaying the \"educational level name\" for the schools with \"Breakfast Provision 2\" in \"county code 37\". The filtering conditions are related to \"Breakfast Provision 2\" and the county code.\n#columns: frpm.`Educational Option Type`, schools.`School Name`, frpm.`NSLP Provision Status`, frpm.`County Code`\n#values: 'Breakfast Provision 2' refers to frpm.`NSLP Provision Status` = 'Breakfast Provision 2', 'county code 37' refers to frpm.`County Code` = '37'\n#SELECT: SELECT educational level name refer to frpm.`Educational Option Type`, school name refer to schools.`School Name`\n#SQL-like: Show frpm.`Educational Option Type`, schools.`School Name` WHERE frpm.`NSLP Provision Status` = 'Breakfast Provision 2' AND frpm.`County Code` = '37'\n#SQL: SELECT T1.`Educational Option Type`, T2.`School Name` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T1.`NSLP Provision Status` = 'Breakfast Provision 2' AND T1.`County Code` = '37'\n```"
    ],
    "1433": [
        "```\n#reason: The question wants to identify countries that have zip codes classified as post office boxes, so the SQL SELECT will retrieve the country names and zip codes where the type is 'PO Box'.\n#columns: country.name, zip_code.zip_code\n#values: 'post office boxes' refer to zip_code.type = 'PO Box'\n#SELECT: SELECT country.name, zip_code.zip_code refer to country.name, zip_code.zip_code\n#SQL-like: Show country.name, zip_code.zip_code WHERE zip_code.type = 'PO Box'\n#SQL: SELECT T1.name, T2.zip_code FROM country AS T1 INNER JOIN zip_code AS T2 ON T1.zip_code = T2.zip_code WHERE T2.type = 'PO Box'\n```"
    ],
    "31": [
        "```\n#reason: The question wants to find the eligible free rate of the 10th and 11th schools with the highest enrollment for students in grades 1 through 12. The eligible free rate is calculated as `Free Meal Count (K-12)` divided by `Enrollment (K-12)`. Therefore, the SQL will filter by the schools having the highest enrollment, and then retrieve the eligible free rate for those specific schools.\n#columns: frpm.`Free Meal Count (K-12)`, frpm.`Enrollment (K-12)`\n#values: 'for students in grades 1 through 12' refer to the conditions on relevant columns for K-12 enrollment.\n#SELECT: SELECT (frpm.`Free Meal Count (K-12)` / frpm.`Enrollment (K-12)`) AS eligible_free_rate refer to the calculation for eligible free rate.\n#SQL-like: Show (frpm.`Free Meal Count (K-12)` / frpm.`Enrollment (K-12)`) AS eligible_free_rate WHERE schools.`Enrollment (K-12)` IS NOT NULL ORDER BY frpm.`Enrollment (K-12)` DESC LIMIT 2 OFFSET 9\n#SQL: SELECT (frpm.`Free Meal Count (K-12)` / frpm.`Enrollment (K-12)`) AS eligible_free_rate FROM frpm JOIN schools ON frpm.`School Code` = schools.`School Code` WHERE frpm.`Enrollment (K-12)` IS NOT NULL ORDER BY frpm.`Enrollment (K-12)` DESC LIMIT 2 OFFSET 9\n```"
    ],
    "918": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify Lewis Hamilton's reference name, so the SQL SELECT will fetch the driverRef for the driver with the full name Lewis Hamilton.\n#columns: drivers.driverRef\n#values: 'Lewis Hamilton' refer to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SELECT: Lewis Hamilton's reference name refers to drivers.driverRef\n#SQL-like: Show drivers.driverRef, WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton'\n#SQL: SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton'\n```"
    ],
    "484": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the Italian names of the cards in the set Coldsnap with the highest converted mana cost, so the SQL SELECT will include the maximum converted mana cost from the cards filtered by the set name and language.\n#columns: cards.name, cards.convertedManaCost, set_translations.translation\n#values: 'set Coldsnap' refer to sets.name = 'Coldsnap', 'Italian' refer to foreign_data.language = 'Italian'\n#SELECT: SELECT cards.name refer to cards.name, set_translations.translation refer to set_translations.translation WHERE cards.convertedManaCost is the highest\n#SQL-like: Show cards.name, set_translations.translation, WHERE sets.name = 'Coldsnap' AND foreign_data.language = 'Italian' ORDER BY cards.convertedManaCost DESC LIMIT 1\n#SQL: SELECT T1.name, T2.translation FROM cards AS T1 INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode INNER JOIN sets AS T4 ON T2.setCode = T4.code WHERE T4.name = 'Coldsnap' AND T3.language = 'Italian' ORDER BY T1.convertedManaCost DESC LIMIT 1\n```"
    ],
    "1116": [
        "```\n#reason: The question wants to list down the names of the most tallest players, so the SQL SELECT will retrieve player names ordered by height in descending order and filtered to only include the tallest players.\n#columns: Player.player_name\n#values: 'most tallest players' refer to 'rank = 1' which means we need to filter based on the maximum height.\n#SELECT: SELECT Player.player_name\n#SQL-like: Show Player.player_name, ORDER BY Player.height DESC WHERE Player.height = (SELECT MAX(height) FROM Player)\n#SQL: SELECT Player.player_name FROM Player WHERE Player.height = (SELECT MAX(height) FROM Player)\n```"
    ],
    "1315": [
        "```\n#reason: The question wants to count the number of students who have attended the event \"Women's Soccer\", so the SQL SELECT will count attendance.link_to_member and filter by event.event_name.\n#columns: attendance.link_to_member, event.event_name\n#values: 'Women's Soccer' refers to event.event_name = 'Women''s Soccer'\n#SELECT: SELECT COUNT(attendance.link_to_member) refer to attendance.link_to_member\n#SQL-like: Show COUNT(attendance.link_to_member), WHERE event.event_name = 'Women''s Soccer'\n#SQL: SELECT COUNT(attendance.link_to_member) FROM attendance INNER JOIN event ON attendance.link_to_event = event.event_id WHERE event.event_name = 'Women''s Soccer'\n```"
    ],
    "1216": [
        "```\n#reason: The question wants to sort all male patients by their birthday in descending order, filtering for those with albumin levels not within the normal range. So the SQL SELECT will include the patient's birthday and identification, and it will filter based on the specified conditions.\n#columns: Patient.Birthday, Patient.ID, Laboratory.ALB, Patient.SEX\n#values: male patients refer to Patient.SEX = 'M', albumin not within range refers to Laboratory.ALB <= 3.5 OR Laboratory.ALB >= 5.5\n#SELECT: SELECT Patient.Birthday, Patient.ID refer to Patient.Birthday, Patient.ID\n#SQL-like: Show Patient.Birthday, Patient.ID WHERE Patient.SEX = 'M' AND (Laboratory.ALB <= 3.5 OR Laboratory.ALB >= 5.5) ORDER BY Patient.Birthday DESC\n#SQL: SELECT T1.Birthday, T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND (T2.ALB <= 3.5 OR T2.ALB >= 5.5) ORDER BY T1.Birthday DESC\n```"
    ],
    "1340": [
        "```\n#reason: The question wants to calculate the difference of the total amount spent in all events by the Student_Club in years 2019 and 2020, so the SQL SELECT will subtract the total spent for events in 2020 from the total spent for events in 2019.\n#columns: expense.spent, event.event_date\n#values: 'in year 2019' refer to strftime('%Y', event.event_date) = '2019', 'in year 2020' refer to strftime('%Y', event.event_date) = '2020'\n#SELECT: SELECT SUBTRACT(SUM(expense.spent WHERE strftime('%Y', event.event_date) = '2019'), SUM(expense.spent WHERE strftime('%Y', event.event_date) = '2020')) refer to expense.spent\n#SQL-like: Show SUBTRACT(SUM(expense.spent WHERE strftime('%Y', event.event_date) = '2019'), SUM(expense.spent WHERE strftime('%Y', event.event_date) = '2020'))\n#SQL: SELECT SUM(CASE WHEN strftime('%Y', T2.event_date) = '2019' THEN T1.spent ELSE 0 END) - SUM(CASE WHEN strftime('%Y', T2.event_date) = '2020' THEN T1.spent ELSE 0 END) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id\n```"
    ],
    "1378": [
        "```\n#reason: The question wants to determine the \"highest amount of budget spend for an event\", so the SQL SELECT will find the maximum value of the \"spent\" column in the budget table.\n#columns: budget.spent\n#values: highest amount refers to MAX(spent)\n#SELECT: SELECT MAX(spent) refer to budget.spent\n#SQL-like: Show MAX(budget.spent)\n#SQL: SELECT MAX(spent) FROM budget\n```"
    ],
    "1281": [
        "```\n#reason: The question wants to find the youngest patient with an abnormal level of glutamic oxaloacetic transaminase, so the SQL SELECT will retrieve the minimum birthday from the patients who have GOT >= 60.\n#columns: Patient.Birthday\n#values: abnormal level of glutamic oxaloacetic transaminase refers to Laboratory.GOT >= 60\n#SELECT: SELECT MIN(Patient.Birthday) refer to Patient.Birthday\n#SQL-like: Show MIN(Patient.Birthday), WHERE Laboratory.GOT >= 60\n#SQL: SELECT MIN(T1.Birthday) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GOT >= 60\n```"
    ],
    "192": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the average amount of loans that are still on running contracts with statement issuance after each transaction, so the SQL SELECT will calculate the average of loan amounts where the status is either 'C' or 'D' and the frequency is 'POPLATEK PO OBRATU'.\n#columns: loan.amount, loan.status, account.frequency\n#values: status = 'C' or status = 'D' refers to loan.status IN ('C', 'D'), 'POPLATEK PO OBRATU' refers to account.frequency = 'POPLATEK PO OBRATU'\n#SELECT: average amount of loan refers to AVG(loan.amount)\n#SQL-like: Show AVG(loan.amount) WHERE loan.status IN ('C', 'D') AND account.frequency = 'POPLATEK PO OBRATU'\n#SQL: SELECT AVG(loan.amount) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.status IN ('C', 'D') AND T2.frequency = 'POPLATEK PO OBRATU'\n```"
    ],
    "451": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of cards available in paper and with a positive starting maximum hand size, so the SQL SELECT should count the cards and filter based on the conditions regarding availability and hand size.\n#columns: cards.availability, cards.hand\n#values: 'available in paper' refer to cards.availability LIKE '%paper%', 'positive starting maximum hand size' refer to cards.hand > '0'\n#SELECT: SELECT COUNT(*) refer to the total number of cards\n#SQL-like: Show COUNT(*), WHERE cards.availability LIKE '%paper%' AND cards.hand > '0'\n#SQL: SELECT COUNT(*) FROM cards WHERE availability LIKE '%paper%' AND hand > '0'\n```"
    ],
    "805": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the \"full names of superheroes\" with the condition \"missing weight\", which is defined as weight_kg = 0 OR weight_kg IS NULL.\n#columns: superhero.full_name, superhero.weight_kg\n#values: missing weight refers to weight_kg = 0 OR weight_kg IS NULL\n#SELECT: full names of superheroes refer to superhero.full_name\n#SQL-like: Show superhero.full_name WHERE weight_kg = 0 OR weight_kg IS NULL\n#SQL: SELECT full_name FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL\n```"
    ],
    "222": [
        "```\n#reason: The question wants to calculate the difference between the number of carcinogenic and non-carcinogenic molecules, so the SQL SELECT will count the occurrences of each label and subtract them.\n#columns: molecule.label\n#values: label = '+' refers to molecule.label = '+', label = '-' refers to molecule.label = '-'\n#SELECT: SELECT SUBTRACT(SUM(label = '+'), SUM(label = '-')) refer to molecule.label\n#SQL-like: Show SUBTRACT(SUM(label = '+'), SUM(label = '-'))\n#SQL: SELECT SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) - SUM(CASE WHEN label = '-' THEN 1 ELSE 0 END) AS DIFFERENCE FROM molecule\n```"
    ],
    "379": [
        "```\n#reason: The question wants to display \"the cards\" that belong to \"duel deck a\", so the SQL SELECT will retrieve the ID of cards filtered by the duelDeck column.\n#columns: cards.id\n#values: duel deck a refers to duelDeck = 'a'\n#SELECT: ID refers to cards.id\n#SQL-like: Show cards.id WHERE duelDeck = 'a'\n#SQL: SELECT id FROM cards WHERE duelDeck = 'a'\n```"
    ],
    "137": [
        "```\n#reason: The question requires displaying the count of accounts with a running contract in the specified branch location. The status can be either 'C' (running contract, OK so far) or 'D' (running contract, client in debt).\n#columns: loan.account_id\n#values: Branch location 1 refers to 'account.district_id = 1' and running contracts refer to 'loan.status IN ('C', 'D')'.\n#SELECT: the count of accounts refer to COUNT(loan.account_id)\n#SQL-like: Show COUNT(loan.account_id) WHERE account.district_id = 1 AND loan.status IN ('C', 'D')\n#SQL: SELECT COUNT(loan.account_id) FROM loan INNER JOIN account ON loan.account_id = account.account_id WHERE account.district_id = 1 AND loan.status IN ('C', 'D')\n```"
    ],
    "388": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the cards\" that belong to \"set 10E\" and have a \"converted mana\" of 5 and also retrieve their \"translation\" and \"languages\". Therefore, the SQL SELECT will pull the relevant card details and their corresponding translations.\n#columns: cards.name, foreign_data.translation, foreign_data.language\n#values: set 10E refers to cards.setCode = '10E', converted mana of 5 refers to cards.convertedManaCost = 5\n#SELECT: SELECT content (the cards refer to cards.name, translation refers to foreign_data.translation, languages refers to foreign_data.language)\n#SQL-like: Show cards.name, foreign_data.translation, foreign_data.language WHERE cards.setCode = '10E' AND cards.convertedManaCost = 5\n#SQL: SELECT T1.name, T2.translation, T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.setCode = '10E' AND T1.convertedManaCost = 5\n```"
    ],
    "728": [
        "```\n#reason: The question wants to rank superheroes from Marvel Comics by their eye color popularity, so the SQL SELECT will count the number of superheroes grouped by their eye color and order it by the count in descending order.\n#columns: colour.colour, COUNT(superhero.id) \n#values: superheroes from Marvel Comics refer to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT COUNT(superhero.id) AS superhero_count, colour.colour refer to COUNT(superhero.id), colour.colour\n#SQL-like: Show COUNT(superhero.id) and colour.colour, WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour ORDER BY COUNT(superhero.id) DESC\n#SQL: SELECT colour.colour, COUNT(superhero.id) FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.colour ORDER BY COUNT(superhero.id) DESC\n```"
    ],
    "901": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to name the races along with their circuit name and location for F1 races hosted in September 2005, so the SQL SELECT will include the race name, circuit name, and location, and it will filter by the date being in September 2005.\n#columns: races.name, circuits.name, circuits.location\n#values: in September 2005 refers to strftime('%m', races.date) = '09' AND strftime('%Y', races.date) = '2005'\n#SELECT: SELECT races.name, circuits.name, circuits.location refer to races.name, circuits.name, circuits.location\n#SQL-like: Show races.name, circuits.name, circuits.location, WHERE strftime('%m', races.date) = '09' AND strftime('%Y', races.date) = '2005'\n#SQL: SELECT races.name, circuits.name, circuits.location FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE strftime('%m', races.date) = '09' AND strftime('%Y', races.date) = '2005'\n```"
    ],
    "609": [
        "```\n#reason: The question wants to count the number of posts with a score of 10, so the SQL SELECT will count the post IDs where the score is 10.\n#columns: posts.Id, posts.Score\n#values: score of 10 refers to posts.Score = 10\n#SELECT: How many posts refer to COUNT(posts.Id)\n#SQL-like: Show COUNT(posts.Id), WHERE posts.Score = 10\n#SQL: SELECT COUNT(Id) FROM posts WHERE Score = 10\n```"
    ],
    "497": [
        "```\n#reason: The question wants to list the expansion type of the set \"Huitième édition\", so the SQL SELECT will retrieve the type from the sets table where the translation matches 'Huitième édition'.\n#columns: sets.type, set_translations.translation\n#values: 'Huitième édition' refer to set_translations.translation = 'Huitième édition'\n#SELECT: SELECT sets.type refer to sets.type\n#SQL-like: Show sets.type, WHERE set_translations.translation = 'Huitième édition'\n#SQL: SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.translation = 'Huitième édition'\n```"
    ],
    "1264": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the count of patients with blood clots in veins who also have a normal level of complement 4, so the SQL SELECT will count distinct patient IDs where the diagnosis indicates blood clots and the complement level is normal.\n#columns: Patient.ID, Laboratory.C4\n#values: 'APS refers to blood clots in veins' refer to Patient.Diagnosis = 'APS', 'normal level of complement 4' refer to Laboratory.C4 > 10\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.Diagnosis = 'APS' AND Laboratory.C4 > 10\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Diagnosis = 'APS' AND L.C4 > 10\n```"
    ],
    "2": [
        "```\n#reason: The question wants to list the zip code of all charter schools in Fresno County Office of Education, so the SQL SELECT will filter on `Charter School (Y/N)` = 1 in the table frpm for Fresno County Office of Education.\n#columns: schools.Zip\n#values: 'Fresno County Office of Education' refer to frpm.`District Name` = 'Fresno County Office of Education', 'Charter schools' refer to frpm.`Charter School (Y/N)` = 1\n#SELECT: SELECT schools.Zip refer to schools.Zip\n#SQL-like: Show schools.Zip, WHERE frpm.`District Name` = 'Fresno County Office of Education' AND frpm.`Charter School (Y/N)` = 1\n#SQL: SELECT T3.Zip FROM frpm INNER JOIN schools AS T3 ON frpm.CDSCode = T3.CDSCode WHERE frpm.`District Name` = 'Fresno County Office of Education' AND frpm.`Charter School (Y/N)` = 1\n```"
    ],
    "869": [
        "```\n#reason: The question wants to find the introduction website of the constructor that received the highest points in race number 9, so the SQL SELECT will retrieve the url of the constructor with the maximum points from the constructorResults table for the specified raceId.\n#columns: constructors.url, constructorResults.points, constructorResults.raceId\n#values: race number refers to constructorResults.raceId = 9\n#SELECT: SELECT constructors.url refer to constructors.url\n#SQL-like: Show constructors.url, WHERE constructorResults.raceId = 9 ORDER BY constructorResults.points DESC LIMIT 1\n#SQL: SELECT T1.url FROM constructors AS T1 INNER JOIN constructorResults AS T2 ON T1.constructorId = T2.constructorId WHERE T2.raceId = 9 ORDER BY T2.points DESC LIMIT 1\n```"
    ],
    "845": [
        "```\n#reason: The question wants to list the power of superheroes with height greater than 80% of the average height of all superheroes, so the SQL SELECT will include the power_name and filter based on the height condition.\n#columns: superpower.power_name, superhero.height_cm\n#values: height greater than 80% of the average height of all superheroes refers to superhero.height_cm > (SELECT AVG(height_cm) * 0.8 FROM superhero)\n#SELECT: SELECT superpower.power_name refer to superpower.power_name\n#SQL-like: Show superpower.power_name WHERE superhero.height_cm > 0.8 * (SELECT AVG(height_cm) FROM superhero)\n#SQL: SELECT T1.power_name FROM superpower AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.power_id INNER JOIN superhero AS T3 ON T2.hero_id = T3.id WHERE T3.height_cm > (SELECT AVG(height_cm) * 0.8 FROM superhero)\n```"
    ],
    "1345": [
        "```\n#reason: The question wants to count the number of majors in \"College of Humanities and Social Sciences\", so the SQL SELECT will count the distinct majors where the college matches the specified name.\n#columns: major.major_id, major.college\n#values: 'College of Humanities and Social Sciences' refer to major.college = 'College of Humanities and Social Sciences'\n#SELECT: How many majors refer to COUNT(DISTINCT major.major_id)\n#SQL-like: Show COUNT(DISTINCT major.major_id), WHERE major.college = 'College of Humanities and Social Sciences'\n#SQL: SELECT COUNT(DISTINCT major.major_id) FROM major WHERE major.college = 'College of Humanities and Social Sciences'\n```"
    ],
    "651": [
        "```\n#reason: The question wants to find the related post title of a specific post, so the SQL SELECT will retrieve the title of the related post where the post's title matches the specified title.\n#columns: posts.Title\n#values: 'How to tell if something happened in a data set which monitors a value over time' refer to posts.Title = 'How to tell if something happened in a data set which monitors a value over time'\n#SELECT: SELECT posts.Title refer to posts.Title\n#SQL-like: Show posts.Title WHERE posts.Title = 'How to tell if something happened in a data set which monitors a value over time'\n#SQL: SELECT T1.Title FROM posts AS T1 INNER JOIN postLinks AS T2 ON T1.Id = T2.RelatedPostId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T3.Title = 'How to tell if something happened in a data set which monitors a value over time'\n```"
    ],
    "632": [
        "```\n#reason: The question wants to know how many votes were made by Harlan, so the SQL SELECT will count the votes where the user's display name is 'Harlan'.\n#columns: votes.Id, users.DisplayName\n#values: 'Harlan' refers to users.DisplayName = 'Harlan'\n#SELECT: SELECT COUNT(votes.Id) refer to votes.Id\n#SQL-like: Show COUNT(votes.Id), WHERE users.DisplayName = 'Harlan'\n#SQL: SELECT COUNT(T1.Id) FROM votes AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'Harlan'\n```"
    ],
    "1422": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"the category of events held at MU 215\", so the SQL SELECT will target the event type from the event table where the event's location matches 'MU 215'.\n#columns: event.type\n#values: 'MU 215' refer to event.location = 'MU 215'\n#SELECT: SELECT event.type refer to event.type\n#SQL-like: Show event.type WHERE event.location = 'MU 215'\n#SQL: SELECT type FROM event WHERE location = 'MU 215'\n```"
    ],
    "98": [
        "```\n#reason: The question wants to list out the accounts that have the lowest approved amount among those with approved loan dates in 1997, and choose weekly issuance statement. So the SQL SELECT will filter by loan date and amount, and also check for the frequency of 'POPLATEK TYDNE'.\n#columns: loan.account_id, loan.amount, account.frequency\n#values: 'approved loan date in 1997' refer to loan.date BETWEEN '1997-01-01' AND '1997-12-31', 'weekly issuance statement' refer to account.frequency = 'POPLATEK TYDNE'\n#SELECT: SELECT account_id, amount refer to loan.account_id, loan.amount\n#SQL-like: Show loan.account_id, loan.amount WHERE loan.date BETWEEN '1997-01-01' AND '1997-12-31' AND account.frequency = 'POPLATEK TYDNE' ORDER BY loan.amount ASC LIMIT 1\n#SQL: SELECT T1.account_id, T1.amount FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T1.date BETWEEN '1997-01-01' AND '1997-12-31' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount ASC LIMIT 1\n```"
    ],
    "1275": [
        "```\n#reason: The question wants to count how many male patients have a normal level of anti-centromere and anti-SSB. The SQL SELECT will count the distinct Patient.ID where both testing criteria and gender conditions are satisfied.\n#columns: Patient.ID, Patient.SEX, Laboratory.CENTROMEA, Laboratory.SSB\n#values: normal level of anti-centromere refers to Laboratory.CENTROMEA IN ('-', '+-'), normal level of anti-SSB refers to Laboratory.SSB IN ('-', '+-'), male refers to Patient.SEX = 'M'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.SEX = 'M' AND Laboratory.CENTROMEA IN ('-', '+-') AND Laboratory.SSB IN ('-', '+-')\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.CENTROMEA IN ('-', '+-') AND T2.SSB IN ('-', '+-')\n```"
    ],
    "987": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the \"average fastest lap time\" of the \"top 10 drivers\" in the 2006 \"United States Grand Prix\". \"Top 10\" refers to \"rank < 11\", and the average is determined using \"AVG(fastestLapTime)\".\n#columns: results.fastestLapTime\n#values: year = 2006 refer to races.year = 2006, race name = 'United States Grand Prix' refer to races.name = 'United States Grand Prix', rank < 11 refer to results.rank < 11\n#SELECT: SELECT AVG(fastestLapTime) refer to AVG(results.fastestLapTime)\n#SQL-like: Show AVG(results.fastestLapTime) WHERE results.rank < 11 AND results.raceId = (SELECT raceId FROM races WHERE races.name = 'United States Grand Prix' AND races.year = 2006)\n#SQL: SELECT AVG(CAST(results.fastestLapTime AS REAL)) FROM results WHERE results.rank < 11 AND results.raceId = (SELECT raceId FROM races WHERE races.name = 'United States Grand Prix' AND races.year = 2006)\n```"
    ],
    "40": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the telephone number\" for \"the school\" with the lowest average score in reading in the \"Fresno Unified\" district, so the SQL SELECT will include the telephone number and will filter based on the district name and the average reading score.\n#columns: schools.Phone, satscores.AvgScrRead, schools.District\n#values: 'Fresno Unified' refers to schools.District = 'Fresno Unified'\n#SELECT: SELECT schools.Phone refer to schools.Phone\n#SQL-like: Show schools.Phone WHERE schools.District = 'Fresno Unified' ORDER BY satscores.AvgScrRead ASC LIMIT 1\n#SQL: SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds WHERE T1.District = 'Fresno Unified' ORDER BY T2.AvgScrRead ASC LIMIT 1\n```"
    ],
    "194": [
        "```\n#reason: The question wants to provide the IDs and age of clients with a high-level credit card who are eligible for loans, so the SQL SELECT will include client.client_id and the age calculated from client.birth_date.\n#columns: client.client_id, client.birth_date\n#values: high-level credit card refers to card.type = 'gold', eligible for loans refers to disp.type = 'OWNER'\n#SELECT: SELECT client.client_id, (strftime('%Y', 'now') - strftime('%Y', client.birth_date)) AS age\n#SQL-like: Show client.client_id, (strftime('%Y', 'now') - strftime('%Y', client.birth_date)) AS age WHERE card.type = 'gold' AND disp.type = 'OWNER'\n#SQL: SELECT client.client_id, (strftime('%Y', 'now') - strftime('%Y', client.birth_date)) AS age FROM client INNER JOIN disp ON client.client_id = disp.client_id INNER JOIN card ON disp.disp_id = card.disp_id WHERE card.type = 'gold' AND disp.type = 'OWNER'\n```"
    ],
    "707": [
        "```\n#reason: The question wants to find the comment with the highest score among posts that have views ranging from 100 to 150, so the SQL SELECT will involve filtering posts based on ViewCount and then determining the comment with the maximum score.\n#columns: comments.Text, comments.Score, posts.ViewCount\n#values: views ranging from 100 to 150 refers to posts.ViewCount BETWEEN 100 AND 150\n#SELECT: SELECT comments.Text refer to comments.Text\n#SQL-like: Show comments.Text WHERE posts.ViewCount BETWEEN 100 AND 150 ORDER BY comments.Score DESC LIMIT 1\n#SQL: SELECT comments.Text FROM comments INNER JOIN posts ON comments.PostId = posts.Id WHERE posts.ViewCount BETWEEN 100 AND 150 ORDER BY comments.Score DESC LIMIT 1\n```"
    ],
    "224": [
        "```\n#reason: The question wants to display the bond IDs that have the same atom ID 2 of TR000_2, so the SQL SELECT will retrieve bond IDs from the connected table where atom_id2 matches TR000_2.\n#columns: connected.bond_id\n#values: TR000_2 refers to connected.atom_id2 = 'TR000_2'\n#SELECT: bond IDs refer to connected.bond_id\n#SQL-like: Show connected.bond_id WHERE connected.atom_id2 = 'TR000_2'\n#SQL: SELECT bond_id FROM connected WHERE atom_id2 = 'TR000_2'\n```"
    ],
    "1531": [
        "```\n#reason: The question wants to identify the top spending customer and calculate the average price per single item purchased by this customer, along with the currency used. The average price per single item is calculated as Total(price) divided by Total(amount).\n#columns: customers.CustomerID, transactions_1k.Price, transactions_1k.Amount, customers.Currency\n#values: 'top spending customer' refers to the customer with the maximum total price, which can be derived from the sum of transactions_1k.Price, and 'currency' refers to customers.Currency.\n#SELECT: SELECT customers.CustomerID, SUM(transactions_1k.Price) / SUM(transactions_1k.Amount) AS average_price, customers.Currency refer to customers.CustomerID, average price per single item, and currency.\n#SQL-like: Show customers.CustomerID, SUM(transactions_1k.Price) / SUM(transactions_1k.Amount), customers.Currency, WHERE ORDER BY SUM(transactions_1k.Price) DESC LIMIT 1\n#SQL: SELECT T1.CustomerID, SUM(T2.Price) / SUM(T2.Amount) AS average_price, T1.Currency FROM customers AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.CustomerID ORDER BY SUM(T2.Price) DESC LIMIT 1\n```"
    ],
    "309": [
        "```\n#reason: The question wants to list out the atom id that belongs to the TR346 molecule and count the distinct bond types that can be created by this molecule, so the SQL SELECT will retrieve atom_id and count distinct bond_type for the molecule TR346.\n#columns: atom.atom_id, bond.bond_type\n#values: 'molecule TR346' refer to atom.molecule_id = 'TR346' AND bond.molecule_id = 'TR346'\n#SELECT: SELECT atom.atom_id, COUNT(DISTINCT bond.bond_type) refer to atom.atom_id, bond.bond_type.\n#SQL-like: Show atom.atom_id, COUNT(DISTINCT bond.bond_type) WHERE atom.molecule_id = 'TR346' AND bond.molecule_id = 'TR346'\n#SQL: SELECT atom.atom_id, COUNT(DISTINCT bond.bond_type) FROM atom LEFT JOIN bond ON atom.molecule_id = bond.molecule_id WHERE atom.molecule_id = 'TR346'\n```"
    ],
    "871": [
        "```\n#reason: The question requires displaying the driver's origin. \"Q2 time as 0:01:15\" is a filtering condition, and \"race No. 347\" refers to raceId.\n#columns: drivers.nationality\n#values: race No. 347 refers to qualifying.raceId = 347 and Q2 time is 0:01:15 refers to qualifying.q2 = '0:01:15'\n#SELECT: nationality refers to drivers.nationality\n#SQL-like: Show drivers.nationality, WHERE qualifying.raceId = 347 AND qualifying.q2 = '0:01:15'\n#SQL: SELECT T1.nationality FROM drivers AS T1 INNER JOIN qualifying AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 347 AND T2.q2 = '0:01:15'\n```"
    ],
    "867": [
        "```\n#reason: The question wants to find the origin of the driver who set the fastest lap speed in race No.933, so the SQL SELECT will retrieve the driver's nationality based on the maximum fastest lap speed in that specific race.\n#columns: drivers.nationality, results.fastestLapSpeed, results.raceId\n#values: race No.933 refers to results.raceId = 933\n#SELECT: nationality of the driver who set the fastest lap speed refers to drivers.nationality\n#SQL-like: Show drivers.nationality, WHERE results.raceId = 933, ORDER BY results.fastestLapSpeed DESC LIMIT 1\n#SQL: SELECT T1.nationality FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.raceId = 933 ORDER BY T2.fastestLapSpeed DESC LIMIT 1\n```"
    ],
    "1150": [
        "```\n#reason: The question wants to calculate the percentage of female patients who were born after 1930. This involves counting the number of female patients born after 1930 and dividing it by the total number of female patients. The SQL SELECT statement will include the necessary conditions for filtering based on gender and birth year.\n#columns: Patient.ID, Patient.Birthday, Patient.SEX\n#values: 'born after 1930' refers to year(Birthday) > '1930', 'female patient' refers to Sex = 'F'\n#SELECT: SELECT content (percentage of female patients born after 1930) refer to COUNT(ID) where year(Birthday) > '1930' and SEX = 'F' divided by COUNT(ID) where SEX = 'F'.\n#SQL-like: Show DIVIDE(COUNT(ID) WHERE year(Birthday) > '1930' AND SEX = 'F', COUNT(ID) WHERE SEX = 'F')\n#SQL: SELECT CAST(COUNT(CASE WHEN Birthday > '1930-01-01' AND SEX = 'F' THEN 1 END) AS REAL) * 100 / COUNT(CASE WHEN SEX = 'F' THEN 1 END) FROM Patient\n```"
    ],
    "180": [
        "```\n#reason: The question requires generating a list of clients born between 1983 and 1987 and whose account branch is in East Bohemia, so the SQL SELECT will include client IDs and names filtered by birth date and district.\n#columns: client.client_id, client.birth_date, account.district_id, district.A3\n#values: 'born between 1983 and 1987' refers to \"strftime('%Y', client.birth_date) BETWEEN '1983' AND '1987'\", 'account branch is in East Bohemia' refers to \"district.A3 = 'east Bohemia'\"\n#SELECT: SELECT client.client_id, client.birth_date refer to client.client_id, client.birth_date\n#SQL-like: Show client.client_id, client.birth_date WHERE strftime('%Y', client.birth_date) BETWEEN '1983' AND '1987' AND district.A3 = 'east Bohemia'\n#SQL: SELECT client.client_id, client.birth_date FROM client INNER JOIN account ON client.district_id = account.district_id INNER JOIN district ON account.district_id = district.district_id WHERE strftime('%Y', client.birth_date) BETWEEN '1983' AND '1987' AND district.A3 = 'east Bohemia'\n```"
    ],
    "64": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the total number of schools in Hickman with a specific charter number, so the SQL SELECT will count the schools where the mailing city is Hickman and the charter number is 00D4.\n#columns: schools.MailCity, schools.CharterNum\n#values: 'mailing city is Hickman' refer to schools.MailCity = 'Hickman', 'charter number 00D4' refer to schools.CharterNum = '00D4'\n#SELECT: SELECT total number of schools refer to COUNT(schools.CDSCode)\n#SQL-like: Show COUNT(schools.CDSCode), WHERE schools.MailCity = 'Hickman' AND schools.CharterNum = '00D4'\n#SQL: SELECT COUNT(schools.CDSCode) FROM schools WHERE schools.MailCity = 'Hickman' AND schools.CharterNum = '00D4'\n```"
    ],
    "363": [
        "```\n#reason: The question wants to count the number of cards whose legalities status is restricted and that are found in a starter deck, so the SQL SELECT will count the cards with the specified conditions.\n#columns: cards.id, legalities.status, cards.isStarter\n#values: 'status is restricted' refers to legalities.status = 'Restricted', 'found in the starter deck' refers to cards.isStarter = 1\n#SELECT: SELECT COUNT(cards.id) refer to cards.id\n#SQL-like: Show COUNT(cards.id), WHERE legalities.status = 'Restricted' AND cards.isStarter = 1\n#SQL: SELECT COUNT(cards.id) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'Restricted' AND cards.isStarter = 1\n```"
    ],
    "492": [
        "```\n#reason: The question wants to display the expansion type of the set \"From the Vault: Lore\", so the SQL SELECT will retrieve the type from the sets table where the name contains 'From the Vault: Lore'.\n#columns: sets.type, sets.name\n#values: 'From the Vault: Lore' refer to sets.name LIKE '%From the Vault: Lore%'\n#SELECT: SELECT sets.type FROM sets WHERE sets.name LIKE '%From the Vault: Lore%'\n#SQL-like: Show sets.type, WHERE sets.name LIKE '%From the Vault: Lore%'\n#SQL: SELECT sets.type FROM sets WHERE sets.name LIKE '%From the Vault: Lore%'\n```"
    ],
    "1037": [
        "```\n#reason: The question wants to calculate the percentage of players who prefer left foot and were born between 1987 and 1992. The SQL SELECT statement will sum the players who prefer left foot and divide it by the total count of players born in that range, multiplying by 100 for the percentage.\n#columns: Player_Attributes.preferred_foot, Player.birthday, Player.player_fifa_api_id\n#values: 'born between 1987 and 1992' refers to strftime('%Y', Player.birthday) BETWEEN '1987' AND '1992'\n#SELECT: SELECT DIVIDE(MULTIPLY(SUM(preferred_foot = 'left'), 100), COUNT(player_fifa_api_id)) refer to Player_Attributes.preferred_foot, Player.birthday, Player.player_fifa_api_id\n#SQL-like: Show DIVIDE(MULTIPLY(SUM(preferred_foot = 'left'), 100), COUNT(player_fifa_api_id)) WHERE strftime('%Y', Player.birthday) BETWEEN '1987' AND '1992'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.preferred_foot = 'left' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.player_fifa_api_id) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_fifa_api_id = T2.player_fifa_api_id WHERE strftime('%Y', T2.birthday) BETWEEN '1987' AND '1992'\n```"
    ],
    "777": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the gender of the superhero, which is defined as gender, and the filtering condition is based on the superhero's name being 'Agent 13'.\n#columns: superhero.gender_id, gender.gender\n#values: 'Agent 13 hero' refers to superhero_name = 'Agent 13'\n#SELECT: gender refer to gender.gender\n#SQL-like: Show gender.gender WHERE superhero_name = 'Agent 13'\n#SQL: SELECT T2.gender FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T1.superhero_name = 'Agent 13'\n```"
    ],
    "219": [
        "```\n#reason: The question involves calculating the percentage of carcinogenic molecules that have triple type bonds. The calculation involves dividing the count of bonds that are of type '#' by the total count of bonds, while filtering for carcinogenic molecules which are indicated by label = '+'. \n#columns: bond.bond_type, molecule.label, bond.bond_id\n#values: triple bond refers to bond.bond_type = '#', label = '+' refers to molecule.label = '+'\n#SELECT: percentage of carcinogenic molecules in triple type bonds refer to DIVIDE(SUM(bond.bond_type = '#') * 100, COUNT(bond.bond_id))\n#SQL-like: Show DIVIDE(SUM(bond.bond_type = '#') * 100, COUNT(bond.bond_id)), WHERE molecule.label = '+'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.bond_type = '#' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'\n```"
    ],
    "1198": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of female patients diagnosed with APS, so the SQL SELECT will count the Patient.ID where SEX is 'F' and Diagnosis is 'APS'.\n#columns: Patient.SEX, Patient.Diagnosis, Patient.ID\n#values: 'female' refers to Patient.SEX = 'F', 'APS diagnosis' refers to Examination.Diagnosis = 'APS'\n#SELECT: SELECT COUNT(Patient.ID) refer to COUNT(Patient.ID)\n#SQL-like: Show COUNT(Patient.ID), WHERE Patient.SEX = 'F' AND Examination.Diagnosis = 'APS'\n#SQL: SELECT COUNT(T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'F' AND T2.Diagnosis = 'APS'\n```"
    ],
    "1517": [
        "```\n#reason: The question requires display in order: \"segment of the earliest customer\". The earliest customer refers to the minimum CustomerID as a proxy for the earliest record, since CustomerID is unique and integer-based.\n#columns: customers.Segment\n#values: earliest customer refers to MIN(customers.CustomerID)\n#SELECT: SELECT Segment refer to customers.Segment\n#SQL-like: Show customers.Segment WHERE customers.CustomerID = (SELECT MIN(CustomerID) FROM customers)\n#SQL: SELECT Segment FROM customers WHERE CustomerID = (SELECT MIN(CustomerID) FROM customers)\n```"
    ],
    "1427": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the budget category of events located at 'MU 215' with a type of 'Guest Speaker' and a budget spent of 0, so the SQL SELECT will retrieve the category from the budget table where the event's location and type match the given criteria.\n#columns: budget.category, event.location, event.type, budget.spent\n#values: 'events located at MU 215' refer to event.location = 'MU 215', 'guest speaker type' refer to event.type = 'Guest Speaker', '0 budget spent' refer to budget.spent = 0\n#SELECT: SELECT budget.category refer to budget.category\n#SQL-like: Show budget.category WHERE event.location = 'MU 215' AND event.type = 'Guest Speaker' AND budget.spent = 0\n#SQL: SELECT budget.category FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.location = 'MU 215' AND event.type = 'Guest Speaker' AND budget.spent = 0\n```"
    ],
    "793": [
        "```\n#reason: The question wants to find the count of male superheroes who have the race of 'God / Eternal'. Therefore, the SQL SELECT statement will count the superheroes filtered by gender and race.\n#columns: superhero.id, superhero.gender_id, superhero.race_id\n#values: race \"god/eternal\" refers to superhero.race_id = 1, male refers to superhero.gender_id = 1\n#SELECT: SELECT COUNT(superhero.id) refer to COUNT(superhero.id)\n#SQL-like: Show COUNT(superhero.id), WHERE superhero.race_id = 1 AND superhero.gender_id = 1\n#SQL: SELECT COUNT(superhero.id) FROM superhero WHERE superhero.race_id = 1 AND superhero.gender_id = 1\n```"
    ],
    "1084": [
        "```\n#reason: The question wants to count how many players were born before the year 1986 and have a high defensive work rate, so the SQL SELECT will count distinct player IDs based on the specified conditions.\n#columns: Player.birthday, Player_Attributes.defensive_work_rate, Player.id\n#values: 'born before the year 1986' refers to strftime('%Y', Player.birthday) < '1986'; 'would remain in his position and defense while the team attacked' refers to Player_Attributes.defensive_work_rate = 'high'\n#SELECT: COUNT(DISTINCT Player.id) refer to Player.id\n#SQL-like: Show COUNT(DISTINCT Player.id), WHERE strftime('%Y', Player.birthday) < '1986' AND Player_Attributes.defensive_work_rate = 'high'\n#SQL: SELECT COUNT(DISTINCT T1.id) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE strftime('%Y', T1.birthday) < '1986' AND T2.defensive_work_rate = 'high'\n```"
    ],
    "1313": [
        "```\n#reason: The question wants to find the number of students from the College of Engineering, so the SQL SELECT will count the number of members linked to majors in that college.\n#columns: member.link_to_major, major.college\n#values: 'from the College of Engineering' refer to 'major.college = 'College of Engineering''\n#SELECT: SELECT COUNT(member.link_to_major) refer to member.link_to_major\n#SQL-like: Show COUNT(member.link_to_major), WHERE major.college = 'College of Engineering'\n#SQL: SELECT COUNT(member.link_to_major) FROM member INNER JOIN major ON member.link_to_major = major.major_id WHERE major.college = 'College of Engineering'\n```"
    ],
    "885": [
        "```\n#reason: The question wants to identify the \"name and date of the last round of race in year 1999\", so the SQL SELECT will involve filtering for the year 1999 and finding the maximum round.\n#columns: races.name, races.date\n#values: last round refers to MAX(round) and year 1999 refers to races.year = 1999\n#SELECT: SELECT name, date\n#SQL-like: Show name, date WHERE year = 1999 ORDER BY round DESC LIMIT 1\n#SQL: SELECT name, date FROM races WHERE year = 1999 ORDER BY round DESC LIMIT 1\n```"
    ],
    "857": [
        "```\n#reason: The question wants to display the coordinate position for the Abu Dhabi Grand Prix, so the SQL SELECT will retrieve the latitude and longitude based on the race name.\n#columns: circuits.lat, circuits.lng\n#values: 'Abu Dhabi Grand Prix' refer to races.name = 'Abu Dhabi Grand Prix'\n#SELECT: SELECT lat, lng refer to circuits.lat, circuits.lng\n#SQL-like: Show circuits.lat, circuits.lng WHERE races.name = 'Abu Dhabi Grand Prix'\n#SQL: SELECT T1.lat, T1.lng FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Abu Dhabi Grand Prix'\n```"
    ],
    "390": [
        "```\n#reason: The question wants to display the colors of cards and the format of these cards where the ID is between 1 and 20, so the SQL SELECT will include the colors and format of the cards filtered by ID.\n#columns: cards.colors, legalities.format\n#values: ID 1-20 refers to cards.id BETWEEN 1 AND 20\n#SELECT: colors of cards refer to cards.colors, format of these cards refers to legalities.format\n#SQL-like: Show cards.colors, legalities.format WHERE cards.id BETWEEN 1 AND 20\n#SQL: SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20\n```"
    ],
    "989": [
        "```\n#reason: The question requires identifying \"the champion\" of the \"Canadian Grand Prix in 2008\" and displaying \"his finish time\". \"Canadian Grand Prix\" refers to the race name and \"2008\" refers to the year of the race.\n#columns: results.time, races.name, races.year\n#values: 'Canadian Grand Prix' refers to races.name = 'Canadian Grand Prix', '2008' refers to races.year = 2008\n#SELECT: SELECT results.time refer to results.time, indicating champion of the race refer to results.resultId\n#SQL-like: Show results.time WHERE races.name = 'Canadian Grand Prix' AND races.year = 2008 AND results.position = 1\n#SQL: SELECT results.time FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.name = 'Canadian Grand Prix' AND races.year = 2008 AND results.position = 1\n```"
    ],
    "511": [
        "```\n#reason: The question wants to identify the most common visual frame effects among incredibly powerful foils, which are defined as having both cardKingdomFoilId and cardKingdomId not null. The most common visual frame effects refers to MAX(frameEffects).\n#columns: cards.frameEffects\n#values: incredibly powerful foils refer to cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SELECT: SELECT the most common visual frame effects refer to cards.frameEffects\n#SQL-like: Show cards.frameEffects, WHERE cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL, GROUP BY cards.frameEffects ORDER BY COUNT(cards.frameEffects) DESC LIMIT 1\n#SQL: SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1\n```"
    ],
    "247": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list all the elements of atoms that cannot bond with any other atoms, so the SQL SELECT will retrieve the elements from the atom table where the atom_id is not present in the connected table.\n#columns: atom.element\n#values: atoms cannot bond with other atoms means atom.atom_id NOT IN (SELECT connected.atom_id FROM connected)\n#SELECT: SELECT element refer to atom.element\n#SQL-like: Show atom.element, WHERE atom.atom_id NOT IN (SELECT connected.atom_id FROM connected)\n#SQL: SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected)\n```"
    ],
    "13": [
        "```\n#reason: The question wants to list the phone numbers of the schools with the top 3 SAT excellence rate. The excellence rate is defined as NumGE1500 / NumTstTakr, therefore, the SQL SELECT will need to calculate the excellence rate and order by it while limiting the result to the top 3.\n#columns: schools.Phone, satscores.NumGE1500, satscores.NumTstTakr\n#values: None\n#SELECT: SELECT the phone numbers refer to schools.Phone\n#SQL-like: Show schools.Phone, ORDER BY (satscores.NumGE1500 * 1.0 / satscores.NumTstTakr) DESC LIMIT 3\n#SQL: SELECT T1.Phone FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY (T2.NumGE1500 * 1.0 / T2.NumTstTakr) DESC LIMIT 3\n```"
    ],
    "863": [
        "```\n#reason: The question wants to display the season page of the year when a specific race took place, so the SQL SELECT will retrieve the season year based on the race ID.\n#columns: seasons.year, seasons.url\n#values: race No. 901 refers to races.raceId = 901\n#SELECT: season page refers to seasons.url, year refers to seasons.year\n#SQL-like: Show seasons.year, seasons.url WHERE races.raceId = 901\n#SQL: SELECT seasons.year, seasons.url FROM races INNER JOIN seasons ON races.year = seasons.year WHERE races.raceId = 901\n```"
    ],
    "50": [
        "```\n#reason: The question wants to display the \"postal street address\" for the school with the 7th highest Math average, so the SQL SELECT will include the school's name and the street address, ordered by the average Math score.\n#columns: schools.School, schools.Street\n#values: 7th highest Math average refers to ORDER BY satscores.AvgScrMath DESC LIMIT 6, 1\n#SELECT: SELECT schools.School, schools.Street\n#SQL-like: Show schools.School, schools.Street WHERE ordered by satscores.AvgScrMath DESC LIMIT 6, 1\n#SQL: SELECT T1.School, T2.Street FROM satscores AS T2 INNER JOIN schools AS T1 ON T2.cds = T1.CDSCode ORDER BY T2.AvgScrMath DESC LIMIT 6, 1\n```"
    ],
    "10": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the FRPM count for students aged 5-17 for the school with the highest average score in Reading in the SAT test, so the SQL SELECT will retrieve the FRPM count from the frpm table where the corresponding school has the maximum average score in Reading from the satscores table.\n#columns: frpm.`FRPM Count (Ages 5-17)`, satscores.AvgScrRead\n#values: highest average score in Reading refers to satscores.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores)\n#SELECT: SELECT FRPM count refer to frpm.`FRPM Count (Ages 5-17)`\n#SQL-like: Show frpm.`FRPM Count (Ages 5-17) WHERE satscores.AvgScrRead = (SELECT MAX(satscores.AvgScrRead) FROM satscores)\n#SQL: SELECT T1.`FRPM Count (Ages 5-17)` FROM frpm AS T1 INNER JOIN satscores AS T2 ON T1.cds = T2.cds WHERE T2.AvgScrRead = (SELECT MAX(AvgScrRead) FROM satscores)\n```"
    ],
    "1088": [
        "```\n#reason: The question wants to list the names of the players whose volley score and dribbling score are over 70, so the SQL SELECT will include Player.player_name and apply the filtering conditions for volley and dribbling scores.\n#columns: Player.player_name, Player_Attributes.volleys, Player_Attributes.dribbling\n#values: volley score are over 70 refer to Player_Attributes.volleys > 70, dribbling score are over 70 refer to Player_Attributes.dribbling > 70\n#SELECT: SELECT Player.player_name refer to Player.player_name\n#SQL-like: Show Player.player_name WHERE Player_Attributes.volleys > 70 AND Player_Attributes.dribbling > 70\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.volleys > 70 AND T2.dribbling > 70\n```"
    ],
    "779": [
        "```\n#reason: The question wants to count the number of powers associated with the hero named Amazo, so the SQL SELECT will count the distinct powers linked to that hero.\n#columns: superpower.id\n#values: 'Amazo hero' refers to superhero_name = 'Amazo'\n#SELECT: SELECT COUNT(DISTINCT superpower.id) refer to superpower.id\n#SQL-like: Show COUNT(DISTINCT superpower.id) FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superhero.superhero_name = 'Amazo'\n#SQL: SELECT COUNT(DISTINCT superpower.id) FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superhero.superhero_name = 'Amazo'\n```"
    ],
    "1509": [
        "```\n#reason: The question wants to count the number of transactions made in gas stations located in the Czech Republic after a specific date, so the SQL SELECT will count the transactions where the gas station is in 'CZE' and the date is after '2012-01-01'.\n#columns: transactions_1k.TransactionID, transactions_1k.Date, gasstations.Country\n#values: transactions made in gas stations in the Czech Republic refers to gasstations.Country = 'CZE', after 2012/1/1 refers to transactions_1k.Date > '2012-01-01'\n#SELECT: how many transactions refer to COUNT(transactions_1k.TransactionID)\n#SQL-like: Show COUNT(transactions_1k.TransactionID), WHERE gasstations.Country = 'CZE' AND transactions_1k.Date > '2012-01-01'\n#SQL: SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T2.Country = 'CZE' AND T1.Date > '2012-01-01'\n```"
    ],
    "90": [
        "```\n#reason: The question requires display in order: \"how many accounts\". \"region in Prague\" is a filtering condition, and \"eligible for loans\" refers to accounts that have an associated loan record.\n#columns: account.account_id, account.district_id, loan.account_id\n#values: region in Prague refers to district.A3 = 'Prague'\n#SELECT: how many accounts refer to COUNT(account.account_id)\n#SQL-like: Show COUNT(account.account_id), WHERE district.A3 = 'Prague' and loan.account_id is not NULL\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T2.A3 = 'Prague'\n```"
    ],
    "43": [
        "```\n#reason: The question wants to find the average math score of the school with the lowest average score for all subjects, which can be computed by summing the average scores in Math, Reading, and Writing, and then finding the school with the minimum total score. Therefore, the SQL SELECT will include the average math score and the county name of that school.\n#columns: satscores.AvgScrMath, satscores.cname, satscores.AvgScrMath + satscores.AvgScrRead + satscores.AvgScrWrite\n#values: the lowest average score for all subjects refers to (satscores.AvgScrMath + satscores.AvgScrRead + satscores.AvgScrWrite) = (SELECT MIN(AvgScrMath + AvgScrRead + AvgScrWrite) FROM satscores)\n#SELECT: SELECT satscores.AvgScrMath, satscores.cname\n#SQL-like: Show AvgScrMath, cname, WHERE (AvgScrMath + AvgScrRead + AvgScrWrite) = (SELECT MIN(AvgScrMath + AvgScrRead + AvgScrWrite) FROM satscores)\n#SQL: SELECT satscores.AvgScrMath, satscores.cname FROM satscores WHERE (satscores.AvgScrMath + satscores.AvgScrRead + satscores.AvgScrWrite) = (SELECT MIN(AvgScrMath + AvgScrRead + AvgScrWrite) FROM satscores)\n```"
    ],
    "299": [
        "```\n#reason: The question asks whether molecule TR124 is carcinogenic, which is determined by checking the label. The filtering condition is that the label must be '+' to indicate \"carcinogenic\".\n#columns: molecule.label\n#values: label = '+' refers to molecule.label = '+'\n#SELECT: Is molecule TR124 carcinogenic? refers to molecule.label\n#SQL-like: Show molecule.label WHERE molecule.molecule_id = 'TR124'\n#SQL: SELECT label FROM molecule WHERE molecule_id = 'TR124'\n```"
    ],
    "487": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the percentage of incredibly powerful cards in the set Coldsnap, so the SQL SELECT will calculate the sum of cards that are incredibly powerful and divide it by the total number of cards in the set, then multiply by 100.\n#columns: cards.cardKingdomFoilId, cards.cardKingdomId, cards.name\n#values: 'set Coldsnap' refer to cards.name = 'Coldsnap', 'incredibly powerful' refer to cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SELECT: SELECT DIVIDE(SUM(cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL), SUM(name = 'Coldsnap')) * 100 refer to cards.cardKingdomFoilId, cards.cardKingdomId, cards.name\n#SQL-like: Show DIVIDE(SUM(cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL), SUM(name = 'Coldsnap')) * 100, WHERE cards.name = 'Coldsnap'\n#SQL: SELECT CAST(SUM(CASE WHEN cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(cards.name) FROM cards WHERE cards.name = 'Coldsnap'\n```"
    ],
    "1297": [
        "```\n#reason: The question wants to count the number of patients whose total cholesterol is higher than normal and have a negative measure of degree of coagulation, so the SQL SELECT will count the distinct Patient.ID where `T-CHO` >= 250 and KCT = '-'.\n#columns: Patient.ID, Laboratory.`T-CHO`, Examination.KCT\n#values: total cholesterol is higher than normal refer to Laboratory.`T-CHO` >= 250, negative measure of degree of coagulation refer to Examination.KCT = '-'\n#SELECT: COUNT(DISTINCT Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.`T-CHO` >= 250 AND Examination.KCT = '-'\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.`T-CHO` >= 250 AND T2.KCT = '-'\n```"
    ],
    "634": [
        "```\n#reason: The question wants to identify which post has higher popularity among those by Harvey Motulsky and Noah Snyder, so the SQL SELECT will calculate the maximum view count for posts by these users.\n#columns: posts.Id, posts.ViewCount\n#values: 'DisplayName is Harvey Motulsky or Noah Snyder' refer to users.DisplayName IN ('Harvey Motulsky', 'Noah Snyder')\n#SELECT: SELECT posts.Id, MAX(SUM(posts.ViewCount)) refer to posts.ViewCount\n#SQL-like: Show posts.Id, MAX(SUM(posts.ViewCount)), WHERE users.DisplayName IN ('Harvey Motulsky', 'Noah Snyder'), GROUP BY posts.Id\n#SQL: SELECT T1.Id FROM posts AS T1 INNER JOIN users AS T2 ON T1.OwnerUserId = T2.Id WHERE T2.DisplayName IN ('Harvey Motulsky', 'Noah Snyder') GROUP BY T1.Id ORDER BY SUM(T1.ViewCount) DESC LIMIT 1\n```"
    ],
    "44": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the \"average writing score\" of the school with the \"highest number of test takers whose total SAT scores are greater or equal to 1500\" and the \"city\" where that school is situated. So the SQL needs to calculate the average writing score and select the city along with it.\n#columns: satscores.AvgScrWrite, schools.City\n#values: 'highest number of test takers who scored >= 1500' refer to satscores.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores)\n#SELECT: SELECT average writing score refer to AVG(satscores.AvgScrWrite), city refer to schools.City\n#SQL-like: Show AVG(satscores.AvgScrWrite), schools.City WHERE satscores.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores)\n#SQL: SELECT AVG(T1.AvgScrWrite), T2.City FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode WHERE T1.NumGE1500 = (SELECT MAX(NumGE1500) FROM satscores) GROUP BY T2.City\n```"
    ],
    "671": [
        "```\n#reason: The question wants to find the display name of the user who acquired the first Autobiographer badge, so the SQL SELECT will retrieve the user's display name based on the minimum date of badge acquisition for the specified badge name.\n#columns: badges.Date, users.DisplayName\n#values: 'Autobiographer' refer to badges.Name = 'Autobiographer', 'acquired the first' refer to MIN(badges.Date)\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName WHERE badges.Name = 'Autobiographer' ORDER BY badges.Date ASC LIMIT 1\n#SQL: SELECT users.DisplayName FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Autobiographer' ORDER BY badges.Date ASC LIMIT 1\n```"
    ],
    "758": [
        "```\n#reason: The question wants to display the hair colour of the human superhero who is 185 cm tall, so the SQL SELECT will filter by height and race.\n#columns: colour.colour, superhero.height_cm, race.race\n#values: 'human superhero' refers to superhero.race_id = (SELECT id FROM race WHERE race = 'Human'), '185 cm tall' refers to superhero.height_cm = 185\n#SELECT: SELECT colour.colour refer to colour.colour\n#SQL-like: Show colour.colour WHERE superhero.height_cm = 185 AND superhero.race_id = (SELECT id FROM race WHERE race = 'Human')\n#SQL: SELECT T1.colour FROM superhero AS T0 INNER JOIN colour AS T1 ON T0.hair_colour_id = T1.id WHERE T0.height_cm = 185 AND T0.race_id = (SELECT id FROM race WHERE race = 'Human')\n```"
    ],
    "430": [
        "```\n#reason: The question wants to list the top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block, so the SQL SELECT will filter by the set block and language, and order the results alphabetically.\n#columns: sets.id, sets.name\n#values: 'Italian-language cards' refer to foreign_data.language = 'Italian', 'Shadowmoor block' refer to sets.block = 'Shadowmoor'\n#SELECT: SELECT sets.id, sets.name\n#SQL-like: Show sets.id, sets.name WHERE foreign_data.language = 'Italian' AND sets.block = 'Shadowmoor' ORDER BY sets.name ASC LIMIT 2\n#SQL: SELECT T1.id, T1.name FROM sets AS T1 INNER JOIN foreign_data AS T2 ON T1.code = T2.uuid WHERE T2.language = 'Italian' AND T1.block = 'Shadowmoor' ORDER BY T1.name ASC LIMIT 2\n```"
    ],
    "1527": [
        "```\n#reason: The question wants to identify the gas station with the highest amount of revenue, so the SQL SELECT will focus on ordering by the total revenue generated by each gas station.\n#columns: gasstations.GasStationID, SUM(transactions_1k.Price) as Revenue\n#values: None\n#SELECT: SELECT the gas station with the highest revenue refers to gasstations.GasStationID\n#SQL-like: Show gasstations.GasStationID, ORDER BY SUM(transactions_1k.Price) DESC LIMIT 1\n#SQL: SELECT T1.GasStationID FROM gasstations AS T1 INNER JOIN transactions_1k AS T2 ON T1.GasStationID = T2.GasStationID GROUP BY T1.GasStationID ORDER BY SUM(T2.Price) DESC LIMIT 1\n```"
    ],
    "1129": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list down the long name for slow speed class team, so the SQL SELECT will retrieve the team_long_name where the buildUpPlaySpeedClass is 'Slow'.\n#columns: Team.team_long_name\n#values: slow speed class refers to Team_Attributes.buildUpPlaySpeedClass = 'Slow'\n#SELECT: long name refers to Team.team_long_name\n#SQL-like: Show Team.team_long_name, WHERE Team_Attributes.buildUpPlaySpeedClass = 'Slow'\n#SQL: SELECT T1.team_long_name FROM Team AS T1 INNER JOIN Team_Attributes AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.buildUpPlaySpeedClass = 'Slow'\n```"
    ],
    "416": [
        "```\n#reason: The question wants to calculate the percentage of cards that are without power and are in French. The filtering criteria are that the language must be 'French' and power must be either NULL or equal to '*'. Thus, the SQL SELECT aggregates these conditions to compute the percentage.\n#columns: cards.power, foreign_data.language\n#values: language is French refers to foreign_data.language = 'French', cards without power refers to cards.power IS NULL OR cards.power = '*'\n#SELECT: percentage of cards without power that are in French refer to (CAST(SUM(CASE WHEN foreign_data.language = 'French' AND (cards.power IS NULL OR cards.power = '*') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN cards.power IS NULL OR cards.power = '*' THEN 1 END))\n#SQL-like: Show (CAST(SUM(CASE WHEN foreign_data.language = 'French' AND (cards.power IS NULL OR cards.power = '*') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN cards.power IS NULL OR cards.power = '*' THEN 1 END))\n#SQL: SELECT CAST(SUM(CASE WHEN T2.language = 'French' AND (T1.power IS NULL OR T1.power = '*') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CASE WHEN T1.power IS NULL OR T1.power = '*' THEN 1 END) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid\n```"
    ],
    "549": [
        "```\n#reason: The question wants to identify the post from which the tag \"bayesian\" is excerpted, so the SQL SELECT will retrieve the body of the post based on the tag name.\n#columns: posts.Body, tags.TagName, tags.ExcerptPostId, posts.Id\n#values: 'bayesian' refer to tags.TagName = 'bayesian'\n#SELECT: SELECT posts.Body FROM posts INNER JOIN tags ON posts.Id = tags.ExcerptPostId WHERE tags.TagName = 'bayesian'\n#SQL-like: Show posts.Body WHERE tags.TagName = 'bayesian'\n#SQL: SELECT posts.Body FROM posts INNER JOIN tags ON posts.Id = tags.ExcerptPostId WHERE tags.TagName = 'bayesian'\n```"
    ],
    "726": [
        "```\n#reason: The question wants to rank heroes published by Marvel Comics by their height in descending order, so the SQL SELECT will include superhero_name and height_cm, and it will filter by publisher_name.\n#columns: superhero.superhero_name, superhero.height_cm\n#values: published by Marvel Comics refers to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT superhero_name, height_cm refer to superhero.superhero_name, superhero.height_cm\n#SQL-like: Show superhero.superhero_name, superhero.height_cm, WHERE publisher.publisher_name = 'Marvel Comics', ORDER BY superhero.height_cm DESC\n#SQL: SELECT T1.superhero_name, T1.height_cm FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics' ORDER BY T1.height_cm DESC\n```"
    ],
    "1156": [
        "```\n#reason: The question wants to state the ID and age of patients with a positive degree of coagulation, so the SQL SELECT will include the patient's ID and the calculated age based on their birthday.\n#columns: Patient.ID, Patient.Birthday\n#values: positive degree of coagulation refers to Examination.RVVT = '+'\n#SELECT: SELECT Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday)) AS age\n#SQL-like: Show Patient.ID, SUBTRACT(year(current_timestamp), year(Patient.Birthday)), WHERE Examination.RVVT = '+'\n#SQL: SELECT Patient.ID, strftime('%Y', 'now') - strftime('%Y', Patient.Birthday) AS age FROM Patient INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Examination.RVVT = '+'\n```"
    ],
    "1526": [
        "```\n#reason: The question wants to calculate the consumption decrease rate for a specific customer based on their payment on a specific date. The SQL SELECT will retrieve the consumption values for the years 2012 and 2013 for that customer and calculate the decrease rate.\n#columns: yearmonth.Consumption, yearmonth.CustomerID, transactions_1k.Price, transactions_1k.CustomerID\n#values: 'paid 634.8' refers to transactions_1k.Price = 634.8, '2012/8/25' refers to transactions_1k.Date = '2012-08-25'\n#SELECT: consumption decrease rate refer to (SUM(CASE WHEN yearmonth.Date = '201207' THEN yearmonth.Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.Date = '201307' THEN yearmonth.Consumption ELSE 0 END)) / SUM(CASE WHEN yearmonth.Date = '201207' THEN yearmonth.Consumption ELSE 0 END)\n#SQL-like: Show (SUM(CASE WHEN yearmonth.Date = '201207' THEN yearmonth.Consumption ELSE 0 END) - SUM(CASE WHEN yearmonth.Date = '201307' THEN yearmonth.Consumption ELSE 0 END)) / SUM(CASE WHEN yearmonth.Date = '201207' THEN yearmonth.Consumption ELSE 0 END), WHERE transactions_1k.Price = 634.8 AND transactions_1k.Date = '2012-08-25'\n#SQL: SELECT (CAST(SUM(CASE WHEN T1.Date = '201207' THEN T1.Consumption ELSE 0 END) AS REAL) - CAST(SUM(CASE WHEN T1.Date = '201307' THEN T1.Consumption ELSE 0 END) AS REAL)) / CAST(SUM(CASE WHEN T1.Date = '201207' THEN T1.Consumption ELSE 0 END) AS REAL) FROM yearmonth AS T1 INNER JOIN transactions_1k AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Price = 634.8 AND T2.Date = '2012-08-25'\n```"
    ],
    "277": [
        "```\n#reason: The question wants to identify the toxicology elements associated with a specific bond ID, so the SQL SELECT will retrieve elements that correspond to the given bond ID.\n#columns: atom.element\n#values: bond ID TR000_1_2 refers to bond.bond_id = 'TR000_1_2'\n#SELECT: toxicology elements refer to atom.element\n#SQL-like: Show atom.element WHERE bond.bond_id = 'TR000_1_2'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_id = 'TR000_1_2'\n```"
    ],
    "250": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the carcinogenic molecule with the most double bonds, so the SQL SELECT will count the double bonds for each carcinogenic molecule and order by that count.\n#columns: molecule.molecule_id, COUNT(bond.bond_type)\n#values: 'carcinogenic molecules' refer to molecule.label = '+', 'double bonds' refer to bond.bond_type = '='\n#SELECT: SELECT molecule.molecule_id, COUNT(bond.bond_type) refer to molecule.molecule_id and COUNT(bond.bond_type)\n#SQL-like: Show molecule.molecule_id, COUNT(bond.bond_type), WHERE molecule.label = '+' AND bond.bond_type = '=' GROUP BY molecule.molecule_id ORDER BY COUNT(bond.bond_type) DESC LIMIT 1\n#SQL: SELECT T1.molecule_id, COUNT(T2.bond_type) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '+' AND T2.bond_type = '=' GROUP BY T1.molecule_id ORDER BY COUNT(T2.bond_type) DESC LIMIT 1\n```"
    ],
    "70": [
        "```\n#reason: The question wants to count the number of active and closed District Community Day Schools, so the SQL SELECT will include COUNT(School Name) with a grouping for Active and Closed statuses and a filtering condition for school type and county.\n#columns: frpm.`School Name`, frpm.`School Type`, schools.StatusType\n#values: 'District Community Day Schools' refer to frpm.`School Type` = 'District Community Day Schools', 'county of Alpine' refer to schools.County = 'Alpine'\n#SELECT: SELECT COUNT(frpm.`School Name`) refer to frpm.`School Name`\n#SQL-like: Show COUNT(frpm.`School Name`) FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.`School Type` = 'District Community Day Schools' AND schools.County = 'Alpine' GROUP BY schools.StatusType\n#SQL: SELECT COUNT(frpm.`School Name`), schools.StatusType FROM frpm INNER JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.`School Type` = 'District Community Day Schools' AND schools.County = 'Alpine' GROUP BY schools.StatusType\n```"
    ],
    "367": [
        "```\n#reason: The question wants to display \"the names of the artists who illustrated the card art in Phyrexian\", so the SQL SELECT will focus on the artist from the cards table and filter by the language in the foreign_data table.\n#columns: cards.artist, foreign_data.language\n#values: 'Phyrexian' refers to foreign_data.language = 'Phyrexian'\n#SELECT: SELECT cards.artist\n#SQL-like: Show cards.artist, WHERE foreign_data.language = 'Phyrexian'\n#SQL: SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'\n```"
    ],
    "1448": [
        "```\n#reason: The question wants to find the name and date of events with expenses for pizza that were more than fifty dollars but less than a hundred dollars, so the SQL SELECT will include event_name and event_date, and the filtering conditions will be based on expense_description and cost.\n#columns: event.event_name, event.event_date\n#values: expenses for pizza refers to expense_description = 'Pizza', more than fifty dollars refers to expense.cost > 50, less than a hundred dollars refers to expense.cost < 100\n#SELECT: SELECT event.event_name, event.event_date\n#SQL-like: Show event.event_name, event.event_date WHERE expense.expense_description = 'Pizza' AND expense.cost > 50 AND expense.cost < 100\n#SQL: SELECT T1.event_name, T1.event_date FROM event AS T1 INNER JOIN expense AS T2 ON T1.event_id = T2.link_to_event WHERE T2.expense_description = 'Pizza' AND T2.cost > 50 AND T2.cost < 100\n```"
    ],
    "187": [
        "```\n#reason: The question wants to count the number of clients who choose statement of weekly issuance and are classified as Owner, so the SQL SELECT will count the disp.client_id where account.frequency is 'POPLATEK TYDNE' and disp.type is 'OWNER'.\n#columns: disp.client_id, account.frequency, disp.type\n#values: Frequency = 'POPLATEK TYDNE' refer to account.frequency = 'POPLATEK TYDNE'; Owner refers to disp.type = 'OWNER'\n#SELECT: SELECT COUNT(disp.client_id) refer to COUNT(disp.client_id).\n#SQL-like: Show COUNT(disp.client_id) WHERE account.frequency = 'POPLATEK TYDNE' AND disp.type = 'OWNER'\n#SQL: SELECT COUNT(T1.client_id) FROM disp AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE T2.frequency = 'POPLATEK TYDNE' AND T1.type = 'OWNER'\n```"
    ],
    "1226": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the oldest patient with the highest total cholesterol, so the SQL SELECT will retrieve the patient ID and T-CHO index, filtering by the oldest birthday and highest total cholesterol.\n#columns: Patient.ID, Laboratory.`T-CHO`\n#values: oldest patient refers to MIN(birthday) and highest total cholesterol refers to MAX(`T-CHO`).\n#SELECT: SELECT Patient.ID, Laboratory.`T-CHO` \n#SQL-like: Show Patient.ID, Laboratory.`T-CHO`, WHERE Patient.Birthday = (SELECT MIN(Birthday) FROM Patient) AND Laboratory.`T-CHO` = (SELECT MAX(`T-CHO`) FROM Laboratory)\n#SQL: SELECT P.ID, L.`T-CHO` FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE P.Birthday = (SELECT MIN(Birthday) FROM Patient) AND L.`T-CHO` = (SELECT MAX(`T-CHO`) FROM Laboratory)\n```"
    ],
    "744": [
        "```\n#reason: The question wants to find the difference in the number of superheroes published by DC Comics and Marvel Comics, so the SQL SELECT will calculate the published superheroes for both and subtract their counts.\n#columns: publisher.publisher_name, superhero.id\n#values: DC refers to publisher.publisher_name = 'DC Comics', Marvel Comics refers to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT SUBTRACT(COUNT(CASE WHEN publisher.publisher_name = 'Marvel Comics' THEN superhero.id ELSE NULL END), COUNT(CASE WHEN publisher.publisher_name = 'DC Comics' THEN superhero.id ELSE NULL END)) refer to publisher.publisher_name.\n#SQL-like: Show SUBTRACT(COUNT(CASE WHEN publisher.publisher_name = 'Marvel Comics' THEN superhero.id ELSE NULL END), COUNT(CASE WHEN publisher.publisher_name = 'DC Comics' THEN superhero.id ELSE NULL END)), WHERE publisher.publisher_name IN ('DC Comics', 'Marvel Comics')\n#SQL: SELECT COUNT(CASE WHEN T1.publisher_name = 'Marvel Comics' THEN T2.id ELSE NULL END) - COUNT(CASE WHEN T1.publisher_name = 'DC Comics' THEN T2.id ELSE NULL END) FROM publisher AS T1 INNER JOIN superhero AS T2 ON T1.id = T2.publisher_id\n```"
    ],
    "177": [
        "```\n#reason: The question wants to determine the sum of the account associated with client number 4 for transaction 851 and also to identify the gender of the account owner. Thus, the SQL SELECT will include the sum of the transaction amount for the specified account and the gender of the client.\n#columns: trans.amount, client.gender\n#values: client number 4 refers to client.client_id = 4, transaction 851 refers to trans.trans_id = 851\n#SELECT: SELECT SUM(trans.amount) refer to trans.amount, client.gender refer to client.gender\n#SQL-like: Show SUM(trans.amount), client.gender, WHERE client.client_id = 4 AND trans.trans_id = 851\n#SQL: SELECT SUM(trans.amount), client.gender FROM trans INNER JOIN disp ON trans.account_id = disp.account_id INNER JOIN client ON disp.client_id = client.client_id WHERE client.client_id = 4 AND trans.trans_id = 851\n```"
    ],
    "689": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to identify the display name and location of the user who was the last to edit the post with ID 183, so the SQL SELECT will retrieve the user's display name and location based on the maximum last edit date for the specified post ID.)\n#columns: users.DisplayName, users.Location\n#values: post ID 183 refers to posts.Id = 183\n#SELECT: SELECT users.DisplayName, users.Location refer to users.DisplayName, users.Location\n#SQL-like: Show users.DisplayName, users.Location WHERE posts.LastEditDate = (SELECT MAX(posts.LastEditDate) FROM posts WHERE posts.Id = 183)\n#SQL: SELECT T1.DisplayName, T1.Location FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.LastEditorUserId WHERE T2.Id = 183 AND T2.LastEditDate = (SELECT MAX(LastEditDate) FROM posts WHERE Id = 183)\n```"
    ],
    "577": [
        "```\n#reason: The question requires displaying all comments made by the user with the display name \"A Lion.\" \"A Lion\" is a filtering condition for the user's display name.\n#columns: comments.Text\n#values: 'A Lion' refer to comments.UserDisplayName = 'A Lion'\n#SELECT: SELECT comments (Text) refer to comments.Text\n#SQL-like: Show comments.Text, WHERE comments.UserDisplayName = 'A Lion'\n#SQL: SELECT Text FROM comments WHERE UserDisplayName = 'A Lion'\n```"
    ],
    "665": [
        "```\n#reason: The question wants to calculate the average monthly number of links created in 2010 for posts that have no more than 2 answers, so the SQL SELECT will count the Ids of links created in 2010 where the AnswerCount is less than or equal to 2 and divide that by 12.\n#columns: postLinks.Id, posts.AnswerCount, postLinks.CreationDate\n#values: 'in 2010' refers to \"strftime('%Y', postLinks.CreationDate) = '2010'\", 'no more than 2 answers' refers to posts.AnswerCount <= 2\n#SELECT: average monthly number of links created refer to DIVIDE(COUNT(postLinks.Id), 12)\n#SQL-like: Show DIVIDE(COUNT(postLinks.Id), 12), WHERE strftime('%Y', postLinks.CreationDate) = '2010' AND posts.AnswerCount <= 2\n#SQL: SELECT CAST(COUNT(T1.Id) AS REAL) / 12 FROM postLinks AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE strftime('%Y', T1.CreationDate) = '2010' AND T2.AnswerCount <= 2\n```"
    ],
    "227": [
        "```\n#reason: The question wants to calculate the percentage of molecules that are carcinogenic, so the SQL SELECT will count the number of carcinogenic molecules and divide it by the total number of molecules.\n#columns: molecule.label, molecule.molecule_id\n#values: label = '+' refer to molecule.label = '+'.\n#SELECT: percentage of molecules that are carcinogenic refer to DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent.\n#SQL-like: Show DIVIDE(SUM(label = '+'), COUNT(molecule_id)) as percent\n#SQL: SELECT CAST(SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(molecule_id) FROM molecule\n```"
    ],
    "555": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the average score of the posts owned by the user 'csgillespie', so the SQL SELECT AVG(Score) and includes filtering by the user's DisplayName.\n#columns: posts.Score, users.DisplayName, posts.OwnerUserId, users.Id\n#values: 'csgillespie' refer to users.DisplayName = 'csgillespie'\n#SELECT: average score refer to AVG(posts.Score)\n#SQL-like: Show AVG(posts.Score), WHERE users.DisplayName = 'csgillespie'\n#SQL: SELECT AVG(posts.Score) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie'\n```"
    ],
    "675": [
        "```\n#reason: The question wants to count the number of users whose reputations are higher than 2000 and the number of views is higher than 1000, so the SQL SELECT will count the users based on the specified conditions.\n#columns: users.Reputation, users.Views\n#values: reputations are higher than 2000 refer to users.Reputation > 2000, number of views is higher than 1000 refer to users.Views > 1000\n#SELECT: SELECT COUNT(*) refer to users.Id\n#SQL-like: Show COUNT(*), WHERE users.Reputation > 2000 AND users.Views > 1000\n#SQL: SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000\n```"
    ],
    "772": [
        "```\n#reason: The question wants to list the eyes, hair, and skin colour of all female superheroes published by Dark Horse Comics, so the SQL SELECT will include the eye_colour_id, hair_colour_id, and skin_colour_id from the superhero table, filtered by gender and publisher.\n#columns: superhero.eye_colour_id, superhero.hair_colour_id, superhero.skin_colour_id\n#values: female superheroes refer to gender.gender = 'Female', published by Dark Horse Comics refer to publisher.publisher_name = 'Dark Horse Comics'\n#SELECT: SELECT superhero.eye_colour_id, superhero.hair_colour_id, superhero.skin_colour_id\n#SQL-like: Show superhero.eye_colour_id, superhero.hair_colour_id, superhero.skin_colour_id, WHERE gender.gender = 'Female' AND publisher.publisher_name = 'Dark Horse Comics'\n#SQL: SELECT T1.eye_colour_id, T1.hair_colour_id, T1.skin_colour_id FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN publisher AS T3 ON T1.publisher_id = T3.id WHERE T2.gender = 'Female' AND T3.publisher_name = 'Dark Horse Comics'\n```"
    ],
    "474": [
        "```\n#reason: The question requires counting the number of sets of cards that have an Italian translation and a base set number of under 100. \"Italian translation\" refers to sets with translations in Italian, and \"base set number of under 100\" refers to baseSetSize being less than 100.\n#columns: sets.baseSetSize, set_translations.language\n#values: 'Italian translation' refers to set_translations.language = 'Italian', 'base set number of under 100' refers to sets.baseSetSize < 100\n#SELECT: COUNT(*)\n#SQL-like: Show COUNT(*), WHERE set_translations.language = 'Italian' AND sets.baseSetSize < 100\n#SQL: SELECT COUNT(*) FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Italian' AND T2.baseSetSize < 100\n```"
    ],
    "831": [
        "```\n#reason: The question requires display in order: \"Abomination's eye colour\". \"Abomination\" refers to the filtering condition and the eye colour refers to the colour column linked to eye_colour_id.\n#columns: colour.colour, superhero.eye_colour_id\n#values: 'Abomination' refer to superhero.superhero_name = 'Abomination'\n#SELECT: Abomination's eye colour refer to colour.colour\n#SQL-like: Show colour.colour, WHERE superhero.superhero_name = 'Abomination'\n#SQL: SELECT T2.colour FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.superhero_name = 'Abomination'\n```"
    ],
    "915": [
        "```\n#reason: The question wants to find the country of the oldest driver, so the SQL SELECT will retrieve the country name corresponding to the driver with the minimum date of birth.\n#columns: circuits.country, drivers.dob\n#values: oldest driver refers to MIN(drivers.dob)\n#SELECT: SELECT circuits.country refer to circuits.country\n#SQL-like: Show circuits.country, ORDER BY drivers.dob ASC LIMIT 1\n#SQL: SELECT T1.country FROM circuits AS T1 INNER JOIN drivers AS T2 ON T1.circuitId = T2.driverId ORDER BY T2.dob ASC LIMIT 1\n```"
    ],
    "1280": [
        "```\n#reason: The question wants to determine the number of male patients with their glutamic oxaloacetic transaminase in the normal range. \"Male\" refers to Sex = 'M' and \"glutamic oxaloacetic transaminase in the normal range\" refers to GOT < 60.\n#columns: Patient.ID, Patient.SEX, Laboratory.GOT\n#values: male refer to Patient.SEX = 'M', glutamic oxaloacetic transaminase in the normal range refer to Laboratory.GOT < 60\n#SELECT: How many male patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.SEX = 'M' AND Laboratory.GOT < 60\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.GOT < 60\n```"
    ],
    "850": [
        "```\n#reason: The question wants to display \"the name of the race\" held on the circuits in Germany, so the SQL SELECT will retrieve the race names from the races table where the corresponding circuit is located in Germany.\n#columns: races.name, circuits.country\n#values: 'Germany' refer to circuits.country = 'Germany'\n#SELECT: SELECT races.name refer to races.name\n#SQL-like: Show races.name WHERE circuits.country = 'Germany'\n#SQL: SELECT T1.name FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Germany'\n```"
    ],
    "1368": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the major of the person identified by the phone number \"809-555-3360\", so the SQL SELECT will retrieve the major_name from the major table by joining it with the member table using the member's ID.\n#columns: major.major_name, member.phone\n#values: 'phone number is 809-555-3360' refer to member.phone = '809-555-3360'\n#SELECT: SELECT major.major_name refer to major.major_name\n#SQL-like: Show major.major_name WHERE member.phone = '809-555-3360'\n#SQL: SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.phone = '809-555-3360'\n```"
    ],
    "1477": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the year with the highest total gas use where payments are made in EUR. This involves summing the gas use and grouping by year, filtered by the currency EUR.\n#columns: yearmonth.Date, yearmonth.Consumption\n#values: paid in EUR refers to customers.Currency = 'EUR'\n#SELECT: the year with the most gas use refers to strftime('%Y', yearmonth.Date)\n#SQL-like: Show strftime('%Y', yearmonth.Date), SUM(yearmonth.Consumption) WHERE customers.Currency = 'EUR' GROUP BY strftime('%Y', yearmonth.Date) ORDER BY SUM(yearmonth.Consumption) DESC LIMIT 1\n#SQL: SELECT strftime('%Y', T1.Date) FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'EUR' GROUP BY strftime('%Y', T1.Date) ORDER BY SUM(T1.Consumption) DESC LIMIT 1\n```"
    ],
    "628": [
        "```\n#reason: The question wants to identify the users with the highest number of views, so the SQL SELECT will group by DisplayName and order by the count of Views in descending order to find the maximum.\n#columns: users.DisplayName, users.Views\n#values: None\n#SELECT: SELECT users.DisplayName FROM users\n#SQL-like: Show users.DisplayName, ORDER BY Views DESC LIMIT 1\n#SQL: SELECT users.DisplayName FROM users ORDER BY users.Views DESC LIMIT 1\n```"
    ],
    "1493": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of customers who consumed more than 528.3 in February 2012, so the SQL SELECT counts the customers meeting the condition and divides it by the total count of customers in that month.\n#columns: yearmonth.CustomerID, yearmonth.Consumption\n#values: February 2012 refers to yearmonth.Date LIKE '201202%' and consumption > 528.3 refer to yearmonth.Consumption > 528.3\n#SELECT: SELECT CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID) refer to yearmonth.CustomerID\n#SQL-like: SQL-like statements ignoring Join conditions\n#SQL: SELECT CAST(SUM(CASE WHEN Consumption > 528.3 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(CustomerID) FROM yearmonth WHERE Date LIKE '201202%'\n```"
    ],
    "1454": [
        "```\n#reason: The question wants to calculate the percentage of the cost for meeting events, so the SQL SELECT will sum the cost of events where the type is 'Meeting' and divide it by the count of event IDs for those events, then multiply by 100.\n#columns: expense.cost, event.event_id\n#values: meeting events refer to event.type = 'Meeting'\n#SELECT: percentage of the cost for the meeting events refers to (SUM(expense.cost) / COUNT(event.event_id)) * 100\n#SQL-like: Show (SUM(expense.cost) / COUNT(event.event_id)) * 100, WHERE event.type = 'Meeting'\n#SQL: SELECT CAST(SUM(expense.cost) AS REAL) * 100 / COUNT(event.event_id) FROM expense INNER JOIN budget ON expense.link_to_budget = budget.budget_id INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.type = 'Meeting'\n```"
    ],
    "1093": [
        "```\n#reason: The question wants to calculate the average overall rating of players born before the year 1986, so the SQL SELECT computes the average overall rating by summing the overall ratings and dividing by the count of players born before that year.\n#columns: Player.birthday, Player.id, Player_Attributes.overall_rating\n#values: 'born before the year 1986' refer to strftime('%Y', Player.birthday) < '1986'\n#SELECT: SELECT average overall rating refer to AVG(overall_rating)\n#SQL-like: Show AVG(overall_rating), WHERE strftime('%Y', birthday) < '1986'\n#SQL: SELECT CAST(SUM(Player_Attributes.overall_rating) AS REAL) / COUNT(Player.id) FROM Player INNER JOIN Player_Attributes ON Player.player_api_id = Player_Attributes.player_api_id WHERE strftime('%Y', Player.birthday) < '1986'\n```"
    ],
    "919": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the circuit used for the 2009 Spanish Grand Prix, so the SQL SELECT will retrieve the circuit name based on the race year and name.\n#columns: circuits.name, races.name\n#values: '2009 Spanish Grand Prix' refers to races.name = 'Spanish Grand Prix' and races.year = 2009\n#SELECT: SELECT circuit name refer to circuits.name\n#SQL-like: Show circuits.name, WHERE races.name = 'Spanish Grand Prix' and races.year = 2009\n#SQL: SELECT T1.name FROM circuits AS T1 INNER JOIN races AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Spanish Grand Prix' AND T2.year = 2009\n```"
    ],
    "179": [
        "```\n#reason: The question wants to find the total amount paid by client number 617 for all transactions in the year 1998, so the SQL SELECT will sum the amounts from the transactions filtered by the specified client and year.\n#columns: trans.amount, trans.date, trans.account_id, disp.client_id\n#values: client number 617 refers to disp.client_id = 617 and in 1998 refers to strftime('%Y', trans.date) = '1998'\n#SELECT: total amount refers to SUM(trans.amount)\n#SQL-like: Show SUM(trans.amount), WHERE disp.client_id = 617 AND strftime('%Y', trans.date) = '1998'\n#SQL: SELECT SUM(T1.amount) FROM trans AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T2.client_id = 617 AND strftime('%Y', T1.date) = '1998'\n```"
    ],
    "873": [
        "```\n#reason: The question wants to display \"the actual finish time\" for \"Bruce McLaren\" in \"the race No.743\", so the SQL SELECT will retrieve the finish time from the results table while filtering for the specific driver and race ID.\n#columns: results.time\n#values: 'Bruce McLaren' refers to drivers.surname = 'McLaren' AND drivers.forename = 'Bruce', 'the race No.743' refers to results.raceId = 743\n#SELECT: SELECT results.time refer to results.time\n#SQL-like: Show results.time WHERE drivers.surname = 'McLaren' AND drivers.forename = 'Bruce' AND results.raceId = 743\n#SQL: SELECT T1.time FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T2.surname = 'McLaren' AND T2.forename = 'Bruce' AND T1.raceId = 743\n```"
    ],
    "28": [
        "```\n#reason: The question wants to list the names and DOC type of schools which have a difference above the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded. Therefore, the SQL will first calculate the average difference between `Enrollment (K-12)` and `Enrollment (Ages 5-17)` for locally funded schools, and then filter the schools that have a difference greater than this average.\n#columns: schools.School Name, schools.DOCType\n#values: locally funded schools refer to frpm.`Charter Funding Type` = 'Locally funded'\n#SELECT: names of schools refer to schools.School Name, DOC type refers to schools.DOCType\n#SQL-like: Show schools.School Name, schools.DOCType WHERE (Enrollment (K-12) - Enrollment (Ages 5-17)) > (SELECT AVG(`Enrollment (K-12)` - `Enrollment (Ages 5-17)`) FROM frpm WHERE `Charter Funding Type` = 'Locally funded')\n#SQL: SELECT T1.`School Name`, T1.DOCType FROM schools AS T1 INNER JOIN frpm AS T2 ON T1.CDSCode = T2.CDSCode WHERE (T2.`Enrollment (K-12)` - T2.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 WHERE T3.`Charter Funding Type` = 'Locally funded')\n```"
    ],
    "410": [
        "```\n#reason: The question wants to check if there is any card from the Erica Yang artist in pauper format and available in paper, so the SQL SELECT will look for cards with the specified conditions.\n#columns: cards.id\n#values: 'available in paper' refer to cards.availability = 'paper', 'pauper format' refer to legalities.format = 'pauper', 'artist is Erica Yang' refer to cards.artist = 'Erica Yang'\n#SELECT: SELECT cards.id refer to cards.id\n#SQL-like: Show cards.id WHERE cards.availability = 'paper' AND legalities.format = 'pauper' AND cards.artist = 'Erica Yang'\n#SQL: SELECT cards.id FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.availability = 'paper' AND legalities.format = 'pauper' AND cards.artist = 'Erica Yang'\n```"
    ],
    "327": [
        "```\n#reason: The question wants to identify non-carcinogenic molecules that consist of more than 5 atoms, so the SQL SELECT will count the number of atoms grouped by molecule and filter for non-carcinogenic labels.\n#columns: molecule.molecule_id, atom.atom_id\n#values: label = '-' refers to molecule.label = '-' and more than 5 atoms refers to COUNT(atom.atom_id) > 5\n#SELECT: SELECT molecule.molecule_id, COUNT(atom.atom_id) \n#SQL-like: Show molecule.molecule_id, COUNT(atom.atom_id), WHERE molecule.label = '-' GROUP BY molecule.molecule_id HAVING COUNT(atom.atom_id) > 5\n#SQL: SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5\n```"
    ],
    "1497": [
        "```\n#reason: The question wants to identify the SME customer with the least consumption in June 2012, so the SQL SELECT will focus on filtering for SME customers and finding the minimum consumption for the specified date.\n#columns: yearmonth.CustomerID, yearmonth.Consumption\n#values: 'June 2012' refers to yearmonth.Date = '201206'\n#SELECT: SELECT CustomerID, Consumption refer to yearmonth.CustomerID, yearmonth.Consumption\n#SQL-like: Show yearmonth.CustomerID, yearmonth.Consumption WHERE yearmonth.Date = '201206' ORDER BY yearmonth.Consumption ASC LIMIT 1\n#SQL: SELECT CustomerID, Consumption FROM yearmonth WHERE Date = '201206' ORDER BY Consumption ASC LIMIT 1\n```"
    ],
    "1425": [
        "```\n#reason: The question wants to count the number of majors under a specific department in the College of Agriculture and Applied Sciences, so the SQL SELECT will focus on counting the majors filtered by college and department conditions.\n#columns: major.major_id, major.college, major.department\n#values: 'College of Agriculture and Applied Sciences' refer to major.college = 'College of Agriculture and Applied Sciences', 'School of Applied Sciences, Technology and Education' refer to major.department = 'School of Applied Sciences, Technology and Education'\n#SELECT: SELECT COUNT(major.major_id) \n#SQL-like: Show COUNT(major.major_id), WHERE major.college = 'College of Agriculture and Applied Sciences' AND major.department = 'School of Applied Sciences, Technology and Education'\n#SQL: SELECT COUNT(major.major_id) FROM major WHERE major.college = 'College of Agriculture and Applied Sciences' AND major.department = 'School of Applied Sciences, Technology and Education'\n```"
    ],
    "895": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the average lap time for Lewis Hamilton in the 2009 Malaysian Grand Prix, so the SQL SELECT will include AVG(milliseconds) and will filter by the driver's full name and the race name.\n#columns: lapTimes.milliseconds, drivers.forename, drivers.surname, races.name\n#values: 'Lewis Hamilton' refer to CONCAT(drivers.forename, ' ', drivers.surname) = 'Lewis Hamilton', 'Malaysian Grand Prix' refer to races.name = 'Malaysian Grand Prix'\n#SELECT: SELECT AVG(lapTimes.milliseconds) refer to lapTimes.milliseconds\n#SQL-like: Show AVG(lapTimes.milliseconds), WHERE CONCAT(drivers.forename, ' ', drivers.surname) = 'Lewis Hamilton' AND races.name = 'Malaysian Grand Prix'\n#SQL: SELECT AVG(T1.milliseconds) FROM lapTimes AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE CONCAT(T2.forename, ' ', T2.surname) = 'Lewis Hamilton' AND T3.name = 'Malaysian Grand Prix'\n```"
    ],
    "890": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of seasons that Silverstone Circuit has hosted the British Grand Prix, so the SQL SELECT will count the distinct seasons where the circuit and race match the specified conditions.\n#columns: COUNT(DISTINCT seasons.year), circuits.circuitId, races.name\n#values: 'Silverstone Circuit' refer to circuits.name = 'Silverstone Circuit', 'British Grand Prix' refer to races.name = 'British Grand Prix'\n#SELECT: COUNT(DISTINCT seasons.year) refer to COUNT(DISTINCT seasons.year)\n#SQL-like: Show COUNT(DISTINCT seasons.year) WHERE circuits.name = 'Silverstone Circuit' AND races.name = 'British Grand Prix'\n#SQL: SELECT COUNT(DISTINCT T3.year) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId INNER JOIN seasons AS T3 ON T1.year = T3.year WHERE T2.name = 'Silverstone Circuit' AND T1.name = 'British Grand Prix'\n```"
    ],
    "992": [
        "```\n#reason: The question wants to display the \"full name\", \"Wiki Pedia page link\", and \"date of birth\" of German drivers born between 1971 and 1985, so the SQL SELECT will include the concatenation of forname and surname for the full name, the url for the Wiki Pedia page link, and dob for the date of birth, with filtering conditions for nationality and date of birth.\n#columns: drivers.forename, drivers.surname, drivers.url, drivers.dob\n#values: Nationality refers to drivers.nationality = 'German'; year(dob) BETWEEN '1971' AND '1985' refers to strftime('%Y', drivers.dob) BETWEEN '1971' AND '1985'\n#SELECT: full name refers to drivers.forename || ' ' || drivers.surname, Wiki Pedia page link refers to drivers.url, date of birth refers to drivers.dob\n#SQL-like: Show drivers.forename || ' ' || drivers.surname, drivers.url, drivers.dob WHERE drivers.nationality = 'German' AND strftime('%Y', drivers.dob) BETWEEN '1971' AND '1985' ORDER BY drivers.dob DESC\n#SQL: SELECT drivers.forename || ' ' || drivers.surname, drivers.url, drivers.dob FROM drivers WHERE drivers.nationality = 'German' AND strftime('%Y', drivers.dob) BETWEEN '1971' AND '1985' ORDER BY drivers.dob DESC\n```"
    ],
    "633": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the post by 'slashnick' that has the most answers count, so the SQL SELECT will retrieve the post ID where the DisplayName is 'slashnick' and the AnswerCount is maximized.\n#columns: posts.Id, posts.AnswerCount, users.DisplayName\n#values: DisplayName = 'slashnick' refer to users.DisplayName = 'slashnick'\n#SELECT: SELECT posts.Id refer to posts.Id\n#SQL-like: Show posts.Id, where users.DisplayName = 'slashnick', ORDER BY posts.AnswerCount DESC LIMIT 1\n#SQL: SELECT posts.Id FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'slashnick' ORDER BY posts.AnswerCount DESC LIMIT 1\n```"
    ],
    "1122": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the name of the most strongest player, so the SQL SELECT will retrieve the player's name with the maximum overall_rating.\n#columns: Player.player_name, Player_Attributes.overall_rating\n#values: 'the most strongest player' refers to 'overall_rating = MAX(overall_rating)'\n#SELECT: SELECT name of the most strongest player refer to Player.player_name\n#SQL-like: Show Player.player_name, ORDER BY Player_Attributes.overall_rating DESC LIMIT 1\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id ORDER BY T2.overall_rating DESC LIMIT 1\n```"
    ],
    "561": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question wants to find the title of the post which got the highest score comment, so the SQL SELECT will include the post title and filter by the maximum comment score)\n#columns: posts.Title, comments.Score\n#values: highest score comment refers to comments.Score = (SELECT MAX(Score) FROM comments)\n#SELECT: SELECT posts.Title refer to posts.Title\n#SQL-like: Show posts.Title WHERE comments.Score = (SELECT MAX(Score) FROM comments)\n#SQL: SELECT posts.Title FROM posts INNER JOIN comments ON comments.PostId = posts.Id WHERE comments.Score = (SELECT MAX(Score) FROM comments)\n```"
    ],
    "350": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the alternative languages available for the card named Annul with the number 29, so the SQL SELECT will target the foreign_data.language column while filtering by the card's name and number.\n#columns: foreign_data.language, cards.name, cards.number\n#values: name = 'Annul' refers to cards.name = 'Annul', numbered 29 refers to cards.number = '29b'\n#SELECT: State the alternative languages available for card named Annul numbered 29 refers to foreign_data.language\n#SQL-like: Show foreign_data.language, WHERE cards.name = 'Annul' AND cards.number = '29b'\n#SQL: SELECT T1.language FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.name = 'Annul' AND T2.number = '29b'\n```"
    ],
    "435": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of card borders with black color and list out the card id. \"border with black color\" refers to borderColor = 'black'.\n#columns: cards.id, cards.borderColor\n#values: border with black color refers to cards.borderColor = 'black'\n#SELECT: How many card borders refer to COUNT(cards.id), and list out the card id refer to cards.id.\n#SQL-like: Show COUNT(cards.id), cards.id WHERE cards.borderColor = 'black'\n#SQL: SELECT COUNT(id), id FROM cards WHERE borderColor = 'black'\n```"
    ],
    "552": [
        "```\n#reason: The question wants to list the names of the badges obtained by the user with the display name \"csgillespie\", so the SQL SELECT will retrieve the badge names associated with the user ID of \"csgillespie\".\n#columns: badges.Name\n#values: 'csgillespie' refers to users.DisplayName = 'csgillespie'\n#SELECT: SELECT badges.Name refer to badges.Name\n#SQL-like: Show badges.Name WHERE users.DisplayName = 'csgillespie'\n#SQL: SELECT T1.Name FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'\n```"
    ],
    "1307": [
        "```\n#reason: The question wants to list the patient's ID if he or she has an abnormal level of red blood cell and is followed at the outpatient clinic, so the SQL SELECT will include the patient ID where the RBC is outside the normal range and the Admission status is '-' for outpatient clinic.\n#columns: Patient.ID, Laboratory.RBC, Patient.Admission\n#values: abnormal level of red blood cell refers to Laboratory.RBC <= 3.5 or Laboratory.RBC >= 6.0; followed at the outpatient clinic refers to Patient.Admission = '-'\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID WHERE Laboratory.RBC <= 3.5 OR Laboratory.RBC >= 6.0 AND Patient.Admission = '-'\n#SQL: SELECT DISTINCT Patient.ID FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.RBC <= 3.5 OR Laboratory.RBC >= 6.0 AND Patient.Admission = '-'\n```"
    ],
    "1157": [
        "```\n#reason: The question wants to list the ID, sex, and disease of patients with a severe degree of thrombosis, so the SQL SELECT will include the relevant columns and filter for severe thrombosis.\n#columns: Patient.ID, Patient.SEX, Patient.Diagnosis\n#values: severe degree of thrombosis refers to Examination.Thrombosis = 2\n#SELECT: SELECT Patient.ID, Patient.SEX, Patient.Diagnosis\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Diagnosis WHERE Examination.Thrombosis = 2\n#SQL: SELECT T1.ID, T1.SEX, T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Thrombosis = 2\n```"
    ],
    "312": [
        "```\n#reason: The question wants to identify the carcinogenic label for a specific bond, so the SQL SELECT will retrieve the label for the bond based on the provided bond ID.\n#columns: molecule.label\n#values: bond ID 'TR001_2_4' refers to bond.bond_id = 'TR001_2_4'\n#SELECT: SELECT the carcinogenic label refer to molecule.label\n#SQL-like: Show molecule.label WHERE bond.bond_id = 'TR001_2_4'\n#SQL: SELECT T1.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_id = 'TR001_2_4'\n```"
    ],
    "1386": [
        "```\n#reason: The question wants to find the total expense for the event named 'Yearly Kickoff', so the SQL SELECT will sum the costs associated with that event.\n#columns: expense.cost\n#values: 'Yearly Kickoff' refer to event.event_name = 'Yearly Kickoff'\n#SELECT: total expense refer to SUM(expense.cost)\n#SQL-like: Show SUM(expense.cost), WHERE event.event_name = 'Yearly Kickoff'\n#SQL: SELECT SUM(T1.cost) FROM expense AS T1 INNER JOIN budget AS T2 ON T1.link_to_budget = T2.budget_id INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'Yearly Kickoff'\n```"
    ],
    "172": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of dispositions of type 'OWNER' and 'DISPONENT' for accounts ranging from 1 to 10, so the SQL SELECT will count the occurrences of each type and filter by account number.\n#columns: disp.type, disp.account_id\n#values: account number 1 to account number 10 refer to disp.account_id BETWEEN 1 AND 10\n#SELECT: SELECT COUNT(*) for OWNER and COUNT(*) for DISPONENT refer to disp.type\n#SQL-like: Show COUNT(*) WHERE disp.type = 'OWNER' AND disp.account_id BETWEEN 1 AND 10; Show COUNT(*) WHERE disp.type = 'DISPONENT' AND disp.account_id BETWEEN 1 AND 10\n#SQL: SELECT disp.type, COUNT(*) FROM disp WHERE disp.account_id BETWEEN 1 AND 10 GROUP BY disp.type\n```"
    ],
    "241": [
        "```\n#reason: The question wants to know how many molecules are not carcinogenic, so the SQL SELECT will use COUNT(molecule.molecule_id) and filter where molecule.label = '-'.\n#columns: molecule.molecule_id, molecule.label\n#values: not carcinogenic refers to molecule.label = '-'\n#SELECT: SELECT COUNT(molecule.molecule_id) refer to molecule.label = '-'.\n#SQL-like: Show COUNT(molecule.molecule_id), WHERE molecule.label = '-'\n#SQL: SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '-'\n```"
    ],
    "568": [
        "```\n#reason: The question wants to display the \"display name of the user\" who made the vote with Id 6347, so the SQL SELECT will join the votes and users tables to filter by the vote Id.\n#columns: users.DisplayName, votes.Id\n#values: vote no. 6347 refers to votes.Id = 6347\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName WHERE votes.Id = 6347\n#SQL: SELECT T1.DisplayName FROM users AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.UserId WHERE T2.Id = 6347\n```"
    ],
    "1070": [
        "```\n#reason: The question wants to identify the country associated with the league 'Italy Serie A', so the SQL SELECT will retrieve the country name by joining the League and Country tables based on the country_id.\n#columns: Country.name, League.name\n#values: 'Italy Serie A' refers to League.name = 'Italy Serie A'\n#SELECT: SELECT Country.name refer to Country.name\n#SQL-like: Show Country.name WHERE League.name = 'Italy Serie A'\n#SQL: SELECT T1.name FROM Country AS T1 INNER JOIN League AS T2 ON T1.id = T2.country_id WHERE T2.name = 'Italy Serie A'\n```"
    ],
    "687": [
        "```\n#reason: The question wants to find out the number of comments for the post with the highest score, so the SQL SELECT will count the comments where the post's score equals the maximum score from the posts table.\n#columns: posts.Score, posts.Id, comments.PostId, comments.Id\n#values: highest score refers to Score = (SELECT MAX(Score) FROM posts)\n#SELECT: How many comments refer to COUNT(comments.Id)\n#SQL-like: Show COUNT(comments.Id) WHERE comments.PostId = (SELECT Id FROM posts WHERE Score = (SELECT MAX(Score) FROM posts))\n#SQL: SELECT COUNT(comments.Id) FROM comments WHERE comments.PostId = (SELECT Id FROM posts WHERE Score = (SELECT MAX(Score) FROM posts))\n```"
    ],
    "809": [
        "```\n#reason: The question wants to display \"the publisher name\" for a specific \"superhero ID 38\". The \"superhero ID 38\" denotes a filtering condition where superhero.id = 38.\n#columns: superhero.publisher_id, publisher.publisher_name\n#values: superhero ID 38 refer to superhero.id = 38\n#SELECT: publisher name refer to publisher.publisher_name\n#SQL-like: Show publisher.publisher_name, WHERE superhero.id = 38\n#SQL: SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.id = 38\n```"
    ],
    "1273": [
        "```\n#reason: The question wants to count the number of distinct patients who have a normal anti-SSB and are diagnosed with SLE in the examination. So the SQL SELECT will count distinct Patient.ID where SSB is either '-' or '+-' and the Diagnosis is 'SLE'.\n#columns: Patient.ID, Laboratory.SSB, Examination.Diagnosis\n#values: normal anti-SSB refers to Laboratory.SSB IN('-', '+-') which translates to Laboratory.SSB IN('negative', '0'), diagnosed with SLE refers to Examination.Diagnosis = 'SLE'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.SSB IN('-', '+-') AND Examination.Diagnosis = 'SLE'\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.SSB IN('negative', '0') AND T2.Diagnosis = 'SLE'\n```"
    ],
    "521": [
        "```\n#reason: The question wants to find the status of a card illustrated by D. Alexander Gregory in legacy play format with sensitive content among those whose frame style version is 1997, so the SQL SELECT will include the status of the card and apply the necessary filters.\n#columns: legalities.status, cards.artist, cards.frameVersion, legalities.format, cards.hasContentWarning\n#values: 'version of frame style is 1997' refer to cards.frameVersion = '1997', 'illustrated by D. Alexander Gregory' refer to cards.artist = 'D. Alexander Gregory', 'sensitive content' refer to cards.hasContentWarning = 1, 'legacy play format' refer to legalities.format = 'legacy'\n#SELECT: SELECT legalities.status\n#SQL-like: Show legalities.status, WHERE cards.frameVersion = '1997' AND cards.artist = 'D. Alexander Gregory' AND cards.hasContentWarning = 1 AND legalities.format = 'legacy'\n#SQL: SELECT T1.status FROM legalities AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.frameVersion = '1997' AND T2.artist = 'D. Alexander Gregory' AND T2.hasContentWarning = 1 AND T1.format = 'legacy'\n```"
    ],
    "1038": [
        "```\n#reason: The question wants to list the top 5 leagues in ascending order of the number of goals made in all seasons combined, so the SQL SELECT will sum the home and away team goals, group by league, and then order the results by the total goals while limiting the output to the top 5.\n#columns: League.id, League.name, Match.home_team_goal, Match.away_team_goal\n#values: None\n#SELECT: SELECT League.id, League.name, SUM(Match.home_team_goal + Match.away_team_goal) refer to SUM(Match.home_team_goal + Match.away_team_goal)\n#SQL-like: Show League.id, League.name, SUM(Match.home_team_goal + Match.away_team_goal), GROUP BY League.id ORDER BY SUM(Match.home_team_goal + Match.away_team_goal) ASC LIMIT 5\n#SQL: SELECT League.id, League.name, SUM(Match.home_team_goal + Match.away_team_goal) FROM League INNER JOIN Match ON League.id = Match.league_id GROUP BY League.id, League.name ORDER BY SUM(Match.home_team_goal + Match.away_team_goal) ASC LIMIT 5\n```"
    ],
    "1395": [
        "```\n#reason: The question wants to know how many members attended a specific event in a specific year, so the SQL SELECT will count the distinct members linked to the event based on the specified conditions.\n#columns: attendance.link_to_member, event.event_date, event.event_name\n#values: event 'Community Theater' refer to event.event_name = 'Community Theater' and in 2019 refer to strftime('%Y', event.event_date) = '2019'\n#SELECT: SELECT COUNT(DISTINCT attendance.link_to_member) refer to COUNT(DISTINCT attendance.link_to_member)\n#SQL-like: Show COUNT(DISTINCT attendance.link_to_member), WHERE event.event_name = 'Community Theater' AND strftime('%Y', event.event_date) = '2019'\n#SQL: SELECT COUNT(DISTINCT attendance.link_to_member) FROM attendance INNER JOIN event ON attendance.link_to_event = event.event_id WHERE event.event_name = 'Community Theater' AND strftime('%Y', event.event_date) = '2019'\n```"
    ],
    "583": [
        "```\n#reason: The question wants to calculate the total score of the posts edited by a specific user and include the user's website URL. \"Yevgeny\" is the filtering condition for the user's display name, and \"edited\" refers to the LastEditorUserId in the posts table.\n#columns: posts.Score, users.WebsiteUrl\n#values: 'Yevgeny' refers to users.DisplayName = 'Yevgeny'\n#SELECT: SELECT SUM(posts.Score) refer to SUM(posts.Score), users.WebsiteUrl refer to users.WebsiteUrl\n#SQL-like: Show SUM(posts.Score), users.WebsiteUrl, WHERE users.DisplayName = 'Yevgeny'\n#SQL: SELECT SUM(T1.Score), T2.WebsiteUrl FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T2.DisplayName = 'Yevgeny'\n```"
    ],
    "737": [
        "```\n#reason: The question wants to display the race of \"Copycat\", so the SQL SELECT will query the race based on the superhero's name.\n#columns: superhero.race_id, race.race\n#values: Copycat refer to superhero.superhero_name = 'Copycat'\n#SELECT: SELECT race.race refer to race.race\n#SQL-like: Show race.race WHERE superhero.superhero_name = 'Copycat'\n#SQL: SELECT T2.race FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T1.superhero_name = 'Copycat'\n```"
    ],
    "208": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the most numerous type of label among atoms with hydrogen, so the SQL SELECT will count the labels for these atoms and group them.\n#columns: molecule.label\n#values: label type most numerous in atoms refers to element = 'h' in atom table\n#SELECT: SELECT label refer to molecule.label\n#SQL-like: Show label FROM molecule INNER JOIN atom ON molecule.molecule_id = atom.molecule_id WHERE atom.element = 'h' GROUP BY molecule.label ORDER BY COUNT(molecule.label) DESC LIMIT 1\n#SQL: SELECT molecule.label FROM molecule INNER JOIN atom ON molecule.molecule_id = atom.molecule_id WHERE atom.element = 'h' GROUP BY molecule.label ORDER BY COUNT(molecule.label) DESC LIMIT 1\n```"
    ],
    "78": [
        "```\n#reason: The question wants to find out the most common type of grade span served in the city of Adelanto, so the SQL SELECT will count the occurrences of grade span types and group them by the type, then order by the count in descending order to find the most common one.\n#columns: schools.GSserved\n#values: city of Adelanto refer to schools.City = 'Adelanto'\n#SELECT: most common type of grade span refer to schools.GSserved\n#SQL-like: Show schools.GSserved, WHERE schools.City = 'Adelanto', GROUP BY schools.GSserved, ORDER BY COUNT(schools.GSserved) DESC LIMIT 1\n#SQL: SELECT GSserved FROM schools WHERE City = 'Adelanto' GROUP BY GSserved ORDER BY COUNT(GSserved) DESC LIMIT 1\n```"
    ],
    "104": [
        "```\n#reason: The question wants to find out when the account was opened based on the transaction amount and date. The SQL SELECT will retrieve the account creation date based on the transaction date and amount.\n#columns: account.date, trans.amount, trans.date\n#values: 'transaction of 840 USD' refers to trans.amount = 840, 'happened in 1998/10/14' refers to trans.date = '1998-10-14'\n#SELECT: SELECT account.date refer to account.date\n#SQL-like: Show account.date, WHERE trans.amount = 840 AND trans.date = '1998-10-14'\n#SQL: SELECT T1.date FROM account AS T1 INNER JOIN trans AS T2 ON T1.account_id = T2.account_id WHERE T2.amount = 840 AND T2.date = '1998-10-14'\n```"
    ],
    "678": [
        "```\n#reason: The question wants to identify the post by Harvey Motulsky with the most views, so the SQL SELECT will retrieve the id and title of the post with the maximum view count for that user.\n#columns: posts.Id, posts.Title\n#values: DisplayName = 'Harvey Motulsky' refer to users.DisplayName = 'Harvey Motulsky', the most views refer to MAX(ViewCount)\n#SELECT: SELECT posts.Id, posts.Title\n#SQL-like: Show posts.Id, posts.Title, WHERE users.DisplayName = 'Harvey Motulsky', ORDER BY posts.ViewCount DESC LIMIT 1\n#SQL: SELECT posts.Id, posts.Title FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Harvey Motulsky' ORDER BY posts.ViewCount DESC LIMIT 1\n```"
    ],
    "291": [
        "```\n#reason: The question wants to count the number of chemical compounds identified as carcinogenic, so the SQL SELECT COUNT(molecule.molecule_id) and the filtering condition is molecule.label = '+'.\n#columns: molecule.molecule_id, molecule.label\n#values: label = '+' refer to molecule.label = '+'\n#SELECT: SELECT COUNT(molecule.molecule_id) refer to molecule.molecule_id\n#SQL-like: Show COUNT(molecule.molecule_id), WHERE molecule.label = '+'\n#SQL: SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '+'\n```"
    ],
    "1152": [
        "```\n#reason: The question wants to calculate the ratio of outpatient to inpatient follow-up treatment among patients diagnosed with 'SLE'. Therefore, the SQL SELECT statement will count the IDs for inpatients and outpatients separately, filtering for the 'SLE' diagnosis. \n#columns: Patient.ID, Patient.Admission, Patient.Diagnosis\n#values: 'SLE' diagnosed patient refers to Patient.Diagnosis = 'SLE', inpatient refers to Patient.Admission = '+', outpatient refers to Patient.Admission = '-'\n#SELECT: ratio of outpatient to inpatient refers to DIVIDE(COUNT(ID) WHERE Patient.Diagnosis = 'SLE' AND Patient.Admission = '+', COUNT(ID) WHERE Patient.Diagnosis = 'SLE' AND Patient.Admission = '-')\n#SQL-like: Show DIVIDE(COUNT(ID WHERE Admission = '+'), COUNT(ID WHERE Admission = '-')), WHERE Diagnosis = 'SLE'\n#SQL: SELECT CAST(COUNT(CASE WHEN Admission = '+' THEN ID END) AS REAL) / COUNT(CASE WHEN Admission = '-' THEN ID END) FROM Patient WHERE Diagnosis = 'SLE'\n```"
    ],
    "223": [
        "```\n#reason: The question wants to display the atom IDs associated with the bond TR000_2_5, so the SQL SELECT will retrieve the atom IDs from the connected table where the bond_id matches the specified bond ID.\n#columns: connected.atom_id, connected.atom_id2\n#values: bond TR000_2_5 refers to connected.bond_id = 'TR000_2_5'\n#SELECT: SELECT connected.atom_id, connected.atom_id2\n#SQL-like: Show connected.atom_id, connected.atom_id2 WHERE connected.bond_id = 'TR000_2_5'\n#SQL: SELECT connected.atom_id, connected.atom_id2 FROM connected WHERE connected.bond_id = 'TR000_2_5'\n```"
    ],
    "971": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to find the reference name of the oldest German driver, so the SQL SELECT will include the driverRef and will filter on nationality and the minimum date of birth.)\n#columns: drivers.driverRef, drivers.dob\n#values: 'German' refers to drivers.nationality = 'German'\n#SELECT: SELECT drivers.driverRef refer to drivers.driverRef\n#SQL-like: Show drivers.driverRef WHERE drivers.nationality = 'German' ORDER BY drivers.dob ASC LIMIT 1\n#SQL: SELECT drivers.driverRef FROM drivers WHERE drivers.nationality = 'German' ORDER BY drivers.dob ASC LIMIT 1\n```"
    ],
    "156": [
        "```\n#reason: The question wants to find the owner of the account with the largest loan amount, so the SQL SELECT will retrieve the client's information associated with the maximum loan amount.\n#columns: client.FirstName, client.LastName, loan.amount\n#values: largest loan amount refers to MAX(loan.amount)\n#SELECT: SELECT client.FirstName, client.LastName refer to client.FirstName, client.LastName\n#SQL-like: Show client.FirstName, client.LastName, WHERE loan.amount = (SELECT MAX(amount) FROM loan)\n#SQL: SELECT T1.FirstName, T1.LastName FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN loan AS T3 ON T2.account_id = T3.account_id WHERE T3.amount = (SELECT MAX(amount) FROM loan)\n```"
    ],
    "1486": [
        "```\n#reason: The question wants to compare the total amount paid by SMEs using Czech koruna and euros, so the SQL SELECT must calculate the total for each currency and find the difference between them.\n#columns: transactions_1k.Amount, customers.Currency, customers.Segment\n#values: 'SMEs' refers to customers.Segment = 'SME'; 'in Czech koruna' refers to customers.Currency = 'CZK'; 'in euros' refers to customers.Currency = 'EUR'\n#SELECT: Total amount paid using Currency CZK and total amount paid using Currency EUR refers to SUM(transactions_1k.Amount) for both currencies.\n#SQL-like: Show SUM(transactions_1k.Amount) WHERE customers.Segment = 'SME' AND customers.Currency = 'CZK' minus SUM(transactions_1k.Amount) WHERE customers.Segment = 'SME' AND customers.Currency = 'EUR'\n#SQL: SELECT (SELECT SUM(T1.Amount) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'SME' AND T2.Currency = 'CZK') - (SELECT SUM(T1.Amount) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Segment = 'SME' AND T2.Currency = 'EUR') AS AmountDifference\n```"
    ],
    "1183": [
        "```\n#reason: The question wants to identify the original diagnosis of the patient diagnosed with SLE on a specific examination date, so the SQL SELECT will involve joining the examination data with patient data based on the patient's ID to find the original diagnosis when they first came to the hospital.\n#columns: Patient.Diagnosis, Examination.`Examination Date`, Patient.`First Date`\n#values: 'SLE' refers to Examination.Diagnosis = 'SLE', '1997-01-27' refers to Examination.`Examination Date` = '1997-01-27'\n#SELECT: SELECT Patient.Diagnosis refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis, WHERE Examination.Diagnosis = 'SLE' AND Examination.`Examination Date` = '1997-01-27'\n#SQL: SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'SLE' AND T2.`Examination Date` = '1997-01-27'\n```"
    ],
    "980": [
        "```\n#reason: The question wants to list the reference name of the drivers who passed the second qualifying lap during race no. 23, so the SQL SELECT will include driverRef, nationality, and dob with the condition that q2 is not null and raceId is 23.\n#columns: drivers.driverRef, drivers.nationality, drivers.dob, qualifying.q2, qualifying.raceId\n#values: passed the second qualifying lap refers to qualifying.q2 IS NOT NULL, race no. refers to qualifying.raceId = 23\n#SELECT: SELECT content refers to driverRef, nationality, dob refer to drivers.driverRef, drivers.nationality, drivers.dob\n#SQL-like: Show drivers.driverRef, drivers.nationality, drivers.dob WHERE qualifying.q2 IS NOT NULL AND qualifying.raceId = 23\n#SQL: SELECT T1.driverRef, T2.nationality, T2.dob FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.q2 IS NOT NULL AND T1.raceId = 23\n```"
    ],
    "298": [
        "```\n#reason: The question wants to calculate the percentage of molecules containing carcinogenic compounds that are made of hydrogen. The percentage is defined as DIVIDE(SUM(label = '+' AND element = 'h'), COUNT(molecule_id)) * 100.0, where 'hydrogen' refers to element = 'h' and 'carcinogenic' refers to label = '+'.\n#columns: molecule.label, atom.element, molecule.molecule_id\n#values: hydrogen refers to atom.element = 'h', carcinogenic refers to molecule.label = '+'\n#SELECT: percentage of molecules containing carcinogenic compounds that are hydrogen refers to DIVIDE(SUM(label = '+' AND element = 'h'), COUNT(molecule_id)) * 100.0\n#SQL-like: Show DIVIDE(SUM(label = '+' AND element = 'h'), COUNT(molecule_id)) * 100.0\n#SQL: SELECT CAST(SUM(CASE WHEN T1.label = '+' AND T2.element = 'h' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T1.molecule_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id\n```"
    ],
    "144": [
        "```\n#reason: The question wants to calculate the average amount of credit card withdrawals made by account holders in a specific month of the year 2021, so the SQL SELECT will compute the average of the transaction amounts where the operation is 'VYBER KARTOU' and the transaction date is in the year 2021.\n#columns: trans.amount, trans.date\n#values: year(trans.date) = '2021' refer to strftime('%Y', trans.date) = '2021', operation = 'VYBER KARTOU' refer to trans.operation = 'VYBER KARTOU'\n#SELECT: average amount refer to AVG(trans.amount)\n#SQL-like: Show AVG(trans.amount), WHERE strftime('%Y', trans.date) = '2021' AND trans.operation = 'VYBER KARTOU'\n#SQL: SELECT AVG(trans.amount) FROM trans WHERE strftime('%Y', trans.date) = '2021' AND trans.operation = 'VYBER KARTOU'\n```"
    ],
    "204": [
        "```\n#reason: The question wants to count the number of carcinogenic molecules among the first 100 molecules in number order, so the SQL SELECT COUNT(molecule.molecule_id) will be used to retrieve the count of molecules where the label indicates they are carcinogenic.\n#columns: molecule.molecule_id, molecule.label\n#values: 'carcinogenic' refers to molecule.label = '+', 'first 100 molecules' refers to molecule.molecule_id BETWEEN 'TR000' AND 'TR099'\n#SELECT: SELECT COUNT(molecule.molecule_id) refer to molecule.molecule_id\n#SQL-like: Show COUNT(molecule.molecule_id), WHERE molecule.label = '+' AND molecule.molecule_id BETWEEN 'TR000' AND 'TR099'\n#SQL: SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '+' AND molecule.molecule_id BETWEEN 'TR000' AND 'TR099'\n```"
    ],
    "200": [
        "```\n#reason: The question wants to find the \"triple-bonded molecules\" that are \"carcinogenic\", so the SQL SELECT will filter based on the bond type and the carcinogenic label.\n#columns: molecule.molecule_id, molecule.label, bond.bond_type\n#values: triple-bonded molecules refer to bond.bond_type = '#', carcinogenic refer to molecule.label = '+'\n#SELECT: SELECT molecule_id, label, bond_type refer to molecule.molecule_id, molecule.label, bond.bond_type\n#SQL-like: Show molecule.molecule_id, molecule.label, bond.bond_type WHERE bond.bond_type = '#' AND molecule.label = '+'\n#SQL: SELECT T1.molecule_id, T1.label, T2.bond_type FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '+'\n```"
    ],
    "351": [
        "```\n#reason: The question wants to display the names of all the cards that have an alternative language in Japanese, so the SQL SELECT will focus on filtering cards based on the foreign language being Japanese.\n#columns: cards.name, foreign_data.language\n#values: 'Japanese' refers to foreign_data.language = 'Japanese'\n#SELECT: SELECT cards.name refer to cards.name\n#SQL-like: Show cards.name, WHERE foreign_data.language = 'Japanese'\n#SQL: SELECT cards.name FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'Japanese'\n```"
    ],
    "1066": [
        "```\n#reason: The question wants to find the \"passing class\" for the team with the short name \"CLB\", so the SQL SELECT will focus on retrieving the buildUpPlayPassingClass from the Team_Attributes table where the team's short name matches \"CLB\".\n#columns: Team_Attributes.buildUpPlayPassingClass, Team.team_short_name\n#values: 'CLB' refer to Team.team_short_name = 'CLB'\n#SELECT: SELECT Team_Attributes.buildUpPlayPassingClass refer to Team_Attributes.buildUpPlayPassingClass\n#SQL-like: Show Team_Attributes.buildUpPlayPassingClass, WHERE Team.team_short_name = 'CLB'\n#SQL: SELECT T1.buildUpPlayPassingClass FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.team_short_name = 'CLB'\n```"
    ],
    "1155": [
        "```\n#reason: The question wants to list the patient ID, sex, and birthday of patients with LDH beyond the normal range, so the SQL SELECT will include these columns and filter based on the LDH value.\n#columns: Patient.ID, Patient.SEX, Patient.Birthday\n#values: LDH beyond normal range refers to Laboratory.LDH > 500\n#SELECT: SELECT Patient.ID, Patient.SEX, Patient.Birthday refer to Patient.ID, Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Birthday WHERE Laboratory.LDH > 500\n#SQL: SELECT T1.ID, T1.SEX, T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.LDH > 500\n```"
    ],
    "1349": [
        "```\n#reason: The question wants to provide the total number of the budget amount for the \"September Speaker\" event, so the SQL SELECT will sum the budget amount where the event name matches 'September Speaker'.\n#columns: budget.amount, event.event_name\n#values: 'September Speaker' refers to event.event_name = 'September Speaker'\n#SELECT: SELECT SUM(budget.amount) refer to budget.amount\n#SQL-like: Show SUM(budget.amount), WHERE event.event_name = 'September Speaker'\n#SQL: SELECT SUM(budget.amount) FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.event_name = 'September Speaker'\n```"
    ],
    "1251": [
        "```\n#reason: The question wants to determine the number of patients with an Ig G higher than the normal range, so the SQL SELECT COUNT(DISTINCT Patient.ID) and COUNT DISTINCT ensures unique patients are counted.\n#columns: Patient.ID, Laboratory.IGG\n#values: Ig G higher than normal refer to IGG >= 2000\n#SELECT: How many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.IGG >= 2000\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.IGG >= 2000\n```"
    ],
    "46": [
        "```\n#reason: The question wants to find the state special schools with the highest number of enrollees from grades 1 through 12, so the SQL SELECT will count the enrollment for schools classified as state special schools and group them accordingly.\n#columns: schools.School, frpm.`Enrollment (K-12)`\n#values: State Special Schools refers to schools.DOC = '31'\n#SELECT: SELECT schools.School, SUM(frpm.`Enrollment (K-12)`) refer to schools.School, SUM(frpm.`Enrollment (K-12)`)\n#SQL-like: Show schools.School, SUM(frpm.`Enrollment (K-12)`), WHERE schools.DOC = '31', GROUP BY schools.School, ORDER BY SUM(frpm.`Enrollment (K-12)`) DESC LIMIT 1\n#SQL: SELECT schools.School, SUM(frpm.`Enrollment (K-12)`) FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.DOC = '31' GROUP BY schools.School ORDER BY SUM(frpm.`Enrollment (K-12)`) DESC LIMIT 1\n```"
    ],
    "1473": [
        "```\n#reason: The question wants to calculate the average monthly consumption of customers in the SME segment for the year 2013, so the SQL SELECT will compute AVG(Consumption) divided by 12, filtering for the year 2013 and the SME segment.\n#columns: yearmonth.Consumption, customers.Segment\n#values: 'SME' refers to customers.Segment = 'SME', 'in 2013' refers to yearmonth.Date BETWEEN '201301' AND '201312'\n#SELECT: SELECT AVG(yearmonth.Consumption) / 12\n#SQL-like: Show AVG(yearmonth.Consumption) / 12, WHERE yearmonth.Date BETWEEN '201301' AND '201312' AND customers.Segment = 'SME'\n#SQL: SELECT CAST(AVG(T1.Consumption) AS REAL) / 12 FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Date BETWEEN '201301' AND '201312' AND T2.Segment = 'SME'\n```"
    ],
    "1483": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the total consumption for customer 6 between August and November 2013, so the SQL SELECT will sum the consumption values for that customer within the specified date range.\n#columns: yearmonth.Consumption\n#values: Between August and November 2013 refers to '201308' <= yearmonth.Date AND yearmonth.Date <= '201311' AND yearmonth.CustomerID = 6\n#SELECT: SELECT total consumption refer to SUM(Consumption)\n#SQL-like: Show SUM(Consumption), WHERE yearmonth.Date BETWEEN '201308' AND '201311' AND yearmonth.CustomerID = 6\n#SQL: SELECT SUM(Consumption) FROM yearmonth WHERE Date BETWEEN '201308' AND '201311' AND CustomerID = 6\n```"
    ],
    "763": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the attribute value of the superhero named Abomination, so the SQL SELECT will filter by the superhero's name and retrieve the corresponding attribute value.\n#columns: hero_attribute.attribute_value, superhero.superhero_name\n#values: Abomination refers to superhero.superhero_name = 'Abomination'\n#SELECT: attribute value refers to hero_attribute.attribute_value\n#SQL-like: Show hero_attribute.attribute_value WHERE superhero.superhero_name = 'Abomination'\n#SQL: SELECT T1.attribute_value FROM hero_attribute AS T1 INNER JOIN superhero AS T2 ON T1.hero_id = T2.id WHERE T2.superhero_name = 'Abomination'\n```"
    ],
    "1246": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the patients with an abnormal activated partial prothrombin time and no thrombosis, so the SQL SELECT will count distinct patient IDs where APTT is greater than 45 and Thrombosis equals 0.\n#columns: Laboratory.ID, Examination.Thrombosis\n#values: abnormal activated partial prothrom bin time refer to Laboratory.APTT > 45, does not have thrombosis refer to Examination.Thrombosis = 0\n#SELECT: SELECT COUNT(DISTINCT Laboratory.ID) refer to Laboratory.ID\n#SQL-like: Show COUNT(DISTINCT Laboratory.ID), WHERE Laboratory.APTT > 45 AND Examination.Thrombosis = 0\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T1.APTT > 45 AND T2.Thrombosis = 0\n```"
    ],
    "510": [
        "```\n#reason: The question wants to identify the illustrator of the card art with the highest cost of converted mana among cards that do not have multiple faces, so the SQL SELECT statement will involve filtering based on the side being NULL and obtaining the maximum converted mana cost.\n#columns: cards.artist, cards.convertedManaCost\n#values: side IS NULL refers to cards.side IS NULL; highest cost of converted mana refers to cards.convertedManaCost = (SELECT MAX(convertedManaCost) FROM cards WHERE side IS NULL)\n#SELECT: SELECT artist refer to cards.artist.\n#SQL-like: Show artist WHERE side IS NULL and convertedManaCost is MAX(convertedManaCost)\n#SQL: SELECT artist FROM cards WHERE side IS NULL AND convertedManaCost = (SELECT MAX(convertedManaCost) FROM cards WHERE side IS NULL)\n```"
    ],
    "909": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of European Grand Prix races hosted in Germany. Therefore, the SQL SELECT will count the races hosted in Germany and divide that by the total count of European Grand Prix races.\n#columns: races.name, circuits.country\n#values: 'European Grand Prix' refers to races.name = 'European Grand Prix', 'Germany' refers to circuits.country = 'Germany'\n#SELECT: percentage of the races refers to DIVIDE(COUNT(races WHERE circuits.country = 'Germany' AND races.name = 'European Grand Prix'), COUNT(races WHERE races.name = 'European Grand Prix')) * 100\n#SQL-like: Show DIVIDE(COUNT(races WHERE circuits.country = 'Germany' AND races.name = 'European Grand Prix'), COUNT(races WHERE races.name = 'European Grand Prix')) * 100\n#SQL: SELECT CAST(COUNT(CASE WHEN circuits.country = 'Germany' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(races.name) FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.name = 'European Grand Prix'\n```"
    ],
    "308": [
        "```\n#reason: The question wants to count the number of bonds created by bonding atoms with the chlorine element, so the SQL SELECT will count the bond IDs where the connected atoms include chlorine.\n#columns: bond.bond_id, atom.element\n#values: chlorine refers to atom.element = 'cl'\n#SELECT: SELECT COUNT(bond.bond_id) refer to bond.bond_id\n#SQL-like: Show COUNT(bond.bond_id) WHERE atom.element = 'cl'\n#SQL: SELECT COUNT(bond.bond_id) FROM bond INNER JOIN connected ON bond.bond_id = connected.bond_id INNER JOIN atom ON connected.atom_id = atom.atom_id WHERE atom.element = 'cl' OR connected.atom_id2 IN (SELECT atom_id FROM atom WHERE element = 'cl')\n```"
    ],
    "1042": [
        "```\n#reason: The question wants to list the leagues where the average goals by the home team are higher than those by the away team in the 2009/2010 season, so the SQL SELECT will calculate the average goals for both home and away teams and filter based on the condition.\n#columns: League.name\n#values: '2009/2010 season' refer to Match.season = '2009/2010'\n#SELECT: SELECT League.name refer to League.name\n#SQL-like: Show League.name, WHERE AVG(home_team_goal) > AVG(away_team_goal) AND Match.season = '2009/2010'\n#SQL: SELECT DISTINCT L.name FROM League AS L INNER JOIN Match AS M ON L.id = M.league_id WHERE M.season = '2009/2010' GROUP BY L.id HAVING AVG(M.home_team_goal) > AVG(M.away_team_goal)\n```"
    ],
    "1287": [
        "```\n#reason: The question wants to find the number of patients followed at the outpatient clinic who have a normal level of alkaliphophatase, so the SQL SELECT will count the distinct patients where the admission status and the ALP level conditions are met.\n#columns: Patient.Admission, Laboratory.ALP, Patient.ID\n#values: followed at the outpatient clinic refer to Patient.Admission = '-' and normal level of alkaliphophatase refer to Laboratory.ALP < 300\n#SELECT: how many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.Admission = '-' AND Laboratory.ALP < 300\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Admission = '-' AND T2.ALP < 300\n```"
    ],
    "1072": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the average overall rating of a specific football player, so the SQL SELECT will use AVG(overall_rating) with a filter for the player's name.\n#columns: Player_Attributes.overall_rating, Player.player_name\n#values: 'the football player Aaron Doran' refer to Player.player_name = 'Aaron Doran'\n#SELECT: average overall rating refer to AVG(overall_rating)\n#SQL-like: Show AVG(overall_rating) WHERE Player.player_name = 'Aaron Doran'\n#SQL: SELECT CAST(SUM(T1.overall_rating) AS REAL) / COUNT(T1.player_api_id) FROM Player_Attributes AS T1 INNER JOIN Player AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.player_name = 'Aaron Doran'\n```"
    ],
    "1324": [
        "```\n#reason: The question wants to determine the \"average attendance\" of meetings in the year 2020. The definition of average is calculated by dividing the count of events by the count of distinct event names, specifically filtering for meetings that occurred in 2020. Hence, the SQL SELECT will count the event IDs and distinct event names from the event table where the type is 'Meeting' and the year of the event date is 2020.\n#columns: event.event_id, event.event_name, event.event_date, event.type\n#values: meetings in 2020 refers to event.type = 'Meeting' AND strftime('%Y', event.event_date) = '2020'\n#SELECT: average = COUNT(event_id) / COUNT(DISTINCT event_name) refer to COUNT(event.event_id), COUNT(DISTINCT event.event_name)\n#SQL-like: Show COUNT(event.event_id) / COUNT(DISTINCT event.event_name), WHERE event.type = 'Meeting' AND strftime('%Y', event.event_date) = '2020'\n#SQL: SELECT CAST(COUNT(event_id) AS REAL) / COUNT(DISTINCT event_name) FROM event WHERE type = 'Meeting' AND strftime('%Y', event.event_date) = '2020'\n```"
    ],
    "1020": [
        "```\n#reason: The question requires identifying \"which player has the highest overall rating\" and indicating the player's api id. The highest overall rating is determined by MAX(overall_rating).\n#columns: Player.player_api_id, Player_Attributes.overall_rating\n#values: None\n#SELECT: the player api id with the highest overall rating refers to Player.player_api_id\n#SQL-like: Show Player.player_api_id, ORDER BY Player_Attributes.overall_rating DESC LIMIT 1\n#SQL: SELECT T1.player_api_id FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id ORDER BY T2.overall_rating DESC LIMIT 1\n```"
    ],
    "509": [
        "```\n#reason: The question want to find the unique id of the set that has the highest number of cards, so the SQL SELECT id from sets where baseSetSize = (SELECT MAX(baseSetSize) FROM sets).\n#columns: sets.id, sets.baseSetSize\n#values: the highest number of cards refer to MAX(baseSetSize) \n#SELECT: SELECT id refer to sets.id\n#SQL-like: Show sets.id WHERE sets.baseSetSize = (SELECT MAX(baseSetSize) FROM sets)\n#SQL: SELECT id FROM sets WHERE baseSetSize = (SELECT MAX(baseSetSize) FROM sets)\n```"
    ],
    "1397": [
        "```\n#reason: The question wants to calculate the average amount spent on food for closed events, so the SQL SELECT will compute the average by dividing the total spent on food by the count of food expenses for closed events.\n#columns: budget.amount, budget.category, budget.event_status, expense.spent\n#values: 'category is Food' refer to budget.category = 'Food', 'event in the past' refer to budget.event_status = 'Closed'\n#SELECT: SELECT CAST(SUM(expense.spent) AS REAL) / COUNT(expense.spent) refer to budget.amount\n#SQL-like: Show CAST(SUM(expense.spent) AS REAL) / COUNT(expense.spent), WHERE budget.category = 'Food' AND budget.event_status = 'Closed'\n#SQL: SELECT CAST(SUM(T2.spent) AS REAL) / COUNT(T2.spent) FROM budget AS T1 INNER JOIN expense AS T2 ON T1.budget_id = T2.link_to_budget WHERE T1.category = 'Food' AND T1.event_status = 'Closed'\n```"
    ],
    "362": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the description about the ruling of the card \"Condemn\", which is filtered by the card's name.\n#columns: rulings.text\n#values: 'Condemn' refers to cards.name = 'Condemn'\n#SELECT: SELECT description about the ruling refers to rulings.text\n#SQL-like: Show rulings.text, WHERE cards.name = 'Condemn'\n#SQL: SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'\n```"
    ],
    "877": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"who is the youngest\" among the drivers who finished the race, which refers to finding the driver with the maximum date of birth (DOB), and the filter indicates that these drivers finished the race with a specific raceId.\n#columns: drivers.dob, drivers.driverId\n#values: finished the race refers to results.time is not NULL and in race No. 872 refers to results.raceId = 872\n#SELECT: SELECT drivers.driverId refer to drivers.driverId\n#SQL-like: Show drivers.driverId WHERE results.time IS NOT NULL AND results.raceId = 872 ORDER BY drivers.dob DESC LIMIT 1\n#SQL: SELECT T1.driverId FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE T2.time IS NOT NULL AND T2.raceId = 872 ORDER BY T1.dob DESC LIMIT 1\n```"
    ],
    "1171": [
        "```\n#reason: The question wants to count the number of underage patients examined during a specific time period, so the SQL SELECT will count distinct patient IDs where the birthday indicates they are underage and the examination date falls within the specified years.\n#columns: Patient.ID, Examination.`Examination Date`, Patient.Birthday\n#values: underage patients refer to year(Patient.Birthday) > strftime('%Y', Examination.`Examination Date`) - 18, three-year period from 1990 to 1993 refers to year(Examination.`Examination Date`) BETWEEN '1990' AND '1993'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE year(Patient.Birthday) > strftime('%Y', Examination.`Examination Date`) - 18 AND year(Examination.`Examination Date`) BETWEEN '1990' AND '1993'\n#SQL: SELECT COUNT(DISTINCT Patient.ID) FROM Patient INNER JOIN Examination ON Patient.ID = Examination.ID WHERE year(Patient.Birthday) > strftime('%Y', Examination.`Examination Date`) - 18 AND year(Examination.`Examination Date`) BETWEEN '1990' AND '1993'\n```"
    ],
    "1320": [
        "```\n#reason: The question wants to display the event names of all the events attended by a specific member, Maya Mclean. This involves filtering the attendance records based on the member's name and joining with the event table to get the event names.\n#columns: event.event_name\n#values: 'Maya Mclean' refers to member.first_name = 'Maya' AND member.last_name = 'Mclean'\n#SELECT: SELECT event.event_name\n#SQL-like: Show event.event_name WHERE attendance.link_to_member = (SELECT member.member_id FROM member WHERE member.first_name = 'Maya' AND member.last_name = 'Mclean')\n#SQL: SELECT T1.event_name FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Maya' AND T3.last_name = 'Mclean'\n```"
    ],
    "697": [
        "```\n#reason: The question requires displaying the \"reputation\" and \"view count\" of the user with the display name 'Jarrod Dixon'. The filtering condition is based on the display name.\n#columns: users.Reputation, users.Views\n#values: 'Jarrod Dixon' refers to users.DisplayName = 'Jarrod Dixon'\n#SELECT: reputation and view count refer to users.Reputation, users.Views\n#SQL-like: Show users.Reputation, users.Views WHERE users.DisplayName = 'Jarrod Dixon'\n#SQL: SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon'\n```"
    ],
    "1207": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"patients with their sex and date of birthday\" along with the filtering condition \"GOT index is within normal range for laboratory examination in 1994\". This means we need to filter by GOT < 60 and the year of laboratory date being 1994.\n#columns: Patient.SEX, Patient.Birthday\n#values: GOT index is within normal range refer to Laboratory.GOT < 60, examination in 1994 refer to strftime('%Y', Laboratory.Date) = '1994'\n#SELECT: SELECT patients with their sex and date of birthday refer to Patient.SEX, Patient.Birthday\n#SQL-like: Show Patient.SEX, Patient.Birthday WHERE Laboratory.GOT < 60 AND strftime('%Y', Laboratory.Date) = '1994'\n#SQL: SELECT P.SEX, P.Birthday FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.GOT < 60 AND strftime('%Y', L.Date) = '1994'\n```"
    ],
    "184": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count female customers who have a junior credit card, so the SQL SELECT COUNT(client.client_id) and include the necessary filtering conditions.\n#columns: client.client_id, client.gender, card.type\n#values: female refers to client.gender = 'F', junior credit card refers to card.type = 'junior'\n#SELECT: SELECT COUNT(client.client_id) refer to COUNT(client.client_id)\n#SQL-like: Show COUNT(client.client_id), WHERE client.gender = 'F' AND card.type = 'junior'\n#SQL: SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN disp AS T2 ON T1.client_id = T2.client_id INNER JOIN account AS T3 ON T2.account_id = T3.account_id INNER JOIN card AS T4 ON T3.account_id = T4.account_id WHERE T1.gender = 'F' AND T4.type = 'junior'\n```"
    ],
    "1431": [
        "```\n#reason: The question wants to list the last name of the members of the club who attended the women's soccer event, so the SQL SELECT will filter based on the event name and the member's position.\n#columns: member.last_name, attendance.link_to_member, attendance.link_to_event, event.event_name\n#values: 'members of the club' refers to position = 'Member', 'Women's Soccer' refers to event.event_name = 'Women''s Soccer'\n#SELECT: SELECT member.last_name\n#SQL-like: Show member.last_name WHERE member.position = 'Member' AND event.event_name = 'Women''s Soccer'\n#SQL: SELECT T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T1.position = 'Member' AND T3.event_name = 'Women''s Soccer'\n```"
    ],
    "994": [
        "```\n#reason: The question wants to identify the constructor that scored the most points from the Monaco Grand Prix between 1980 and 2010, so the SQL SELECT will aggregate points and include the constructor's name and nationality.\n#columns: constructorResults.points, constructors.name, constructors.nationality\n#values: Monaco Grand Prix refers to races.name = 'Monaco Grand Prix' and races.year BETWEEN 1980 AND 2010\n#SELECT: SELECT MAX(constructorResults.points), constructors.name, constructors.nationality refer to constructorResults.points, constructors.name, constructors.nationality\n#SQL-like: Show MAX(constructorResults.points), constructors.name, constructors.nationality WHERE races.name = 'Monaco Grand Prix' AND races.year BETWEEN 1980 AND 2010 GROUP BY constructors.constructorId ORDER BY MAX(constructorResults.points) DESC LIMIT 1\n#SQL: SELECT MAX(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN races AS T3 ON T1.raceId = T3.raceId INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.constructorId ORDER BY MAX(T1.points) DESC LIMIT 1\n```"
    ],
    "143": [
        "```\n#reason: The question wants to display \"the accounts\" that have \"gold credit cards\", so the SQL SELECT will filter accounts based on the card type being 'gold'.\n#columns: account.account_id, card.type\n#values: 'gold credit cards' refer to card.type = 'gold'\n#SELECT: SELECT account.account_id refer to account.account_id\n#SQL-like: Show account.account_id, WHERE card.type = 'gold'\n#SQL: SELECT T1.account_id FROM account AS T1 INNER JOIN card AS T2 ON T1.account_id = T2.card_id WHERE T2.type = 'gold'\n```"
    ],
    "147": [
        "```\n#reason: The question wants to count the number of female clients' accounts in the region of South Bohemia, so the SQL SELECT COUNT(client.client_id) and INNER JOIN conditions will be used to filter by gender and region.\n#columns: client.client_id, district.A3\n#values: female refers to client.gender = 'F', region South Bohemia refers to district.A3 = 'south Bohemia'\n#SELECT: How many female clients' accounts refer to COUNT(client.client_id)\n#SQL-like: Show COUNT(client.client_id), WHERE client.gender = 'F' AND district.A3 = 'south Bohemia'\n#SQL: SELECT COUNT(T1.client_id) FROM client AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T1.gender = 'F' AND T2.A3 = 'south Bohemia'\n```"
    ],
    "295": [
        "```\n#reason: The question wants to count how many atoms belong to the molecule where the element is hydrogen and the molecule is labeled as carcinogenic. Therefore, the SQL SELECT will count the atoms based on the given filtering conditions for element and label.\n#columns: atom.atom_id\n#values: element is hydrogen refer to atom.element = 'h', label is carcinogenic refer to molecule.label = '+'\n#SELECT: SELECT COUNT(atom.atom_id) refer to atom.atom_id\n#SQL-like: Show COUNT(atom.atom_id), WHERE atom.element = 'h' AND molecule.label = '+'\n#SQL: SELECT COUNT(atom.atom_id) FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.element = 'h' AND molecule.label = '+'\n```"
    ],
    "1366": [
        "```\n#reason: The question wants to list all the members who attended the event \"October Meeting\", so the SQL SELECT will retrieve member details based on the attendance linked to the specific event name.\n#columns: member.first_name, member.last_name, attendance.link_to_member, attendance.link_to_event, event.event_name\n#values: 'October Meeting' refers to event.event_name = 'October Meeting'\n#SELECT: SELECT member.first_name, member.last_name refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name WHERE event.event_name = 'October Meeting'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN attendance AS T2 ON T1.member_id = T2.link_to_member INNER JOIN event AS T3 ON T2.link_to_event = T3.event_id WHERE T3.event_name = 'October Meeting'\n```"
    ],
    "462": [
        "```\n#reason: The question wants to display the Italian name of the set of cards that includes \"Ancestor's Chosen\", so the SQL SELECT will filter by the card name and the language.\n#columns: sets.name\n#values: 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen', 'Italian' refer to set_translations.language = 'Italian'\n#SELECT: Italian name of the set of cards refer to sets.name\n#SQL-like: Show sets.name, WHERE cards.name = 'Ancestor''s Chosen' AND set_translations.language = 'Italian'\n#SQL: SELECT T2.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'\n```"
    ],
    "220": [
        "```\n#reason: The question wants to list the top three elements of the toxicology of the molecule TR000 in alphabetical order, so the SQL SELECT will involve the elements of the atom table filtered by the molecule_id 'TR000'.\n#columns: atom.element\n#values: 'molecule TR000' refer to atom.molecule_id = 'TR000'\n#SELECT: SELECT top three elements refer to atom.element\n#SQL-like: Show atom.element WHERE atom.molecule_id = 'TR000' ORDER BY atom.element LIMIT 3\n#SQL: SELECT atom.element FROM atom WHERE atom.molecule_id = 'TR000' ORDER BY atom.element LIMIT 3\n```"
    ],
    "986": [
        "```\n#reason: The question wants to identify the race in which the fastest 1st lap time was recorded, so the SQL SELECT will retrieve the race and the time in milliseconds, filtering for the minimum lap time.\n#columns: races.name, lapTimes.milliseconds\n#values: fastest refers to MIN(lapTimes.time) which needs to be converted to milliseconds.\n#SELECT: SELECT races.name, lapTimes.milliseconds refer to races.name, lapTimes.milliseconds\n#SQL-like: Show races.name, lapTimes.milliseconds, ORDER BY lapTimes.milliseconds LIMIT 1\n#SQL: SELECT T1.name, T2.milliseconds FROM races AS T1 INNER JOIN lapTimes AS T2 ON T1.raceId = T2.raceId ORDER BY T2.milliseconds LIMIT 1\n```"
    ],
    "1370": [
        "```\n#reason: The question wants to list all the expenses incurred by the vice president, so the SQL SELECT will include the expense_description from the Expense table where the member's position is 'Vice President'.\n#columns: expense.expense_description\n#values: 'Vice President' refers to member.position = 'Vice President'\n#SELECT: SELECT expense_description refer to expense.expense_description\n#SQL-like: Show expense.expense_description, WHERE member.position = 'Vice President'\n#SQL: SELECT T1.expense_description FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T2.position = 'Vice President'\n```"
    ],
    "579": [
        "```\n#reason: The question wants to display all comments made on the post titled 'How does gentle boosting differ from AdaBoost?', so the SQL SELECT will retrieve the comments' text where the post title matches the specified title.\n#columns: comments.Text\n#values: 'How does gentle boosting differ from AdaBoost?' refer to posts.Title = 'How does gentle boosting differ from AdaBoost?'\n#SELECT: SELECT comments.Text refer to comments.Text\n#SQL-like: Show comments.Text WHERE posts.Title = 'How does gentle boosting differ from AdaBoost?'\n#SQL: SELECT T1.Text FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'How does gentle boosting differ from AdaBoost?'\n```"
    ],
    "1312": [
        "```\n#reason: The question wants to display \"Angela Sanders's major\". The full name \"Angela Sanders\" is the filtering condition, and \"major\" refers to major_name.\n#columns: major.major_name, member.first_name, member.last_name\n#values: 'Angela' refers to member.first_name = 'Angela', 'Sanders' refers to member.last_name = 'Sanders'\n#SELECT: SELECT major_name refer to major.major_name\n#SQL-like: Show major.major_name, WHERE member.first_name = 'Angela' AND member.last_name = 'Sanders'\n#SQL: SELECT T1.major_name FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.first_name = 'Angela' AND T2.last_name = 'Sanders'\n```"
    ],
    "591": [
        "```\n#reason: The question wants to find the number of users awarded with the \"Supporter\" badge during the year 2011, so the SQL SELECT will count the distinct UserId from the badges table where the badge name is \"Supporter\" and the date falls within the year 2011.\n#columns: badges.UserId, badges.Date\n#values: \"Supporter\" is the Name of badge refer to badges.Name = 'Supporter', \"in year 2011\" refer to strftime('%Y', badges.Date) = '2011'\n#SELECT: SELECT COUNT(DISTINCT UserId) refer to badges.UserId\n#SQL-like: Show COUNT(DISTINCT UserId), WHERE badges.Name = 'Supporter' AND strftime('%Y', badges.Date) = '2011'\n#SQL: SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Supporter' AND strftime('%Y', Date) = '2011'\n```"
    ],
    "719": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of superheroes with the super power of \"Super Strength\" and a height of over 200cm, so the SQL SELECT will count the superhero IDs that meet these conditions.\n#columns: superhero.id, superhero.height_cm, superpower.power_name\n#values: super power of \"Super Strength\" refers to superpower.power_name = 'Super Strength', a height of over 200cm refers to superhero.height_cm > 200\n#SELECT: COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE superpower.power_name = 'Super Strength' AND superhero.height_cm > 200\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200\n```"
    ],
    "1423": [
        "```\n#reason: The question wants to count the number of income records with an amount of 50, so the SQL SELECT will count the rows where the income amount equals 50.\n#columns: income.amount\n#values: amount of 50 refer to amount = 50\n#SELECT: SELECT COUNT(*) refer to income.amount\n#SQL-like: Show COUNT(*), WHERE amount = 50\n#SQL: SELECT COUNT(*) FROM income WHERE amount = 50\n```"
    ],
    "735": [
        "```\n#reason: The question wants to count how many superheroes have blonde hair, so the SQL SELECT statement will count the superheroes filtered by their hair color.\n#columns: superhero.hair_colour_id\n#values: 'blonde hair' refers to colour.colour = 'Blond'\n#SELECT: SELECT COUNT(superhero.hair_colour_id) refer to COUNT(superhero.hair_colour_id)\n#SQL-like: Show COUNT(superhero.hair_colour_id), WHERE colour.colour = 'Blond'\n#SQL: SELECT COUNT(T1.hair_colour_id) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.hair_colour_id = T2.id WHERE T2.colour = 'Blond'\n```"
    ],
    "134": [
        "```\n#reason: The question wants to find the number of accounts opened in the branch with the largest number of crimes committed in 1996, so the SQL SELECT will count the accounts and filter by the district with the maximum number of crimes in 1996.\n#columns: account.account_id, district.A16\n#values: largest number of crimes in 1996 refers to (SELECT MAX(A16) FROM district)\n#SELECT: SELECT COUNT(account.account_id) refer to account.account_id\n#SQL-like: Show COUNT(account.account_id), WHERE district_id = (SELECT district_id FROM district WHERE A16 = (SELECT MAX(A16) FROM district))\n#SQL: SELECT COUNT(account.account_id) FROM account WHERE district_id = (SELECT district_id FROM district WHERE A16 = (SELECT MAX(A16) FROM district))\n```"
    ],
    "411": [
        "```\n#reason: The question wants to find out which artist illustrated the card with a specific flavor text, so the SQL SELECT will extract the artist column from the cards table where the flavor text matches the given value.\n#columns: cards.artist\n#values: 'Das perfekte Gegenmittel zu einer dichten Formation' refer to cards.flavorText = 'Das perfekte Gegenmittel zu einer dichten Formation'\n#SELECT: SELECT artist refer to cards.artist\n#SQL-like: Show artist, WHERE cards.flavorText = 'Das perfekte Gegenmittel zu einer dichten Formation'\n#SQL: SELECT artist FROM cards WHERE flavorText = 'Das perfekte Gegenmittel zu einer dichten Formation'\n```"
    ],
    "1499": [
        "```\n#reason: The question wants to display \"the biggest monthly consumption\" of \"the customers\" who use euro as their currency. The biggest monthly consumption refers to MAX(SUM(consumption) / 12) and the filtering condition is customers.Currency = 'EUR'. \n#columns: yearmonth.Consumption, customers.Currency, yearmonth.CustomerID\n#values: 'use euro as their currency' refer to customers.Currency = 'EUR'\n#SELECT: SELECT MAX(SUM(consumption) / 12) refer to monthly consumption\n#SQL-like: Show MAX(SUM(consumption) / 12) WHERE customers.Currency = 'EUR'\n#SQL: SELECT MAX(CAST(SUM(yearmonth.Consumption) AS REAL) / 12) FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE customers.Currency = 'EUR'\n```"
    ],
    "849": [
        "```\n#reason: The question wants to find the introduction of the races held on Circuit de Barcelona-Catalunya, so the SQL SELECT will retrieve the url of the races where the circuit name matches 'Circuit de Barcelona-Catalunya'.\n#columns: races.url, circuits.name\n#values: 'Circuit de Barcelona-Catalunya' refer to circuits.name = 'Circuit de Barcelona-Catalunya'\n#SELECT: SELECT races.url refer to races.url\n#SQL-like: Show races.url WHERE circuits.name = 'Circuit de Barcelona-Catalunya'\n#SQL: SELECT T1.url FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Circuit de Barcelona-Catalunya'\n```"
    ],
    "1142": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the number of games played in the Italian Serie A league during the 2015–2016 season, so the SQL SELECT will count the matches where the season is '2015/2016'.\n#columns: Match.season, Match.id\n#values: 'in the 2015–2016 season' refers to Match.season = '2015/2016'\n#SELECT: 'how many games' refers to COUNT(Match.id)\n#SQL-like: Show COUNT(Match.id), WHERE Match.season = '2015/2016'\n#SQL: SELECT COUNT(id) FROM Match WHERE season = '2015/2016'\n```"
    ],
    "303": [
        "```\n#reason: The question wants to count the number of double bonds for the molecule TR006 and check if it is carcinogenic, so the SQL SELECT will count the bonds where bond_type is '=' and filter by the molecule_id 'TR006' while also checking the label for carcinogenicity.\n#columns: bond.bond_type, molecule.label\n#values: double bond refers to bond.bond_type = '=', TR006 refers to bond.molecule_id = 'TR006', carcinogenic refers to molecule.label = '+'\n#SELECT: SELECT COUNT(bond.bond_type) refer to bond.bond_type. The order of columns in the SELECT clause must be the same as the order in the question.\n#SQL-like: Show COUNT(bond.bond_type), WHERE bond.bond_type = '=' AND bond.molecule_id = 'TR006' AND molecule.label = '+'\n#SQL: SELECT COUNT(bond.bond_type) FROM bond INNER JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE bond.bond_type = '=' AND bond.molecule_id = 'TR006' AND molecule.label = '+'\n```"
    ],
    "210": [
        "```\n#reason: The question wants to identify atoms that are connected by single type bonds, so the SQL SELECT will retrieve the connected atoms where the bond type is single.\n#columns: connected.atom_id, connected.atom_id2, bond.bond_type\n#values: bond_type = '-' refer to bond.bond_type = '-'\n#SELECT: SELECT connected.atom_id, connected.atom_id2 refer to connected.atom_id, connected.atom_id2\n#SQL-like: Show connected.atom_id, connected.atom_id2, WHERE bond.bond_type = '-'\n#SQL: SELECT T1.atom_id, T1.atom_id2 FROM connected AS T1 INNER JOIN bond AS T2 ON T1.bond_id = T2.bond_id WHERE T2.bond_type = '-'\n```"
    ],
    "1445": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display \"the full name of members\" whose \"t-shirt size is extra large\", so the SQL SELECT will include member.first_name and member.last_name with a filter on member.t_shirt_size.\n#columns: member.first_name, member.last_name\n#values: t_shirt_size = 'X-Large' refer to member.t_shirt_size = 'X-Large'\n#SELECT: SELECT full name refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name WHERE member.t_shirt_size = 'X-Large'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 WHERE T1.t_shirt_size = 'X-Large'\n```"
    ],
    "944": [
        "```\n#reason: The question wants to calculate how much faster in percentage the champion is compared to the driver who finished last in the 2008 Australian Grand Prix. This involves calculating the last driver's finished time based on the champion's time and then determining the percentage difference. The SQL SELECT will retrieve the necessary times for both the champion and the last driver.\n#columns: results.time, results.position, results.raceId\n#values: '2008 Australian Grand Prix' refers to races.name = 'Australian Grand Prix' AND races.year = 2008; 'finished the game' refers to results.time IS NOT NULL\n#SELECT: SELECT divide(subtract(incremental time, champion time), last_driver time) * 100\n#SQL-like: Show divide(subtract((SELECT time FROM results WHERE position = (SELECT MAX(position) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008))),(SELECT time FROM results WHERE position = 1 AND raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008))), (SELECT time FROM results WHERE position = (SELECT MAX(position) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008)) + (SELECT time FROM results WHERE position = 1 AND raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008))) * 100\n#SQL: SELECT CAST((CAST((SELECT time FROM results WHERE position = 1 AND raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008)) AS REAL) - CAST((SELECT time FROM results WHERE position = (SELECT MAX(position) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008)) + (SELECT time FROM results WHERE position = 1 AND raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008))) AS REAL)) AS REAL) * 100 / CAST((SELECT time FROM results WHERE position = (SELECT MAX(position) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008)) + (SELECT time FROM results WHERE position = 1 AND raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008))) AS REAL) FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008) AND time IS NOT NULL\n```"
    ],
    "590": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the user ID with the lowest view count, so the SQL SELECT will retrieve the user ID and order by the view count in ascending order to get the minimum.\n#columns: users.Id, users.Views\n#values: lowest views refers to MIN(Views)\n#SELECT: SELECT user ID refer to users.Id\n#SQL-like: Show users.Id, ORDER BY users.Views ASC LIMIT 1\n#SQL: SELECT Id FROM users ORDER BY Views ASC LIMIT 1\n```"
    ],
    "433": [
        "```\n#reason: The question wants to calculate the percentage of cards that have Chinese Simplified as the language and are only available for online games. The SQL SELECT will count the cards that meet these criteria and divide by the total count of cards, multiplying by 100 to get the percentage.\n#columns: cards.isOnlineOnly, foreign_data.language\n#values: 'Chinese Simplified' refer to foreign_data.language = 'Chinese Simplified', 'only available for online games' refer to cards.isOnlineOnly = 1\n#SELECT: SELECT DIVIDE(COUNT(cards.isOnlineOnly = 1), COUNT(cards.isOnlineOnly)) * 100\n#SQL-like: Show DIVIDE(COUNT(cards.isOnlineOnly = 1), COUNT(cards.isOnlineOnly)) * 100, WHERE foreign_data.language = 'Chinese Simplified' AND cards.isOnlineOnly = 1\n#SQL: SELECT CAST(COUNT(CASE WHEN cards.isOnlineOnly = 1 THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(*) FROM cards INNER JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'Chinese Simplified' AND cards.isOnlineOnly = 1\n```"
    ],
    "330": [
        "```\n#reason: The question wants to calculate the percentage of carcinogenic molecules that contain triple bonded hydrogen atoms. This requires filtering for elements where the element is hydrogen, the bond type is triple, and the label indicates carcinogenic. The SQL SELECT statement needs to account for these conditions and include the appropriate calculations for the percentage.\n#columns: molecule.label, atom.element, bond.bond_type, molecule.molecule_id\n#values: label = '+' refers to molecule.label = '+', hydrogen refers to atom.element = 'h', triple bond refers to bond.bond_type = '#'\n#SELECT: percentage of carcinogenic molecules with triple bonded hydrogen atoms refer to DIVIDE(SUM(label = '+'), COUNT(molecule_id)) * 100.0\n#SQL-like: Show DIVIDE(SUM(molecule.label = '+'), COUNT(molecule.molecule_id)) * 100.0 WHERE atom.element = 'h' AND bond.bond_type = '#'\n#SQL: SELECT CAST(SUM(CASE WHEN T3.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(T3.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id INNER JOIN molecule AS T3 ON T2.molecule_id = T3.molecule_id WHERE T1.element = 'h' AND T2.bond_type = '#'\n```"
    ],
    "431": [
        "```\n#reason: The question wants to find sets that are not available outside of the United States and have foil cards with Japanese writing on them, so the SQL SELECT will focus on fetching the set ID of such sets using specific filters for availability and language.\n#columns: sets.id, sets.isForeignOnly, sets.isFoilOnly, set_translations.language\n#values: not available outside of the United States refers to sets.isForeignOnly = 1, has foil cards refers to sets.isFoilOnly = 1, with Japanese writing on them refers to set_translations.language = 'Japanese'\n#SELECT: SELECT sets.id refer to sets.id\n#SQL-like: Show sets.id, WHERE sets.isForeignOnly = 1 AND sets.isFoilOnly = 1 AND set_translations.language = 'Japanese'\n#SQL: SELECT sets.id FROM sets INNER JOIN set_translations ON sets.code = set_translations.setCode WHERE sets.isForeignOnly = 1 AND sets.isFoilOnly = 1 AND set_translations.language = 'Japanese'\n```"
    ],
    "45": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the average writing score of each school managed by Ricci Ulrich, so the SQL SELECT will include the school names and their corresponding average writing scores.\n#columns: schools.School, satscores.AvgScrWrite\n#values: 'managed by Ricci Ulrich' refers to schools.AdmFName1 = 'Ricci' AND schools.AdmLName1 = 'Ulrich'\n#SELECT: SELECT average writing score refer to AVG(satscores.AvgScrWrite) and schools refer to schools.School\n#SQL-like: Show schools.School, AVG(satscores.AvgScrWrite) WHERE schools.AdmFName1 = 'Ricci' AND schools.AdmLName1 = 'Ulrich' GROUP BY schools.School\n#SQL: SELECT schools.School, AVG(satscores.AvgScrWrite) FROM schools INNER JOIN satscores ON schools.CDSCode = satscores.cds WHERE schools.AdmFName1 = 'Ricci' AND schools.AdmLName1 = 'Ulrich' GROUP BY schools.School\n```"
    ],
    "830": [
        "```\n#reason: The question wants to identify the weakest attribute of the Black Panther, so the SQL SELECT will retrieve the attribute_name where the attribute_value is the minimum for the superhero named 'Black Panther'.\n#columns: attribute.attribute_name, hero_attribute.attribute_value, superhero.superhero_name\n#values: 'Black Panther' refers to superhero.superhero_name = 'Black Panther'\n#SELECT: SELECT attribute.attribute_name refer to attribute.attribute_name WHERE hero_attribute.attribute_value = (SELECT MIN(hero_attribute.attribute_value) FROM hero_attribute INNER JOIN superhero ON hero_attribute.hero_id = superhero.id WHERE superhero.superhero_name = 'Black Panther')\n#SQL-like: Show attribute.attribute_name WHERE hero_attribute.attribute_value = (SELECT MIN(hero_attribute.attribute_value) FROM hero_attribute INNER JOIN superhero ON hero_attribute.hero_id = superhero.id WHERE superhero.superhero_name = 'Black Panther')\n#SQL: SELECT attribute.attribute_name FROM hero_attribute INNER JOIN superhero ON hero_attribute.hero_id = superhero.id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE superhero.superhero_name = 'Black Panther' AND hero_attribute.attribute_value = (SELECT MIN(attribute_value) FROM hero_attribute INNER JOIN superhero ON hero_attribute.hero_id = superhero.id WHERE superhero.superhero_name = 'Black Panther')\n```"
    ],
    "257": [
        "```\n#reason: The question wants to list down atom id2 for atoms with element sulfur, so the SQL SELECT will retrieve connected.atom_id2 where atom.element = 's'.\n#columns: connected.atom_id2, atom.element\n#values: element sulfur refers to atom.element = 's'\n#SELECT: SELECT connected.atom_id2 refer to connected.atom_id2\n#SQL-like: Show connected.atom_id2, WHERE atom.element = 's'\n#SQL: SELECT T1.atom_id2 FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T2.element = 's'\n```"
    ],
    "1409": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"total expense\" used on a specific date, so the SQL SELECT will sum the cost of expenses where the expense date matches the specified date.\n#columns: expense.cost\n#values: 'on 8/20/2019' refers to expense.expense_date = '2019-08-20'\n#SELECT: SELECT total expense refers to SUM(cost)\n#SQL-like: Show SUM(cost), WHERE expense.expense_date = '2019-08-20'\n#SQL: SELECT SUM(cost) FROM expense WHERE expense_date = '2019-08-20'\n```"
    ],
    "972": [
        "```\n#reason: The question wants to find \"drivers who were born in 1971 and has the fastest lap time\", so the SQL SELECT will acquire the driver's ID and code.\n#columns: drivers.driverId, drivers.code\n#values: born in 1971 refers to year(dob) = 1971; has the fastest lap time refers to results.fastestLapTime IS NOT NULL\n#SELECT: SELECT drivers.driverId, drivers.code refer to drivers.driverId, drivers.code\n#SQL-like: Show drivers.driverId, drivers.code WHERE year(drivers.dob) = 1971 AND results.fastestLapTime IS NOT NULL\n#SQL: SELECT T1.driverId, T1.code FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId WHERE strftime('%Y', T1.dob) = '1971' AND T2.fastestLapTime IS NOT NULL\n```"
    ],
    "361": [
        "```\n#reason: The question wants to count the number of cards whose legalities status is restricted and that have text boxes, so the SQL SELECT will count the cards and filter by the specified conditions.\n#columns: cards.id, legalities.status, cards.isTextless\n#values: status is restricted refer to legalities.status = 'Restricted', have text boxes refer to cards.isTextless = 0\n#SELECT: SELECT COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id), WHERE legalities.status = 'Restricted' AND cards.isTextless = 0\n#SQL: SELECT COUNT(cards.id) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'Restricted' AND cards.isTextless = 0\n```"
    ],
    "479": [
        "```\n#reason: The question wants to count the number of cards with a converted mana cost higher than 5 in the set Coldsnap that have unknown power, so the SQL SELECT COUNT(cards.id) is used to count the cards based on the specified conditions.\n#columns: cards.id, cards.convertedManaCost, cards.power, sets.name\n#values: 'set is Coldsnap' refer to sets.name = 'Coldsnap', 'converted mana cost higher than 5' refer to cards.convertedManaCost > 5, 'unknown power' refer to cards.power = '*' OR cards.power IS NULL\n#SELECT: SELECT COUNT(cards.id) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id), WHERE sets.name = 'Coldsnap' AND cards.convertedManaCost > 5 AND (cards.power = '*' OR cards.power IS NULL)\n#SQL: SELECT COUNT(cards.id) FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.convertedManaCost > 5 AND (cards.power = '*' OR cards.power IS NULL)\n```"
    ],
    "866": [
        "```\n#reason: Analyze how to generate SQL based on the question. (the question wants to identify the player with a specific lap time in a given race, so the SQL SELECT will retrieve the driver's introduction website based on the lap time and race number.)\n#columns: drivers.url, lapTimes.time, lapTimes.raceId\n#values: lap time of 0:01:27 refers to lapTimes.time LIKE '1:27%' and race number refers to lapTimes.raceId = 161\n#SELECT: SELECT drivers.url refer to drivers.url\n#SQL-like: Show drivers.url WHERE lapTimes.time LIKE '1:27%' AND lapTimes.raceId = 161\n#SQL: SELECT T1.url FROM drivers AS T1 INNER JOIN lapTimes AS T2 ON T1.driverId = T2.driverId WHERE T2.time LIKE '1:27%' AND T2.raceId = 161\n```"
    ],
    "320": [
        "```\n#reason: The question wants to identify the type of bond that connects two specific atoms, TR000_1 and TR000_2, so the SQL SELECT will retrieve the bond_type from the bond table where the bond_id matches the connection indication in the connected table.\n#columns: bond.bond_type\n#values: 'between TR000_1 and TR000_2' refer to connected.atom_id = 'TR000_1' AND connected.atom_id2 = 'TR000_2'.\n#SELECT: SELECT bond.bond_type\n#SQL-like: Show bond.bond_type WHERE connected.atom_id = 'TR000_1' AND connected.atom_id2 = 'TR000_2'\n#SQL: SELECT T1.bond_type FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T2.atom_id = 'TR000_1' AND T2.atom_id2 = 'TR000_2'\n```"
    ],
    "936": [
        "```\n#reason: The question wants to find the fastest lap for Lewis Hamilton in the 2008 Australian Grand Prix, so the SQL SELECT will involve joining the relevant tables to filter by the driver's name and the specific race.\n#columns: results.fastestLap, results.raceId, drivers.driverId, races.raceId\n#values: 'Lewis Hamilton' refers to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton', '2008 Australian Grand Prix' refers to races.name = 'Australian Grand Prix' AND races.year = 2008\n#SELECT: SELECT results.fastestLap refer to results.fastestLap\n#SQL-like: Show results.fastestLap, WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND races.name = 'Australian Grand Prix' AND races.year = 2008\n#SQL: SELECT T1.fastestLap FROM results AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceId = T3.raceId WHERE T2.forename = 'Lewis' AND T2.surname = 'Hamilton' AND T3.name = 'Australian Grand Prix' AND T3.year = 2008\n```"
    ],
    "364": [
        "```\n#reason: The question wants to display the status of the card \"Cloudchaser Eagle\", so the SQL SELECT will retrieve the status from the cards table where the name matches \"Cloudchaser Eagle\".\n#columns: cards.name, cards.hasAlternativeDeckLimit, cards.hasContentWarning, cards.hasNonFoil, cards.isFullArt, cards.isPromo, cards.isReserved\n#values: 'Cloudchaser Eagle' refers to cards.name = 'Cloudchaser Eagle'\n#SELECT: SELECT cards.hasAlternativeDeckLimit, cards.hasContentWarning, cards.hasNonFoil, cards.isFullArt, cards.isPromo, cards.isReserved refer to cards.name\n#SQL-like: Show cards.hasAlternativeDeckLimit, cards.hasContentWarning, cards.hasNonFoil, cards.isFullArt, cards.isPromo, cards.isReserved WHERE cards.name = 'Cloudchaser Eagle'\n#SQL: SELECT cards.hasAlternativeDeckLimit, cards.hasContentWarning, cards.hasNonFoil, cards.isFullArt, cards.isPromo, cards.isReserved FROM cards WHERE cards.name = 'Cloudchaser Eagle'\n```"
    ],
    "1329": [
        "```\n#reason: The question wants to find the \"county\" where Sherri Ramsey grew up, which is determined by the member's zip code. The filtering condition is the name \"Sherri Ramsey\" which corresponds to the member's first and last name.\n#columns: zip_code.county, member.first_name, member.last_name\n#values: 'Sherri' refers to member.first_name = 'Sherri', 'Ramsey' refers to member.last_name = 'Ramsey'\n#SELECT: county refers to zip_code.county\n#SQL-like: Show zip_code.county, WHERE member.first_name = 'Sherri' AND member.last_name = 'Ramsey'\n#SQL: SELECT T2.county FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T2.first_name = 'Sherri' AND T2.last_name = 'Ramsey'\n```"
    ],
    "197": [
        "```\n#reason: The question wants to calculate the average number of oxygen atoms in single-bonded molecules, so the SQL SELECT will count the number of oxygen atoms where the bond type is single and then calculate the average.\n#columns: atom.element, bond.bond_type, bond.molecule_id\n#values: single-bonded molecules refer to bond.bond_type = '-'\n#SELECT: SELECT AVG(CASE WHEN atom.element = 'o' THEN 1 ELSE 0 END) refer to atom.element\n#SQL-like: Show AVG(CASE WHEN atom.element = 'o' THEN 1 ELSE 0 END), WHERE bond.bond_type = '-' GROUP BY bond.molecule_id\n#SQL: SELECT CAST(SUM(CASE WHEN T1.element = 'o' THEN 1 ELSE 0 END) AS REAL) / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '-'\n```"
    ],
    "1364": [
        "```\n#reason: The question wants to display Amy Firth's hometown, which is defined as city, county, and state. The filtering condition is based on the member's name \"Amy Firth\".\n#columns: zip_code.city, zip_code.county, zip_code.state\n#values: 'Amy' refers to member.first_name = 'Amy' AND 'Firth' refers to member.last_name = 'Firth'\n#SELECT: hometown refers to zip_code.city, zip_code.county, zip_code.state\n#SQL-like: Show zip_code.city, zip_code.county, zip_code.state WHERE member.first_name = 'Amy' AND member.last_name = 'Firth'\n#SQL: SELECT T1.city, T1.county, T1.state FROM zip_code AS T1 INNER JOIN member AS T2 ON T1.zip_code = T2.zip WHERE T2.first_name = 'Amy' AND T2.last_name = 'Firth'\n```"
    ],
    "209": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the type of bond associated with chlorine, so the SQL SELECT will retrieve bond_type from the bond table based on the condition of the element being chlorine.\n#columns: bond.bond_type\n#values: chlorine refers to atom.element = 'cl'\n#SELECT: bond_type refers to bond.bond_type\n#SQL-like: Show bond.bond_type, WHERE atom.element = 'cl'\n#SQL: SELECT T1.bond_type FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'cl'\n```"
    ],
    "494": [
        "```\n#reason: The question wants to retrieve the text of the ruling for all cards illustrated by Jim Pavelec and check if these cards have missing or degraded properties. So the SQL SELECT will include the ruling text and a condition to check for content warnings.\n#columns: rulings.text, cards.hasContentWarning\n#values: 'all cards illustrated by Jim Pavelec' refer to cards.artist = 'Jim Pavelec'\n#SELECT: SELECT rulings.text, CASE WHEN cards.hasContentWarning = 1 THEN 'has missing or degraded properties' ELSE 'does not have missing or degraded properties' END\n#SQL-like: Show rulings.text, CASE WHEN cards.hasContentWarning = 1 THEN 'has missing or degraded properties' ELSE 'does not have missing or degraded properties' END WHERE cards.artist = 'Jim Pavelec'\n#SQL: SELECT T1.text, CASE WHEN T2.hasContentWarning = 1 THEN 'has missing or degraded properties' ELSE 'does not have missing or degraded properties' END FROM rulings AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.artist = 'Jim Pavelec'\n```"
    ],
    "16": [
        "```\n#reason: The question wants to count the number of schools in merged Alameda with a specific filter for the number of test takers, so the SQL SELECT COUNT(satscores.sname) will be used for the counting and the filtering condition will be applied.\n#columns: satscores.sname, satscores.NumTstTakr, schools.County\n#values: 'in merged Alameda' refer to schools.County = 'Alameda', 'number of test takers less than 100' refer to satscores.NumTstTakr < 100\n#SELECT: SELECT COUNT(satscores.sname) refer to counting the number of schools.\n#SQL-like: Show COUNT(satscores.sname), WHERE schools.County = 'Alameda' AND satscores.NumTstTakr < 100\n#SQL: SELECT COUNT(satscores.sname) FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.County = 'Alameda' AND satscores.NumTstTakr < 100\n```"
    ],
    "1181": [
        "```\n#reason: The question wants to find the age of the patient at the time of the laboratory test, which is calculated by subtracting the birth year from the year of the test date. The filtering conditions are based on the test date and uric acid level.\n#columns: Laboratory.Date, Patient.Birthday\n#values: uric acid level as 8.4 refers to Laboratory.UA = 8.4, 1991-10-21 refers to Laboratory.Date = '1991-10-21'\n#SELECT: how old at that time refers to SUBTRACT(year(test date), year(Birthday))\n#SQL-like: Show SUBTRACT(STRFTIME('%Y', Laboratory.Date), STRFTIME('%Y', Patient.Birthday)), WHERE Laboratory.Date = '1991-10-21' AND Laboratory.UA = 8.4\n#SQL: SELECT STRFTIME('%Y', T1.Date) - STRFTIME('%Y', T2.Birthday) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.Date = '1991-10-21' AND T1.UA = 8.4\n```"
    ],
    "746": [
        "```\n#reason: The question requires calculating the average attribute value of all superheroes. Average attribute value is defined as AVG(attribute_value).\n#columns: hero_attribute.attribute_value\n#values: None (no specific filtering conditions are given in the SQL)\n#SELECT: average attribute value refers to AVG(attribute_value)\n#SQL-like: Show AVG(hero_attribute.attribute_value)\n#SQL: SELECT AVG(attribute_value) FROM hero_attribute\n```"
    ],
    "800": [
        "```\n#reason: The question wants to calculate the percentage of superheroes with blue eyes, so the SQL SELECT will aggregate the count of superheroes with blue eyes over the total number of superheroes.\n#columns: superhero.superhero_name, superhero.eye_colour_id, colour.colour\n#values: 'blue eyes' refers to colour.colour = 'Blue' and colour.id = superhero.eye_colour_id\n#SELECT: percentage of superheroes with blue eyes refer to MULTIPLY(DIVIDE(SUM(superhero_name WHERE colour = 'Blue'), COUNT(superhero_name)), 100.0)\n#SQL-like: Show MULTIPLY(DIVIDE(SUM(superhero_name WHERE colour = 'Blue'), COUNT(superhero_name)), 100.0)\n#SQL: SELECT CAST(SUM(CASE WHEN T3.colour = 'Blue' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.superhero_name) FROM superhero AS T1 INNER JOIN colour AS T3 ON T1.eye_colour_id = T3.id\n```"
    ],
    "829": [
        "```\n#reason: The question wants to find out which publisher created more superheroes and the difference in the number of superheroes between DC Comics and Marvel Comics. Therefore, the SQL SELECT will count the number of superheroes for each publisher and calculate the difference.\n#columns: publisher.publisher_name, superhero.publisher_id\n#values: DC refers to publisher_name = 'DC Comics', Marvel Comics refers to publisher_name = 'Marvel Comics'\n#SELECT: difference in the number of superheroes between DC and Marvel refer to SUBTRACT(SUM(CASE WHEN publisher_name = 'DC Comics' THEN 1 ELSE 0 END), SUM(CASE WHEN publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\n#SQL-like: Show SUBTRACT(SUM(CASE WHEN publisher_name = 'DC Comics' THEN 1 ELSE 0 END), SUM(CASE WHEN publisher_name = 'Marvel Comics' THEN 1 ELSE 0 END))\n#SQL: SELECT (SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'DC Comics') - (SELECT COUNT(T3.id) FROM superhero AS T3 INNER JOIN publisher AS T4 ON T3.publisher_id = T4.id WHERE T4.publisher_name = 'Marvel Comics') AS difference\n```"
    ],
    "1478": [
        "```\n#reason: The question wants to identify the segment with the least consumption, so the SQL SELECT will focus on the segment and the consumption values to find the minimum.\n#columns: yearmonth.CustomerID, yearmonth.Consumption, customers.Segment\n#values: least consumption refers to MIN(yearmonth.Consumption)\n#SELECT: SELECT customers.Segment refer to customers.Segment\n#SQL-like: Show customers.Segment, ORDER BY yearmonth.Consumption ASC LIMIT 1\n#SQL: SELECT T2.Segment FROM yearmonth AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID ORDER BY T1.Consumption ASC LIMIT 1\n```"
    ],
    "1484": [
        "```\n#reason: The question wants to compare the number of discount gas stations in the Czech Republic and Slovakia, so the SQL SELECT will count the number of gas stations in each country with the segment 'Discount' and then subtract the two counts.\n#columns: gasstations.GasStationID, gasstations.Country, gasstations.Segment\n#values: 'Czech Republic' refers to gasstations.Country = 'CZE', 'Slovakia' refers to gasstations.Country = 'SVK', 'discount' refers to gasstations.Segment = 'Discount'\n#SELECT: How many more discount gas stations refer to (SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Discount') - (SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK' AND Segment = 'Discount')\n#SQL-like: Show (SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Discount') - (SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK' AND Segment = 'Discount')\n#SQL: SELECT (SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Discount') - (SELECT COUNT(GasStationID) FROM gasstations WHERE Country = 'SVK' AND Segment = 'Discount') AS Calu\n```"
    ],
    "166": [
        "```\n#reason: The question wants to count the number of accounts from the Jesenik district, so the SQL SELECT will count the account IDs where the district is Jesenik.\n#columns: account.account_id, account.district_id, district.A2\n#values: 'from Jesenik district' refer to district.A2 = 'Jesenik'\n#SELECT: SELECT COUNT(account.account_id) refer to account.account_id\n#SQL-like: Show COUNT(account.account_id) WHERE district.A2 = 'Jesenik'\n#SQL: SELECT COUNT(T1.account_id) FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id WHERE T2.A2 = 'Jesenik'\n```"
    ],
    "249": [
        "```\n#reason: The question requires displaying the elements of the atoms associated with bond id \"TR144_8_19\". Therefore, we need to join the bond and atom tables based on the bond_id and retrieve the elements corresponding to the atoms connected by this bond.\n#columns: atom.element\n#values: bond id 'TR144_8_19' refers to bond.bond_id = 'TR144_8_19'\n#SELECT: elements refer to atom.element\n#SQL-like: Show atom.element WHERE bond.bond_id = 'TR144_8_19'\n#SQL: SELECT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id OR T1.atom_id = T2.atom_id2 INNER JOIN bond AS T3 ON T2.bond_id = T3.bond_id WHERE T3.bond_id = 'TR144_8_19'\n```"
    ],
    "1360": [
        "```\n#reason: The question wants to calculate the percentage of the budget allocated for Parking in relation to the total budget for the \"November Speaker\" event, so the SQL SELECT will sum the budget amount for 'Parking' and divide it by the total budget for 'November Speaker', then multiply by 100 to get the percentage.\n#columns: budget.amount, budget.category, event.event_name\n#values: 'Parking' refer to budget.category = 'Parking', 'November Speaker' refer to event.event_name = 'November Speaker'\n#SELECT: percentage of budget for Parking to the total budget for November Speaker refer to (SUM(budget.amount WHERE budget.category = 'Parking' AND event.event_name = 'November Speaker') / SUM(budget.amount WHERE event.event_name = 'November Speaker')) * 100\n#SQL-like: Show (SUM(budget.amount WHERE budget.category = 'Parking' AND event.event_name = 'November Speaker') / SUM(budget.amount WHERE event.event_name = 'November Speaker')) * 100 \n#SQL: SELECT CAST(SUM(CASE WHEN budget.category = 'Parking' THEN budget.amount ELSE 0 END) AS REAL) * 100 / SUM(budget.amount) FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.event_name = 'November Speaker'\n```"
    ],
    "893": [
        "```\n#reason: The question wants to display the top 3 drivers and their points scored in the 2017 Chinese Grand Prix, so the SQL SELECT will include the driver names and their points, filtered by the race name and year.\n#columns: drivers.forename, drivers.surname, results.points\n#values: '2017' refers to races.year = 2017, 'Chinese Grand Prix' refers to races.name = 'Chinese Grand Prix'\n#SELECT: SELECT drivers.forename, drivers.surname, results.points refer to drivers.forename, drivers.surname, results.points\n#SQL-like: Show drivers.forename, drivers.surname, results.points WHERE races.year = 2017 AND races.name = 'Chinese Grand Prix' ORDER BY results.points DESC LIMIT 3\n#SQL: SELECT T1.forename, T1.surname, T2.points FROM drivers AS T1 INNER JOIN results AS T2 ON T1.driverId = T2.driverId INNER JOIN races AS T3 ON T2.raceId = T3.raceId WHERE T3.year = 2017 AND T3.name = 'Chinese Grand Prix' ORDER BY T2.points DESC LIMIT 3\n```"
    ],
    "311": [
        "```\n#reason: The question wants to count the number of molecules that do not contain the sulphur element and do not have a double bond. Therefore, the SQL SELECT will count the distinct molecule IDs where the bond type is not a double bond and the element is not sulphur.\n#columns: DISTINCT molecule.molecule_id\n#values: 'without sulphur element' refer to atom.element <> 's', 'not having double bond' refer to bond.bond_type <> '='\n#SELECT: SELECT COUNT(DISTINCT molecule.molecule_id) refer to COUNT(DISTINCT molecule.molecule_id)\n#SQL-like: Show COUNT(DISTINCT molecule.molecule_id), WHERE atom.element <> 's' AND bond.bond_type <> '='\n#SQL: SELECT COUNT(DISTINCT molecule.molecule_id) FROM atom INNER JOIN bond ON atom.molecule_id = bond.molecule_id WHERE atom.element <> 's' AND bond.bond_type <> '='\n```"
    ],
    "961": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the race with the shortest actual finishing time, so the SQL SELECT will retrieve the name and year of the race with the minimum milliseconds value, excluding null values.\n#columns: races.name, races.year, results.milliseconds\n#values: shortest actual finishing time refers to Min(milliseconds) where milliseconds is not null\n#SELECT: SELECT races.name, races.year\n#SQL-like: Show races.name, races.year, WHERE results.milliseconds = (SELECT MIN(milliseconds) FROM results WHERE milliseconds IS NOT NULL)\n#SQL: SELECT races.name, races.year FROM results INNER JOIN races ON results.raceId = races.raceId WHERE results.milliseconds IS NOT NULL ORDER BY results.milliseconds ASC LIMIT 1\n```"
    ],
    "551": [
        "```\n#reason: The question wants to count the number of badges obtained by the user \"csgillespie\", so the SQL SELECT COUNT(badges.Id) and the filtering condition is based on the user's DisplayName.\n#columns: badges.Id, users.DisplayName\n#values: 'csgillespie' refer to users.DisplayName = 'csgillespie'\n#SELECT: SELECT COUNT(badges.Id) refer to COUNT(badges.Id)\n#SQL-like: Show COUNT(badges.Id), WHERE users.DisplayName = 'csgillespie'\n#SQL: SELECT COUNT(T1.Id) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.DisplayName = 'csgillespie'\n```"
    ],
    "835": [
        "```\n#reason: The question wants to calculate the percentage of 'good' superheroes among all superheroes published by Marvel Comics. The SQL SELECT statement will count the number of superheroes with 'Good' alignment and divide it by the total number of superheroes published by Marvel Comics, then multiply by 100 to get the percentage.\n#columns: superhero.id, alignment.alignment, publisher.publisher_name\n#values: 'Marvel Comics' refers to publisher.publisher_name = 'Marvel Comics', 'Good' refers to alignment.alignment = 'Good'\n#SELECT: percentage of 'good' superheroes refer to (SUM(alignment = 'Good') / COUNT(publisher_name)) * 100\n#SQL-like: Show (SUM(CASE WHEN alignment.alignment = 'Good' THEN 1 ELSE 0 END) * 100 / COUNT(superhero.id)), WHERE publisher.publisher_name = 'Marvel Comics'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.alignment_id = (SELECT id FROM alignment WHERE alignment = 'Good') THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'\n```"
    ],
    "1173": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the most common illness identified among patients whose lab work was done within a specific date range, so the SQL SELECT will count the occurrences of each diagnosis and select the one with the maximum count.\n#columns: Examination.Diagnosis, Laboratory.Date\n#values: lab work between 1/1/1985 and 12/31/1995 refers to Laboratory.Date between '1985-01-01' and '1995-12-31'\n#SELECT: SELECT content 'most common illness' refer to Examination.Diagnosis\n#SQL-like: Show Examination.Diagnosis, WHERE Laboratory.Date BETWEEN '1985-01-01' AND '1995-12-31', GROUP BY Examination.Diagnosis ORDER BY COUNT(Examination.Diagnosis) DESC\n#SQL: SELECT T1.Diagnosis FROM Examination AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.Date BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T1.Diagnosis ORDER BY COUNT(T1.Diagnosis) DESC LIMIT 1\n```"
    ],
    "584": [
        "```\n#reason: The question wants to retrieve all comments left by users who edited a specific post, so the SQL SELECT will focus on the comments related to the post with the given title.\n#columns: comments.Text, comments.UserId\n#values: title is 'Why square the difference instead of taking the absolute value in standard deviation?' refer to posts.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\n#SELECT: SELECT comments.Text, comments.UserId refer to comments.Text, comments.UserId\n#SQL-like: Show comments.Text, comments.UserId WHERE posts.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\n#SQL: SELECT T1.Text, T1.UserId FROM comments AS T1 INNER JOIN posts AS T2 ON T1.PostId = T2.Id WHERE T2.Title = 'Why square the difference instead of taking the absolute value in standard deviation?'\n```"
    ],
    "102": [
        "```\n#reason: The question wants to list different accounts that were opened before 1997 and have an amount of money greater than 3000 USD, so the SQL SELECT will filter accounts based on the opening date and the amount of money.\n#columns: account.account_id, account.date, trans.amount\n#values: 'account opening date before 1997' refer to account.date < '1997-01-01', 'amount of money greater than 3000USD' refer to trans.amount > 3000\n#SELECT: SELECT DISTINCT account.account_id refer to account.account_id\n#SQL-like: Show DISTINCT account.account_id, WHERE account.date < '1997-01-01' AND trans.amount > 3000\n#SQL: SELECT DISTINCT account.account_id FROM account INNER JOIN trans ON account.account_id = trans.account_id WHERE account.date < '1997-01-01' AND trans.amount > 3000\n```"
    ],
    "581": [
        "```\n#reason: The question wants to display the editor of a specific post title, so the SQL SELECT will retrieve the DisplayName of the user who is the last editor of the post with the specified title.\n#columns: posts.Title, users.DisplayName, posts.LastEditorUserId\n#values: 'Open source tools for visualizing multi-dimensional data?' refer to posts.Title = 'Open source tools for visualizing multi-dimensional data?'\n#SELECT: editor refer to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE posts.Title = 'Open source tools for visualizing multi-dimensional data?'\n#SQL: SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Open source tools for visualizing multi-dimensional data?'\n```"
    ],
    "425": [
        "```\n#reason: The question wants to find the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard, so the SQL SELECT will check for card numbers where 'side is null' and 'subtypes include Angel and Wizard'.\n#columns: cards.number, cards.side, cards.subtypes\n#values: 'don't have multiple faces on a single card' refer to cards.side IS NULL, 'subtypes include Angel and Wizard' refer to cards.subtypes LIKE '%Angel%' AND cards.subtypes LIKE '%Wizard%'\n#SELECT: SELECT cards.number \n#SQL-like: Show cards.number WHERE cards.side IS NULL AND cards.subtypes LIKE '%Angel%' AND cards.subtypes LIKE '%Wizard%'\n#SQL: SELECT cards.number FROM cards WHERE cards.side IS NULL AND cards.subtypes LIKE '%Angel%' AND cards.subtypes LIKE '%Wizard%'\n```"
    ],
    "1314": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the full names of the students in the Student_Club that come from the Art and Design Department, so the SQL SELECT will include first_name and last_name from the member table, with a filter on the major.department.\n#columns: member.first_name, member.last_name\n#values: 'come from the Art and Design Department' refer to major.department = 'Art and Design Department'\n#SELECT: SELECT full names of the students refer to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, WHERE member.link_to_major IN (SELECT major.major_id FROM major WHERE major.department = 'Art and Design Department')\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'Art and Design Department'\n```"
    ],
    "8": [
        "```\n#reason: The question wants to find \"the number of SAT test takers of the schools with the highest FRPM count for K-12 students\", so the SQL SELECT will retrieve the number of test takers and the schools need to be filtered by the highest FRPM count.\n#columns: satscores.NumTstTakr, frpm.`FRPM Count (K-12)`\n#values: 'highest FRPM count for K-12 students' refers to 'satscores.cds = frpm.School Code AND frpm.`FRPM Count (K-12)` = (SELECT MAX(`FRPM Count (K-12)`) FROM frpm)'\n#SELECT: SELECT 'the number of SAT test takers' refer to satscores.NumTstTakr\n#SQL-like: Show satscores.NumTstTakr WHERE frpm.`FRPM Count (K-12)` = (SELECT MAX(`FRPM Count (K-12)`) FROM frpm)\n#SQL: SELECT T1.NumTstTakr FROM satscores AS T1 INNER JOIN frpm AS T2 ON T1.cds = T2.School Code WHERE T2.`FRPM Count (K-12)` = (SELECT MAX(`FRPM Count (K-12)`) FROM frpm)\n```"
    ],
    "284": [
        "```\n#reason: The question wants to determine the bond type that is formed in the chemical compound containing element Carbon, so the SQL SELECT statements will check for the element 'c' and retrieve the corresponding bond types.\n#columns: bond.bond_type, atom.element\n#values: element Carbon refers to atom.element = 'c'\n#SELECT: SELECT bond type (bond.bond_type) refer to bond.bond_type\n#SQL-like: Show bond.bond_type, WHERE atom.element = 'c'\n#SQL: SELECT DISTINCT T2.bond_type FROM bond AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.element = 'c'\n```"
    ],
    "1149": [
        "```\n#reason: The question wants to compare the number of male in-patients and outpatients and calculate the deviation in percentage, so the SQL SELECT will count the male patients in both categories and compute the percentage difference.\n#columns: Patient.SEX, Patient.Admission, Patient.ID\n#values: male refers to Patient.SEX = 'M', in-patient refers to Patient.Admission = '+', outpatient refers to Patient.Admission = '-'\n#SELECT: percentage deviation refer to DIVIDE(COUNT(ID) WHERE SEX = 'M' AND Admission = '+', COUNT(ID) WHERE SEX = 'M' AND Admission = '-') * 100\n#SQL-like: Show DIVIDE(COUNT(ID) WHERE SEX = 'M' AND Admission = '+', COUNT(ID) WHERE SEX = 'M' AND Admission = '-') * 100\n#SQL: SELECT CAST(COUNT(CASE WHEN Admission = '+' THEN ID END) AS REAL) * 100 / COUNT(CASE WHEN Admission = '-' THEN ID END) AS deviation FROM Patient WHERE SEX = 'M'\n```"
    ],
    "563": [
        "```\n#reason: The question wants to find out the \"how many favorite counts\" for the post to which user No.3025 commented. This requires filtering the comments to find the specific user and the comment date, and subsequently accessing the favorite count of the related post. \n#columns: posts.FavoriteCount, comments.PostId, comments.CreationDate, comments.UserId\n#values: user No.3025 refers to comments.UserId = 3025, comment at 20:29:39 on 2014/4/23 refers to comments.CreationDate = '2014-04-23 20:29:39.0'\n#SELECT: how many favorite counts refers to posts.FavoriteCount\n#SQL-like: Show posts.FavoriteCount, WHERE comments.UserId = 3025 AND comments.CreationDate = '2014-04-23 20:29:39.0'\n#SQL: SELECT T1.FavoriteCount FROM posts AS T1 INNER JOIN comments AS T2 ON T1.Id = T2.PostId WHERE T2.UserId = 3025 AND T2.CreationDate = '2014-04-23 20:29:39.0'\n```"
    ],
    "1109": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the build up play dribbling class for the team \"LEI\" on a specific date, so the SQL SELECT will retrieve the buildUpPlayDribblingClass from Team_Attributes where the team_short_name is 'LEI' and the date is '2015-09-10 00:00:00'.\n#columns: Team_Attributes.buildUpPlayDribblingClass, Team.team_short_name, Team_Attributes.date\n#values: 'LEI' refer to Team.team_short_name = 'LEI', '2015-09-10 00:00:00' refer to Team_Attributes.date = '2015-09-10 00:00:00'\n#SELECT: SELECT Team_Attributes.buildUpPlayDribblingClass\n#SQL-like: Show Team_Attributes.buildUpPlayDribblingClass, WHERE Team.team_short_name = 'LEI' AND Team_Attributes.date = '2015-09-10 00:00:00'\n#SQL: SELECT T1.buildUpPlayDribblingClass FROM Team_Attributes AS T1 INNER JOIN Team AS T2 ON T1.team_api_id = T2.team_api_id WHERE T2.team_short_name = 'LEI' AND T1.date = '2015-09-10 00:00:00'\n```"
    ],
    "1053": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list \"the football teams\" with a specific \"chance creation passing class\" of 'Risky', so the SQL SELECT will focus on the team_short_name from the Team_Attributes table where the chanceCreationPassingClass is 'Risky'.\n#columns: Team.team_short_name, Team_Attributes.chanceCreationPassingClass\n#values: chance creation passing class of Risky refers to Team_Attributes.chanceCreationPassingClass = 'Risky'\n#SELECT: SELECT team_short_name refer to Team.team_short_name\n#SQL-like: Show Team.team_short_name, WHERE Team_Attributes.chanceCreationPassingClass = 'Risky'\n#SQL: SELECT T.team_short_name FROM Team_Attributes AS T INNER JOIN Team AS T2 ON T.team_api_id = T2.team_api_id WHERE T.chanceCreationPassingClass = 'Risky'\n```"
    ],
    "243": [
        "```\n#reason: The question requires identifying bonds that include phosphorus and nitrogen as atom elements, so the SQL SELECT will involve filtering for these elements in the atomic data and joining with the bond data to retrieve the corresponding bonds.\n#columns: bond.bond_id, bond.bond_type\n#values: phosphorus as atom element refers to atom.element = 'p'; nitrogen as atom element refers to atom.element = 'n'\n#SELECT: SELECT bond.bond_id, bond.bond_type refer to bond.bond_id, bond.bond_type\n#SQL-like: Show bond.bond_id, bond.bond_type, WHERE atom.element = 'p' AND atom.element = 'n'\n#SQL: SELECT DISTINCT B.bond_id, B.bond_type FROM bond AS B INNER JOIN atom AS A1 ON B.molecule_id = A1.molecule_id WHERE A1.element = 'p' AND B.bond_id IN (SELECT B2.bond_id FROM bond AS B2 INNER JOIN atom AS A2 ON B2.molecule_id = A2.molecule_id WHERE A2.element = 'n')\n```"
    ],
    "1332": [
        "```\n#reason: The question wants to know how much the Student_Club members spent on food for the September Meeting, so the SQL SELECT will involve calculating the total amount spent categorized under food for that specific event.\n#columns: budget.spent\n#values: spend on food in September Meeting refers to budget.category = 'Food' AND event.event_name = 'September Meeting'\n#SELECT: SELECT SUM(budget.spent) refer to budget.spent\n#SQL-like: Show SUM(budget.spent), WHERE budget.category = 'Food' AND event.event_name = 'September Meeting'\n#SQL: SELECT SUM(T1.spent) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Food' AND T2.event_name = 'September Meeting'\n```"
    ],
    "449": [
        "```\n#reason: The question wants to display the \"language of the card\" and \"type of this card\". \"has azorius watermark\" is a filtering condition. \n#columns: foreign_data.language, cards.type\n#values: azorius watermark refers to cards.watermark = 'azorius'\n#SELECT: SELECT foreign_data.language, cards.type\n#SQL-like: Show foreign_data.language, cards.type WHERE cards.watermark = 'azorius'\n#SQL: SELECT T1.language, T2.type FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid WHERE T2.watermark = 'azorius'\n```"
    ],
    "539": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the owner of a specific post, so the SQL SELECT will retrieve the DisplayName based on the Title of the post.\n#columns: posts.Title, users.DisplayName\n#values: 'Eliciting priors from experts' refer to posts.Title = 'Eliciting priors from experts'\n#SELECT: SELECT DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE posts.Title = 'Eliciting priors from experts'\n#SQL: SELECT u.DisplayName FROM posts AS p INNER JOIN users AS u ON p.OwnerUserId = u.Id WHERE p.Title = 'Eliciting priors from experts'\n```"
    ],
    "546": [
        "```\n#reason: The question wants to list the display names of all the users who own a post that is well-finished, so the SQL SELECT will include the display names from the users table and filter for posts where ClosedDate is not null.\n#columns: users.DisplayName, posts.ClosedDate\n#values: the post that is well-finished refers to posts.ClosedDate IS NOT NULL\n#SELECT: SELECT users.DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName WHERE posts.ClosedDate IS NOT NULL\n#SQL: SELECT T1.DisplayName FROM users AS T1 INNER JOIN posts AS T2 ON T1.Id = T2.OwnerUserId WHERE T2.ClosedDate IS NOT NULL\n```"
    ],
    "630": [
        "```\n#reason: The question wants to display the name of tags used by John Salvatier, so the SQL SELECT will be for tags and the filtering is based on the user’s display name.\n#columns: tags.TagName, posts.OwnerDisplayName\n#values: 'John Salvatier' refers to posts.OwnerDisplayName = 'John Salvatier'\n#SELECT: SELECT tags.TagName refer to tags.TagName\n#SQL-like: Show tags.TagName WHERE posts.OwnerDisplayName = 'John Salvatier'\n#SQL: SELECT T1.TagName FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id WHERE T2.OwnerDisplayName = 'John Salvatier'\n```"
    ],
    "1170": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find out how many patients hadn't undergone a medical examination until at least a year following their initial hospital visit, so the SQL SELECT will count distinct patient IDs while applying the filtering condition based on the difference in years between the `Examination Date` and `First Date`.\n#columns: DISTINCT Patient.ID, Examination.`Examination Date`, Patient.`First Date`\n#values: hadn't undergone a medical examination until at least a year refers to \"SUBTRACT(year(`Examination Date`), year(`First Date`)) >= 1\"\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE (SUBTRACT(year(`Examination Date`), year(`First Date`)) >= 1)\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P LEFT JOIN Examination AS E ON P.ID = E.ID WHERE strftime('%Y', E.`Examination Date`) - strftime('%Y', P.`First Date`) >= 1\n```"
    ],
    "910": [
        "```\n#reason: The question wants to display the location coordinates of Silverstone Circuit, so the SQL SELECT will retrieve the latitude and longitude from the circuits table where the name matches 'Silverstone Circuit'.\n#columns: circuits.lat, circuits.lng\n#values: 'Silverstone Circuit' refer to circuits.name = 'Silverstone Circuit'\n#SELECT: SELECT location coordinates refer to circuits.lat, circuits.lng\n#SQL-like: Show circuits.lat, circuits.lng WHERE circuits.name = 'Silverstone Circuit'\n#SQL: SELECT T1.lat, T1.lng FROM circuits AS T1 WHERE T1.name = 'Silverstone Circuit'\n```"
    ],
    "401": [
        "```\n#reason: The question wants to calculate the percentage of legendary frame effect cards that are only available in online game variations. This is done by counting the number of cards that are both legendary and available online, then dividing that by the total count of legendary cards. \n#columns: cards.id, cards.isOnlineOnly, cards.frameEffects\n#values: 'only available in online game variations' refer to 'isOnlineOnly = 1', 'legendary frame effect cards' refer to 'frameEffects = 'legendary''\n#SELECT: SELECT CAST(COUNT(CASE WHEN isOnlineOnly = 1 THEN 1 END) AS REAL) * 100 / COUNT(id)\n#SQL-like: Show percentage (COUNT(CASE WHEN isOnlineOnly = 1 THEN 1 END) / COUNT(id)); WHERE frameEffects = 'legendary'\n#SQL: SELECT CAST(COUNT(CASE WHEN isOnlineOnly = 1 THEN 1 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE frameEffects = 'legendary'\n```"
    ],
    "266": [
        "```\n#reason: The question requires calculating the \"total carcinogenic molecules\" for molecule ids from TR000 to TR030, so the SQL SELECT will sum the molecules where label = '+' and the molecule_id is between the specified range.\n#columns: molecule.label, molecule.molecule_id\n#values: label = '+' refer to molecule.label = '+', molecule id from TR000 to TR030 refer to molecule.molecule_id BETWEEN 'TR000' AND 'TR030'\n#SELECT: total carcinogenic molecules refer to COUNT(molecule.molecule_id)\n#SQL-like: Show COUNT(molecule.molecule_id), WHERE molecule.label = '+' AND molecule.molecule_id BETWEEN 'TR000' AND 'TR030'\n#SQL: SELECT COUNT(molecule.molecule_id) FROM molecule WHERE molecule.label = '+' AND molecule.molecule_id BETWEEN 'TR000' AND 'TR030'\n```"
    ],
    "278": [
        "```\n#reason: The question wants to count the number of single bond type molecules that are non-carcinogenic, so the SQL SELECT COUNT(molecule.molecule_id) and COUNT(bond.bond_id) will be used to filter based on the bond type and label.\n#columns: molecule.molecule_id, bond.bond_id\n#values: 'non-carcinogenic' refers to molecule.label = '-' and 'single bond type' refers to bond.bond_type = '-'\n#SELECT: SELECT COUNT(molecule.molecule_id) FROM molecule INNER JOIN bond ON molecule.molecule_id = bond.molecule_id WHERE molecule.label = '-' AND bond.bond_type = '-'\n#SQL-like: Show COUNT(molecule.molecule_id), WHERE molecule.label = '-' AND bond.bond_type = '-'\n#SQL: SELECT COUNT(molecule.molecule_id) FROM molecule INNER JOIN bond ON molecule.molecule_id = bond.molecule_id WHERE molecule.label = '-' AND bond.bond_type = '-'\n```"
    ],
    "1318": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the event with the highest attendance, so the SQL SELECT will count the number of attendees for each event and find the maximum.\n#columns: attendance.link_to_event, event.event_name\n#values: None\n#SELECT: SELECT event.event_name refer to event.event_name\n#SQL-like: Show event.event_name, GROUP BY attendance.link_to_event, ORDER BY COUNT(attendance.link_to_event) DESC LIMIT 1\n#SQL: SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id GROUP BY T1.link_to_event ORDER BY COUNT(T1.link_to_event) DESC LIMIT 1\n```"
    ],
    "669": [
        "```\n#reason: The question requires displaying the earliest vote date for user 'chl'. The earliest vote date is identified as MIN(CreationDate), and 'chl' refers to DisplayName = 'chl'.\n#columns: votes.CreationDate, users.DisplayName\n#values: 'chl' refers to users.DisplayName = 'chl'\n#SELECT: first vote date refers to MIN(votes.CreationDate)\n#SQL-like: Show MIN(votes.CreationDate) WHERE users.DisplayName = 'chl'\n#SQL: SELECT MIN(v.CreationDate) FROM votes AS v INNER JOIN users AS u ON v.UserId = u.Id WHERE u.DisplayName = 'chl'\n```"
    ],
    "940": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of drivers who finished the race in the 2008 Chinese Grand Prix and have participated in Formula 1 races, so the SQL SELECT will count the distinct driver IDs from the results table where the time is not null and the driver has entries in the driver standings.\n#columns: results.driverId, results.time, driverStandings.driverId\n#values: 'finished the race in the 2008 Chinese Grand Prix' refer to results.raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix' AND year = 2008) AND results.time IS NOT NULL; 'participated in Formula_1 races' refer to COUNT(driverStandings.raceId) > 0\n#SELECT: SELECT COUNT(DISTINCT results.driverId) refer to 'how many drivers'\n#SQL-like: Show COUNT(DISTINCT results.driverId), WHERE results.raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix' AND year = 2008) AND results.time IS NOT NULL AND EXISTS (SELECT 1 FROM driverStandings WHERE driverStandings.driverId = results.driverId)\n#SQL: SELECT COUNT(DISTINCT R1.driverId) FROM results AS R1 WHERE R1.raceId = (SELECT raceId FROM races WHERE name = 'Chinese Grand Prix' AND year = 2008) AND R1.time IS NOT NULL AND EXISTS (SELECT 1 FROM driverStandings AS R2 WHERE R2.driverId = R1.driverId)\n```"
    ],
    "1519": [
        "```\n#reason: The question wants to find the product id of a specific transaction, so the SQL SELECT will filter by the date and time of the transaction.\n#columns: transactions_1k.ProductID, transactions_1k.Date, transactions_1k.Time\n#values: '2012/8/23 21:20:00' refer to transactions_1k.Date = '2012-08-23' AND transactions_1k.Time = '21:20:00'\n#SELECT: product id refer to transactions_1k.ProductID\n#SQL-like: Show transactions_1k.ProductID, WHERE transactions_1k.Date = '2012-08-23' AND transactions_1k.Time = '21:20:00'\n#SQL: SELECT T1.ProductID FROM transactions_1k AS T1 WHERE T1.Date = '2012-08-23' AND T1.Time = '21:20:00'\n```"
    ],
    "1230": [
        "```\n#reason: The question wants to list all outpatient patients with a normal range of creatinine phosphokinase, so the SQL SELECT will include distinct patient IDs where the Admission status is outpatient and the CPK level is below 250.\n#columns: Patient.ID, Patient.Admission, Laboratory.CPK\n#values: outpatient refers to Patient.Admission = '-', normal range of creatinine phosphokinase refers to Laboratory.CPK < 250\n#SELECT: SELECT DISTINCT Patient.ID\n#SQL-like: Show DISTINCT Patient.ID, WHERE Patient.Admission = '-' AND Laboratory.CPK < 250\n#SQL: SELECT DISTINCT Patient.ID FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Patient.Admission = '-' AND Laboratory.CPK < 250\n```"
    ],
    "1355": [
        "```\n#reason: The question wants to display the hometown state for a member named \"Sacha Harrison\". The filtering condition is the full name, which corresponds to member's first and last name.\n#columns: zip_code.state\n#values: 'Sacha' refers to member.first_name = 'Sacha' AND 'Harrison' refers to member.last_name = 'Harrison'\n#SELECT: SELECT state refer to zip_code.state\n#SQL-like: Show zip_code.state, WHERE member.first_name = 'Sacha' AND member.last_name = 'Harrison'\n#SQL: SELECT T2.state FROM member AS T1 INNER JOIN zip_code AS T2 ON T1.zip = T2.zip_code WHERE T1.first_name = 'Sacha' AND T1.last_name = 'Harrison'\n```"
    ],
    "1394": [
        "```\n#reason: The question wants to find the number of members who have a major in 'Physics Teaching', so the SQL SELECT will count the members whose major matches this name.\n#columns: member.member_id, major.major_name\n#values: major is 'Physics Teaching' refer to major.major_name = 'Physics Teaching'\n#SELECT: SELECT COUNT(member.member_id) refer to member.member_id\n#SQL-like: Show COUNT(member.member_id) WHERE major.major_name = 'Physics Teaching'\n#SQL: SELECT COUNT(T1.member_id) FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Physics Teaching'\n```"
    ],
    "1276": [
        "```\n#reason: The question wants to list the diseases diagnosed in patients with an abnormal level of anti-DNA, so the SQL SELECT will pull the Diagnosis based on the condition of having DNA greater than or equal to 8.\n#columns: Patient.Diagnosis, Laboratory.DNA\n#values: abnormal level of anti-DNA refers to Laboratory.DNA >= 8\n#SELECT: diseases refer to Patient.Diagnosis\n#SQL-like: Show Patient.Diagnosis, WHERE Laboratory.DNA >= 8\n#SQL: SELECT T1.Diagnosis FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.DNA >= 8\n```"
    ],
    "1283": [
        "```\n#reason: The question wants to determine the count of patients who have a normal glutamic pyruvic transaminase level and are male, so the SQL SELECT will count distinct Patient IDs and filter by the defined conditions.\n#columns: Laboratory.GOT, Patient.SEX, Patient.ID\n#values: normal glutamic pyruvic transaminase level refers to Laboratory.GOT < 60, male refers to Patient.SEX = 'M'\n#SELECT: SELECT COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.GOT < 60 AND Patient.SEX = 'M'\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.GOT < 60 AND T2.SEX = 'M'\n```"
    ],
    "576": [
        "```\n#reason: The question want to retrieve the user who commented a specific text, so the SQL SELECT will focus on the DisplayName of the user associated with that comment.\n#columns: comments.Text, comments.UserId, users.DisplayName\n#values: 'thank you user93!' refers to comments.Text = 'thank you user93!'\n#SELECT: SELECT DisplayName refer to users.DisplayName\n#SQL-like: Show users.DisplayName, WHERE comments.Text = 'thank you user93!'\n#SQL: SELECT users.DisplayName FROM comments INNER JOIN users ON comments.UserId = users.Id WHERE comments.Text = 'thank you user93!'\n```"
    ],
    "1522": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to determine the currency used by the customer who spent a specific amount in June of 2013, so the SQL SELECT will retrieve the currency from the customers table and join with the yearmonth table to filter by the amount spent and the date.\n#columns: customers.Currency, yearmonth.Consumption\n#values: 'spending of 214582.17' refer to yearmonth.Consumption = 214582.17, 'in June of 2013' refer to yearmonth.Date like '201306'\n#SELECT: SELECT customers.Currency refer to customers.Currency\n#SQL-like: Show customers.Currency, WHERE yearmonth.Consumption = 214582.17 and yearmonth.Date like '201306'\n#SQL: SELECT T1.Currency FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Consumption = 214582.17 AND T2.Date LIKE '201306'\n```"
    ],
    "1467": [
        "```\n#reason: The question wants to calculate the total amount spent on speaker gifts and list the name of the event they were spent on, so the SQL SELECT will summarize the spent amount and include the event name.\n#columns: budget.spent, event.event_name\n#values: 'category is Speaker Gifts' refer to budget.category = 'Speaker Gifts'\n#SELECT: SELECT total amount spent refer to SUM(budget.spent), name of the event refer to event.event_name\n#SQL-like: Show SUM(budget.spent), event.event_name, WHERE budget.category = 'Speaker Gifts'\n#SQL: SELECT SUM(budget.spent), event.event_name FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE budget.category = 'Speaker Gifts'\n```"
    ],
    "983": [
        "```\n#reason: The question requires finding out \"which Italian constructor\" has \"the highest point\" and their \"introduction website.\" The highest point is determined from the points column in the constructorStandings table, and Italian refers to constructors of nationality 'Italian'.\n#columns: constructors.name, constructorStandings.points, constructors.url\n#values: 'Italian' refers to constructors.nationality = 'Italian'\n#SELECT: SELECT constructors.name, constructorStandings.points, constructors.url\n#SQL-like: Show constructors.name, constructorStandings.points, constructors.url WHERE constructors.nationality = 'Italian' ORDER BY constructorStandings.points DESC LIMIT 1\n#SQL: SELECT T1.name, T2.points, T1.url FROM constructors AS T1 INNER JOIN constructorStandings AS T2 ON T1.constructorId = T2.constructorId WHERE T1.nationality = 'Italian' ORDER BY T2.points DESC LIMIT 1\n```"
    ],
    "1266": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the youngest patient with an abnormal anti-ribonuclear protein level, so the SQL SELECT will retrieve the patient's date of birth where the anti-ribonuclear protein level is not normal.\n#columns: Patient.Birthday, Laboratory.RNP\n#values: abnormal anti-ribonuclear protein level refers to Laboratory.RNP NOT IN ('-', '+-')\n#SELECT: SELECT Patient.Birthday refer to Patient.Birthday\n#SQL-like: Show Patient.Birthday, WHERE Laboratory.RNP NOT IN ('-', '+-'), ORDER BY Patient.Birthday DESC LIMIT 1\n#SQL: SELECT T1.Birthday FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.RNP NOT IN ('-', '+-') ORDER BY T1.Birthday DESC LIMIT 1\n```"
    ],
    "122": [
        "```\n#reason: The question wants to display the \"district\" and \"region\" for the loan ID '4990', so the SQL SELECT will retrieve the district name and region based on the loan ID.\n#columns: district.A2, district.A3\n#values: loan ID '4990' refers to loan.loan_id = 4990\n#SELECT: SELECT district.A2, district.A3\n#SQL-like: Show district.A2, district.A3, WHERE loan.loan_id = 4990\n#SQL: SELECT T1.A2, T2.A3 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.loan_id = 4990\n```"
    ],
    "1435": [
        "```\n#reason: The question wants to list the names of closed events that are of type \"Game\" and were closed between specific dates, so the SQL SELECT will filter by event type, status, and event date.\n#columns: event.event_name, event.type, event.status, event.event_date\n#values: 'closed event' refer to event.status = 'Closed', 'game event' refer to event.type = 'Game', 'from 3/15/2019 to 3/20/2020' refer to event.event_date BETWEEN '2019-03-15' AND '2020-03-20'\n#SELECT: SELECT event_name refer to event.event_name\n#SQL-like: Show event.event_name, WHERE event.type = 'Game' AND event.status = 'Closed' AND event.event_date BETWEEN '2019-03-15' AND '2020-03-20'\n#SQL: SELECT event.event_name FROM event WHERE event.type = 'Game' AND event.status = 'Closed' AND event.event_date BETWEEN '2019-03-15' AND '2020-03-20'\n```"
    ],
    "467": [
        "```\n#reason: The question wants to display \"How many cards\" in the base set of a specific translation, so the SQL SELECT will count the baseSetSize where the translation matches 'Hauptset Zehnte Edition'.\n#columns: sets.baseSetSize, set_translations.translation\n#values: 'Hauptset Zehnte Edition' refer to set_translations.translation = 'Hauptset Zehnte Edition'\n#SELECT: SELECT COUNT(sets.baseSetSize) refer to sets.baseSetSize\n#SQL-like: Show COUNT(sets.baseSetSize), WHERE set_translations.translation = 'Hauptset Zehnte Edition'\n#SQL: SELECT COUNT(s.baseSetSize) FROM sets AS s INNER JOIN set_translations AS st ON s.code = st.setCode WHERE st.translation = 'Hauptset Zehnte Edition'\n```"
    ],
    "943": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the rate of drivers completing all the laps in the 2008 Australian Grand Prix, so the SQL SELECT will calculate the rate as the division of the count of drivers with non-null time over the total count of drivers in that race.\n#columns: results.raceId, results.time\n#values: '2008 Australian Grand Prix' refers to races.name = 'Australian Grand Prix' and races.year = 2008\n#SELECT: rate of drivers completing all the laps refers to CAST(SUM(CASE WHEN results.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(results.raceId)\n#SQL-like: Show CAST(SUM(CASE WHEN results.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(results.raceId), WHERE races.name = 'Australian Grand Prix' AND races.year = 2008\n#SQL: SELECT CAST(SUM(CASE WHEN results.time IS NOT NULL THEN 1 ELSE 0 END) AS REAL) / COUNT(results.raceId) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.name = 'Australian Grand Prix' AND races.year = 2008\n```"
    ],
    "1057": [
        "```\n#reason: The question wants to calculate the \"average home team goal\" in the \"2010/2011 season\" for the country \"Poland\". The average is calculated using AVG(home_team_goal), and the filtering conditions are based on the country name and the season.\n#columns: Match.home_team_goal, Match.season, Country.name\n#values: 'Poland' refer to Country.name = 'Poland', '2010/2011' refer to Match.season = '2010/2011'\n#SELECT: average home team goal refer to AVG(home_team_goal)\n#SQL-like: Show AVG(home_team_goal), WHERE season = '2010/2011' AND Country.name = 'Poland'\n#SQL: SELECT AVG(M.home_team_goal) FROM Match AS M INNER JOIN Country AS C ON M.country_id = C.id WHERE M.season = '2010/2011' AND C.name = 'Poland'\n```"
    ],
    "1016": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find out how long a driver spent at the pit stop during the race where he set the lap record for the Austrian Grand Prix Circuit, so the SQL SELECT will retrieve the duration of the pit stop for the race with the fastest lap time for the Austrian Grand Prix.\n#columns: results.time, pitStops.duration\n#values: lap record refers to results.fastestLapTime = (SELECT MIN(results.fastestLapTime) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.name = 'Austrian Grand Prix'), how long spent at pitstop refers to pitStops.duration\n#SELECT: SELECT pitStops.duration refer to pitStops.duration\n#SQL-like: Show pitStops.duration, WHERE results.fastestLapTime = (SELECT MIN(results.fastestLapTime) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.name = 'Austrian Grand Prix')\n#SQL: SELECT T2.duration FROM results AS T1 INNER JOIN pitStops AS T2 ON T1.raceId = T2.raceId WHERE T1.fastestLapTime = (SELECT MIN(T3.fastestLapTime) FROM results AS T3 INNER JOIN races AS T4 ON T3.raceId = T4.raceId WHERE T4.name = 'Austrian Grand Prix')\n```"
    ],
    "1319": [
        "```\n#reason: Analyze how to generate SQL based on the question. (format: the question wants to know which college the vice president of the Student Club is from, so the SQL SELECT will retrieve the college from the major table where the member's position is 'Vice President'.)\n#columns: major.college, member.position\n#values: vice president refers to member.position = 'Vice President'\n#SELECT: SELECT college refer to major.college\n#SQL-like: Show major.college WHERE member.position = 'Vice President'\n#SQL: SELECT T1.college FROM major AS T1 INNER JOIN member AS T2 ON T1.major_id = T2.link_to_major WHERE T2.position = 'Vice President'\n```"
    ],
    "506": [
        "```\n#reason: The question wants to calculate the percentage of cards with Japanese translation that are only available in non-foil. So the SQL SELECT will focus on summing the cards that meet these conditions and dividing them accordingly.\n#columns: set_translations.language, sets.isNonFoilOnly\n#values: 'Japanese translation' refers to set_translations.language = 'Japanese', 'in non-foil' refers to sets.isNonFoilOnly = 1\n#SELECT: SELECT percentage of Japanese non-foil in Japanese cards refer to (SUM(isNonFoilOnly = 1) * 100 / SUM(language = 'Japanese'))\n#SQL-like: Show (SUM(CASE WHEN sets.isNonFoilOnly = 1 THEN 1 ELSE 0 END) * 100 / COUNT(*)), WHERE set_translations.language = 'Japanese'\n#SQL: SELECT CAST(SUM(CASE WHEN sets.isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM set_translations AS T1 INNER JOIN sets AS T2 ON T1.setCode = T2.code WHERE T1.language = 'Japanese'\n```"
    ],
    "358": [
        "```\n#reason: The question wants to display the border color of the card \"Ancestor's Chosen\", so the SQL SELECT will retrieve the borderColor from the cards table where the name matches 'Ancestor''s Chosen'.\n#columns: cards.borderColor\n#values: name of card = 'Ancestor''s Chosen' refer to cards.name = 'Ancestor''s Chosen'\n#SELECT: border color refer to cards.borderColor\n#SQL-like: Show cards.borderColor, WHERE cards.name = 'Ancestor''s Chosen'\n#SQL: SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'\n```"
    ],
    "1346": [
        "```\n#reason: The question wants to display the \"phone number\" of \"Carlo Jacobs\", so the SQL SELECT will retrieve the member's phone number based on the filtering condition of the full name.\n#columns: member.phone\n#values: 'Carlo Jacobs' refer to member.first_name = 'Carlo' AND member.last_name = 'Jacobs'\n#SELECT: phone number refer to member.phone\n#SQL-like: Show member.phone, WHERE member.first_name = 'Carlo' AND member.last_name = 'Jacobs'\n#SQL: SELECT T1.phone FROM member AS T1 WHERE T1.first_name = 'Carlo' AND T1.last_name = 'Jacobs'\n```"
    ],
    "1292": [
        "```\n#reason: The question want to retrieve the anti Cardiolipin antibody concentrations of the highest uric acid level among female patients, so the SQL SELECT will retrieve `aCL IgG`, `aCL IgM`, `aCL IgA` for the patient with the maximum uric acid level.\n#columns: Laboratory.IGA, Laboratory.IGG, Laboratory.IGM, Laboratory.UA, Patient.SEX\n#values: female patient refers to Patient.SEX = 'F'; highest uric acid level in the normal range refers to Laboratory.UA > 6.50\n#SELECT: SELECT `aCL IgG`, `aCL IgM`, `aCL IgA` refer to `aCL IgG`, `aCL IgM`, `aCL IgA`\n#SQL-like: Show `aCL IgG`, `aCL IgM`, `aCL IgA` WHERE Patient.SEX = 'F' AND Laboratory.UA > 6.50 ORDER BY Laboratory.UA DESC LIMIT 1\n#SQL: SELECT T3.`aCL IgG`, T3.`aCL IgM`, T3.`aCL IgA` FROM Laboratory AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T2.SEX = 'F' AND T1.UA > 6.50 ORDER BY T1.UA DESC LIMIT 1\n```"
    ],
    "625": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of users from New York, so the SQL SELECT will count the users where the location is New York.\n#columns: users.Location\n#values: 'New York' refers to users.Location = 'New York'\n#SELECT: SELECT COUNT(*) refer to users.Location\n#SQL-like: Show COUNT(*), WHERE users.Location = 'New York'\n#SQL: SELECT COUNT(*) FROM users WHERE Location = 'New York'\n```"
    ],
    "545": [
        "```\n#reason: The question wants to know how many posts are owned by the user \"csgillespie\" and are root posts, so the SQL SELECT will count the posts where the OwnerDisplayName is 'csgillespie' and ParentId is NULL.\n#columns: posts.OwnerDisplayName, posts.ParentId\n#values: 'csgillespie' refer to posts.OwnerDisplayName = 'csgillespie', root post refer to posts.ParentId IS NULL\n#SELECT: How many posts refer to COUNT(posts.Id)\n#SQL-like: Show COUNT(posts.Id), WHERE posts.OwnerDisplayName = 'csgillespie' AND posts.ParentId IS NULL\n#SQL: SELECT COUNT(Id) FROM posts WHERE OwnerDisplayName = 'csgillespie' AND ParentId IS NULL\n```"
    ],
    "383": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count how many cards are banned and have a white border, so the SQL SELECT will count the cards where the status is 'Banned' and the border color is 'white'.\n#columns: cards.borderColor, legalities.status\n#values: banned card refers to status = 'Banned', white border refers to borderColor = 'white'\n#SELECT: SELECT COUNT(*) refer to cards.id\n#SQL-like: Show COUNT(*), WHERE legalities.status = 'Banned' AND cards.borderColor = 'white'\n#SQL: SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'\n```"
    ],
    "1176": [
        "```\n#reason: The question wants to display the anti-nucleus antibody concentration level for a specific patient on a specific date, so the SQL SELECT will retrieve the Examination.ANA for the patient with the given ID on the specified Examination Date.\n#columns: Examination.ANA\n#values: patient id 3605340 refers to Examination.ID = 3605340, 1996/12/2 refers to Examination.`Examination Date` = '1996-12-02'\n#SELECT: SELECT anti-nucleus antibody concentration level refers to Examination.ANA\n#SQL-like: Show Examination.ANA WHERE Examination.ID = 3605340 AND Examination.`Examination Date` = '1996-12-02'\n#SQL: SELECT T1.ANA FROM Examination AS T1 WHERE T1.ID = 3605340 AND T1.`Examination Date` = '1996-12-02'\n```"
    ],
    "1128": [
        "```\n#reason: The question wants to identify \"which country's players have the heaviest average weights\", so the SQL SELECT will calculate the average weight for each country and find the maximum of those averages.\n#columns: Country.name, Player.weight\n#values: heaviest average weights refers to MAX(AVG(Player.weight)) over groups of countries.\n#SELECT: SELECT Country.name refer to Country.name and AVG(Player.weight) refer to AVG(Player.weight).\n#SQL-like: Show Country.name, AVG(Player.weight), GROUP BY Country.name, ORDER BY AVG(Player.weight) DESC LIMIT 1\n#SQL: SELECT T1.name FROM Country AS T1 INNER JOIN Player AS T2 ON T1.id = T2.player_api_id GROUP BY T1.name ORDER BY AVG(T2.weight) DESC LIMIT 1\n```"
    ],
    "1087": [
        "```\n#reason: The question wants to determine the count of players whose height is over 180 and have a volley score of over 70, so the SQL SELECT will count the distinct player IDs that meet these conditions.\n#columns: Player.id, Player.height, Player_Attributes.volleys\n#values: height > 180 refers to Player.height > 180, volleys > 70 refers to Player_Attributes.volleys > 70\n#SELECT: how many players refer to COUNT(DISTINCT Player.id)\n#SQL-like: Show COUNT(DISTINCT Player.id), WHERE Player.height > 180 AND Player_Attributes.volleys > 70\n#SQL: SELECT COUNT(DISTINCT T1.id) FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T1.height > 180 AND T2.volleys > 70\n```"
    ],
    "1167": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the average number of male patients tested in the lab each month for the year 1998, so the SQL SELECT will include the count of IDs divided by 12 after applying the necessary filters.\n#columns: Laboratory.ID, Patient.SEX\n#values: 'male' refers to Patient.SEX = 'M', 'the year that concluded on December 31, 1998' refers to Laboratory.Date BETWEEN '1998-01-01' AND '1998-12-31'\n#SELECT: average number of male patients refer to DIVIDE(COUNT(ID), 12)\n#SQL-like: Show DIVIDE(COUNT(Laboratory.ID), 12), WHERE Patient.SEX = 'M' AND Laboratory.Date BETWEEN '1998-01-01' AND '1998-12-31'\n#SQL: SELECT CAST(COUNT(Laboratory.ID) AS REAL) / 12 FROM Laboratory INNER JOIN Patient ON Laboratory.ID = Patient.ID WHERE Patient.SEX = 'M' AND Laboratory.Date BETWEEN '1998-01-01' AND '1998-12-31'\n```"
    ],
    "1492": [
        "```\n#reason: The question wants to calculate the percentage of KAM customers who pay in euros, so the SQL SELECT will count the KAM customers who use Euro and divide it by the total number of KAM customers, then multiply by 100.\n#columns: customers.Currency, customers.Segment\n#values: 'KAM customers' refer to customers.Segment = 'KAM', 'pay in euros' refer to customers.Currency = 'EUR'\n#SELECT: SELECT (COUNT(CASE WHEN customers.Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*)) refer to (Total of KAM uses Euro / Total of KAM) * 100\n#SQL-like: Show (COUNT(CASE WHEN customers.Currency = 'EUR' THEN 1 END) * 100.0 / COUNT(*)) WHERE customers.Segment = 'KAM'\n#SQL: SELECT CAST(COUNT(CASE WHEN Currency = 'EUR' THEN 1 END) AS REAL) * 100 / COUNT(*) FROM customers WHERE Segment = 'KAM'\n```"
    ],
    "530": [
        "```\n#reason: The question wants to list all the frame styles and cards Allen Williams worked on and find any banned cards if there are any, so the SQL SELECT will include frameVersion, cards.name, and legalities.status with filtering conditions for artist and status.\n#columns: cards.frameVersion, cards.name, legalities.status\n#values: artist is 'Allen Williams' refer to cards.artist = 'Allen Williams', status is 'Banned' refer to legalities.status = 'Banned'\n#SELECT: SELECT frameVersion, name, status refer to cards.frameVersion, cards.name, legalities.status\n#SQL-like: Show cards.frameVersion, cards.name, legalities.status, WHERE cards.artist = 'Allen Williams' AND legalities.status = 'Banned'\n#SQL: SELECT cards.frameVersion, cards.name, legalities.status FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.artist = 'Allen Williams' AND legalities.status = 'Banned'\n```"
    ],
    "464": [
        "```\n#reason: The question wants to list the names of the cards in the set \"Hauptset Zehnte Edition\", so the SQL SELECT will retrieve the card names filtered by the set translation.\n#columns: cards.name\n#values: 'Hauptset Zehnte Edition' refer to set_translations.translation = 'Hauptset Zehnte Edition'\n#SELECT: SELECT cards.name\n#SQL-like: Show cards.name, WHERE set_translations.translation = 'Hauptset Zehnte Edition'\n#SQL: SELECT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T1.setCode = T2.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'\n```"
    ],
    "1410": [
        "```\n#reason: The question wants to display the full name and total cost incurred by the member with ID \"rec4BLdZHS2Blfp4v\", so the SQL SELECT will gather the first_name and last_name from the member table, and the total cost from the expense table, filtered by the provided member ID.\n#columns: member.first_name, member.last_name, expense.cost\n#values: member id \"rec4BLdZHS2Blfp4v\" refer to member.member_id = 'rec4BLdZHS2Blfp4v'\n#SELECT: full name refers to member.first_name, member.last_name, total cost refers to SUM(expense.cost)\n#SQL-like: Show member.first_name, member.last_name, SUM(expense.cost), WHERE expense.link_to_member = 'rec4BLdZHS2Blfp4v'\n#SQL: SELECT T1.first_name, T1.last_name, SUM(T2.cost) FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T1.member_id = 'rec4BLdZHS2Blfp4v'\n```"
    ],
    "394": [
        "```\n#reason: The question wants to count the number of cards that have a white border and are powerful, where white bordered cards refer to borderColor = 'white' and powerful cards are those where cardKingdomFoilId is not null AND cardKingdomId is not null.\n#columns: cards.id, cards.borderColor, cards.cardKingdomFoilId, cards.cardKingdomId\n#values: 'white bordered cards' refer to cards.borderColor = 'white', 'powerful cards' refer to cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SELECT: SELECT COUNT(cards.id) refer to cards.id\n#SQL-like: Show COUNT(cards.id), WHERE cards.borderColor = 'white' AND cards.cardKingdomFoilId IS NOT NULL AND cards.cardKingdomId IS NOT NULL\n#SQL: SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL\n```"
    ],
    "985": [
        "```\n#reason: The question wants to identify the driver with the slowest time in the 3rd lap of the French Grand Prix, so the SQL SELECT will retrieve the maximum lap time for the 3rd lap, along with the driver's identification.\n#columns: lapTimes.driverId, lapTimes.time\n#values: Participated in the 'French Grand Prix' refers to races.name = 'French Grand Prix' and lap number is 3 refers to lapTimes.lap = 3.\n#SELECT: slowest time refers to Max(time) and the driver identification refers to lapTimes.driverId.\n#SQL-like: Show lapTimes.driverId, MAX(lapTimes.time), WHERE races.name = 'French Grand Prix' AND lapTimes.lap = 3 GROUP BY lapTimes.driverId ORDER BY MAX(lapTimes.time) DESC LIMIT 1\n#SQL: SELECT T1.driverId, MAX(T1.time) FROM lapTimes AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.name = 'French Grand Prix' AND T1.lap = 3 GROUP BY T1.driverId ORDER BY MAX(T1.time) DESC LIMIT 1\n```"
    ],
    "57": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to retrieve the phone number and extension number for the school with the 333rd highest average writing score, which refers to ordering the average writing scores in descending order and limiting the result to 1 to get the school at that rank.\n#columns: schools.Phone, schools.Ext, satscores.AvgScrWrite\n#values: 333rd highest average writing score refers to \"satscores.AvgScrWrite\" ordered in descending order and limited to that rank.\n#SELECT: SELECT phone number and extension number refer to schools.Phone, schools.Ext\n#SQL-like: Show schools.Phone, schools.Ext, ORDER BY satscores.AvgScrWrite DESC LIMIT 1 OFFSET 332\n#SQL: SELECT T1.Phone, T1.Ext FROM schools AS T1 INNER JOIN satscores AS T2 ON T1.CDSCode = T2.cds ORDER BY T2.AvgScrWrite DESC LIMIT 1 OFFSET 332\n```"
    ],
    "274": [
        "```\n#reason: The question wants to list the toxicology elements associated with a specific molecule, so the SQL SELECT will retrieve the elements from the atom table where the molecule_id matches 'TR001'.\n#columns: atom.element\n#values: 'TR001' refer to atom.molecule_id = 'TR001'\n#SELECT: SELECT atom.element refer to atom.element\n#SQL-like: Show atom.element, WHERE atom.molecule_id = 'TR001'\n#SQL: SELECT T1.element FROM atom AS T1 WHERE T1.molecule_id = 'TR001'\n```"
    ],
    "808": [
        "```\n#reason: The question wants to find the race of the superhero who weighs 108kg and is 188cm tall, so the SQL SELECT will filter based on weight_kg and height_cm.\n#columns: race.race, superhero.weight_kg, superhero.height_cm\n#values: weighs 108kg refers to superhero.weight_kg = 108, 188cm tall refers to superhero.height_cm = 188\n#SELECT: SELECT race.race\n#SQL-like: Show race.race WHERE superhero.weight_kg = 108 AND superhero.height_cm = 188\n#SQL: SELECT T1.race FROM race AS T1 INNER JOIN superhero AS T2 ON T1.id = T2.race_id WHERE T2.weight_kg = 108 AND T2.height_cm = 188\n```"
    ],
    "403": [
        "```\n#reason: The question wants to calculate the percentage of cards in Spanish, so the SQL SELECT will count the IDs of cards where the foreign language is 'Spanish' and divide by the total count of card IDs, multiplied by 100 to get the percentage.\n#columns: foreign_data.language, cards.name, cards.id\n#values: 'Spanish' refer to foreign_data.language = 'Spanish'\n#SELECT: SELECT DIVIDE(SUM(CASE WHEN foreign_data.language = 'Spanish' THEN 1 ELSE 0 END), COUNT(cards.id)) * 100 as percentage, cards.name refer to cards.name\n#SQL-like: Show DIVIDE(SUM(CASE WHEN foreign_data.language = 'Spanish' THEN 1 ELSE 0 END), COUNT(cards.id)) * 100, WHERE foreign_data.language = 'Spanish'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T2.id) FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T1.uuid = T2.uuid\n```"
    ],
    "1159": [
        "```\n#reason: The question wants to list the ID, sex, and diagnosis of patients with an albumin level lower than 3.5, so the SQL SELECT will include the relevant columns from the Patient and Laboratory tables, applying the filter for albumin level.\n#columns: Patient.ID, Patient.SEX, Patient.Diagnosis\n#values: albumin level lower than 3.5 refers to Laboratory.ALB < 3.5\n#SELECT: ID refer to Patient.ID, sex refer to Patient.SEX, diagnosis refer to Patient.Diagnosis\n#SQL-like: Show Patient.ID, Patient.SEX, Patient.Diagnosis WHERE Laboratory.ALB < 3.5\n#SQL: SELECT P.ID, P.SEX, P.Diagnosis FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID WHERE L.ALB < 3.5\n```"
    ],
    "409": [
        "```\n#reason: The question wants to count the number of cards with pre-modern format and a specific ruling text while ensuring that these cards do not have multiple faces. Therefore, the SQL SELECT will count the cards that meet these criteria.\n#columns: COUNT(cards.id)\n#values: format = 'premodern' refers to legalities.format = 'premodern', ruling text \"This is a triggered mana ability.\" refers to rulings.text = 'This is a triggered mana ability.', do not have multiple faces refers to cards.side IS NULL\n#SELECT: COUNT(cards.id) refer to COUNT(cards.id)\n#SQL-like: Show COUNT(cards.id), WHERE legalities.format = 'premodern' AND rulings.text = 'This is a triggered mana ability.' AND cards.side IS NULL\n#SQL: SELECT COUNT(cards.id) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid INNER JOIN rulings ON cards.uuid = rulings.uuid WHERE legalities.format = 'premodern' AND rulings.text = 'This is a triggered mana ability.' AND cards.side IS NULL\n```"
    ],
    "1443": [
        "```\n#reason: The question wants to display the event ID, location, and status of events conducted from November 2019 to March 2020, so the SQL SELECT will filter events based on the event_date.\n#columns: event.event_id, event.location, event.status\n#values: events conducted from November 2019 to March 2020 refer to event.event_date BETWEEN '2019-11-01' and '2020-03-31'\n#SELECT: event ID, location, and status refer to event.event_id, event.location, event.status\n#SQL-like: Show event.event_id, event.location, event.status WHERE event.event_date BETWEEN '2019-11-01' and '2020-03-31'\n#SQL: SELECT event_id, location, status FROM event WHERE event_date BETWEEN '2019-11-01' and '2020-03-31'\n```"
    ],
    "1439": [
        "```\n#reason: The question wants to list the phone numbers of members who majored in business at the College of Agriculture and Applied Sciences, so the SQL SELECT will include the phone numbers and filter based on the college and major.\n#columns: member.phone, major.major_name, major.college\n#values: 'College of Agriculture and Applied Sciences' refers to major.college = 'College of Agriculture and Applied Sciences', 'majored in business' refers to major.major_name = 'Business'\n#SELECT: SELECT member.phone\n#SQL-like: Show member.phone WHERE major.college = 'College of Agriculture and Applied Sciences' AND major.major_name = 'Business'\n#SQL: SELECT T1.phone FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.college = 'College of Agriculture and Applied Sciences' AND T2.major_name = 'Business'\n```"
    ],
    "1026": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify \"which home team\" had \"lost the fewest matches\" in the \"2016 season\". The filter for lost matches refers to a condition where home_team_goal is less than away_team_goal. The season filter restricts the results to matches from the 2016 season (2015/2016).\n#columns: Match.home_team_api_id, Match.home_team_goal, Match.away_team_goal\n#values: 2016 season refers to Match.season = '2015/2016' and home team lost the matches refers to \"home_team_goal < away_team_goal\"\n#SELECT: SELECT content refer to Match.home_team_api_id \n#SQL-like: Show Match.home_team_api_id, WHERE Match.season = '2015/2016' AND Match.home_team_goal < Match.away_team_goal GROUP BY Match.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1\n#SQL: SELECT Match.home_team_api_id FROM Match WHERE Match.season = '2015/2016' AND Match.home_team_goal < Match.away_team_goal GROUP BY Match.home_team_api_id ORDER BY COUNT(*) ASC LIMIT 1\n```"
    ],
    "768": [
        "```\n#reason: The question wants to determine \"How many superheroes\" and focuses on those \"published by Dark Horse Comics.\" \n#columns: superhero.publisher_id, superhero.id\n#values: 'Dark Horse Comics' refers to publisher.publisher_name = 'Dark Horse Comics'\n#SELECT: SELECT COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE publisher.publisher_name = 'Dark Horse Comics'\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Dark Horse Comics'\n```"
    ],
    "1415": [
        "```\n#reason: The question wants to list out the position of members who joined the major of Business, so the SQL SELECT will retrieve member.position based on the criteria that their major is Business.\n#columns: member.position, major.major_name\n#values: 'Business' refer to major.major_name = 'Business'\n#SELECT: SELECT member.position refer to member.position\n#SQL-like: Show member.position WHERE major.major_name = 'Business'\n#SQL: SELECT T1.position FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.major_name = 'Business'\n```"
    ],
    "639": [
        "```\n#reason: The question requires calculating the percentage of posts that use the R language based on posts made by the user \"Community\". The SQL SELECT must count posts with the tag 'r' and divide it by the total posts made by the user 'Community'.\n#columns: tags.TagName, posts.OwnerDisplayName, posts.Id\n#values: 'posts posted by Community' refer to posts.OwnerDisplayName = 'Community', 'use the R language' refer to tags.TagName = 'r'\n#SELECT: SELECT DIVIDE(COUNT(PostId WHERE TagName = 'r'), COUNT(PostId WHERE DisplayName = 'Community')) as percentage\n#SQL-like: Show DIVIDE(COUNT(PostId WHERE TagName = 'r'), COUNT(PostId WHERE DisplayName = 'Community')) as percentage WHERE tags.TagName = 'r' AND posts.OwnerDisplayName = 'Community'\n#SQL: SELECT CAST(COUNT(CASE WHEN T1.TagName = 'r' THEN 1 END) AS REAL) * 100 / COUNT(CASE WHEN T2.OwnerDisplayName = 'Community' THEN 1 END) FROM tags AS T1 INNER JOIN posts AS T2 ON T1.ExcerptPostId = T2.Id\n```"
    ],
    "914": [
        "```\n#reason: The question wants to determine how many drivers don't have a code, which means the code column is null.\n#columns: drivers.code\n#values: code is null refer to drivers.code IS NULL\n#SELECT: How many drivers refer to COUNT(*)\n#SQL-like: Show COUNT(*), WHERE drivers.code IS NULL\n#SQL: SELECT COUNT(*) FROM drivers WHERE drivers.code IS NULL\n```"
    ],
    "1375": [
        "```\n#reason: The question wants to list all the members of the \"School of Applied Sciences, Technology and Education\" department, so the SQL SELECT will get the full names of all members whose major is in that department.\n#columns: member.first_name, member.last_name\n#values: \"School of Applied Sciences, Technology and Education\" refer to major.department = 'School of Applied Sciences, Technology and Education'\n#SELECT: SELECT member.first_name, member.last_name \n#SQL-like: Show member.first_name, member.last_name, WHERE major.department = 'School of Applied Sciences, Technology and Education'\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN major AS T2 ON T1.link_to_major = T2.major_id WHERE T2.department = 'School of Applied Sciences, Technology and Education'\n```"
    ],
    "908": [
        "```\n#reason: The question requires displaying \"the most laps\" of f1 races, which refers to the maximum value of the laps column, while also displaying the associated race name, year, and circuit location. So the SQL SELECT will gather the laps along with the respective race's name, year, and the location of the circuit.\n#columns: results.laps, races.name, races.year, circuits.location\n#values: No specific values are filtering, but we need to find the maximum laps in relation to their race.\n#SELECT: SELECT results.laps, races.name, races.year, circuits.location\n#SQL-like: Show results.laps, races.name, races.year, circuits.location, ORDER BY results.laps DESC LIMIT 1\n#SQL: SELECT T1.laps, T2.name, T2.year, T3.location FROM results AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId INNER JOIN circuits AS T3 ON T2.circuitId = T3.circuitId ORDER BY T1.laps DESC LIMIT 1\n```"
    ],
    "875": [
        "```\n#reason: The question wants to display \"the season page\" along with \"year\" when the race No. 901 took place. Hence, the SQL SELECT will target the columns for \"season page\" and \"year\" from the relevant tables where the race ID matches 901.\n#columns: seasons.url, races.year\n#values: race number 901 refers to races.raceId = 901\n#SELECT: SELECT seasons.url, races.year\n#SQL-like: Show seasons.url, races.year WHERE races.raceId = 901\n#SQL: SELECT seasons.url, races.year FROM races INNER JOIN seasons ON races.year = seasons.year WHERE races.raceId = 901\n```"
    ],
    "1294": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to list the patient's ID whose creatinine level is normal and whose anti Cardiolipin antibody concentration level is the highest, so the SQL SELECT will include the patient ID and apply the necessary filters.\n#columns: Patient.ID, Examination.`aCL IgA`, Laboratory.CRE\n#values: creatinine level is normal refers to Laboratory.CRE < 1.5, anti Cardiolipin antibody concentration level is the highest refers to MAX(Examination.`aCL IgA`)\n#SELECT: SELECT Patient.ID refer to Patient.ID\n#SQL-like: Show Patient.ID, WHERE Laboratory.CRE < 1.5 AND Examination.`aCL IgA` = (SELECT MAX(Examination.`aCL IgA`) FROM Examination INNER JOIN Patient ON Examination.ID = Patient.ID WHERE Laboratory.CRE < 1.5)\n#SQL: SELECT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T3.CRE < 1.5 AND T2.`aCL IgA` = (SELECT MAX(`aCL IgA`) FROM Examination WHERE ID IN (SELECT ID FROM Laboratory WHERE CRE < 1.5))\n```"
    ],
    "920": [
        "```\n#reason: The question wants to list all the years that Silverstone Circuit was used in a Formula 1 race, so the SQL SELECT will retrieve distinct years from the races table where the circuitId corresponds to Silverstone Circuit.\n#columns: races.year\n#values: 'Silverstone Circuit' refers to circuits.name = 'Silverstone Circuit'\n#SELECT: SELECT DISTINCT races.year\n#SQL-like: Show DISTINCT races.year, WHERE races.circuitId IN (SELECT circuits.circuitId FROM circuits WHERE circuits.name = 'Silverstone Circuit')\n#SQL: SELECT DISTINCT T1.year FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.name = 'Silverstone Circuit'\n```"
    ],
    "1365": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find \"the expenses of the budget with the lowest remaining\", so the SQL SELECT will focus on the expense_description from the Expense table, filtered by the budget with the minimum remaining value.\n#columns: expense.expense_description, budget.remaining\n#values: lowest remaining refers to MIN(budget.remaining)\n#SELECT: SELECT expense.expense_description refer to expense.expense_description\n#SQL-like: Show expense.expense_description, WHERE budget.remaining is the smallest (ORDER BY budget.remaining LIMIT 1)\n#SQL: SELECT T1.expense_description FROM Expense AS T1 INNER JOIN Budget AS T2 ON T1.link_to_budget = T2.budget_id ORDER BY T2.remaining ASC LIMIT 1\n```"
    ],
    "1317": [
        "```\n#reason: The question wants to determine how many students attended the event \"Women's Soccer\" and want a T-shirt that's in medium size, so the SQL SELECT will count the members who meet both conditions.\n#columns: attendance.link_to_member, event.event_name, member.t_shirt_size\n#values: \"Women's Soccer\" refers to event.event_name = 'Women''s Soccer', medium size refers to member.t_shirt_size = 'Medium'\n#SELECT: how many students refer to COUNT(attendance.link_to_member)\n#SQL-like: Show COUNT(attendance.link_to_member), WHERE event.event_name = 'Women''s Soccer' AND member.t_shirt_size = 'Medium'\n#SQL: SELECT COUNT(attendance.link_to_member) FROM attendance INNER JOIN event ON attendance.link_to_event = event.event_id INNER JOIN member ON attendance.link_to_member = member.member_id WHERE event.event_name = 'Women''s Soccer' AND member.t_shirt_size = 'Medium'\n```"
    ],
    "1460": [
        "```\n#reason: The question wants to display the \"full name of the member\" who spent money for \"water, veggie tray and supplies\" and include the \"cost of it\". The full name is defined as first_name and last_name, and the expense description is a filtering condition.\n#columns: member.first_name, member.last_name, expense.cost\n#values: 'spent money for water, veggie tray and supplies' refer to expense.expense_description = 'Water, Veggie tray, supplies'\n#SELECT: SELECT member.first_name, member.last_name, expense.cost refer to member.first_name, member.last_name, expense.cost\n#SQL-like: Show member.first_name, member.last_name, expense.cost WHERE expense.expense_description = 'Water, Veggie tray, supplies'\n#SQL: SELECT T1.first_name, T1.last_name, T2.cost FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member WHERE T2.expense_description = 'Water, Veggie tray, supplies'\n```"
    ],
    "933": [
        "```\n#reason: The question wants to determine Lewis Hamilton's final rank, so the SQL SELECT will retrieve the positionOrder from results where the driver's full name matches and the race name is 'Chinese Grand Prix'.\n#columns: results.positionOrder, drivers.forename, drivers.surname, races.name\n#values: 'Lewis Hamilton' refers to 'drivers.forename = \"Lewis\" AND drivers.surname = \"Hamilton\"', 'Chinese Grand Prix' refers to 'races.name = \"Chinese Grand Prix\"'\n#SELECT: SELECT results.positionOrder refer to results.positionOrder\n#SQL-like: Show results.positionOrder, WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND races.name = 'Chinese Grand Prix'\n#SQL: SELECT R.positionOrder FROM results AS R INNER JOIN drivers AS D ON R.driverId = D.driverId INNER JOIN races AS RA ON R.raceId = RA.raceId WHERE D.forename = 'Lewis' AND D.surname = 'Hamilton' AND RA.name = 'Chinese Grand Prix'\n```"
    ],
    "1488": [
        "```\n#reason: The question wants to find out the customer who belongs to the KAM segment and has the highest consumption, so the SQL SELECT will return the customer details and consumption amount.\n#columns: customers.CustomerID, yearmonth.Consumption\n#values: KAM customers refer to customers.Segment = 'KAM'\n#SELECT: SELECT customer ID, consumption refers to customers.CustomerID, yearmonth.Consumption\n#SQL-like: Show customers.CustomerID, yearmonth.Consumption WHERE customers.Segment = 'KAM' ORDER BY yearmonth.Consumption DESC LIMIT 1\n#SQL: SELECT T1.CustomerID, T2.Consumption FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T1.Segment = 'KAM' ORDER BY T2.Consumption DESC LIMIT 1\n```"
    ],
    "883": [
        "```\n#reason: The question requires displaying \"How many races\" and \"name all the races in descending order\". \"in 2005\" is a filtering condition.\n#columns: races.raceId, races.name\n#values: 2005 refers to races.year = 2005\n#SELECT: How many races refers to COUNT(races.raceId), and name all the races refers to races.name\n#SQL-like: Show COUNT(races.raceId), races.name WHERE races.year = 2005 ORDER BY races.name DESC\n#SQL: SELECT COUNT(raceId), name FROM races WHERE year = 2005 ORDER BY name DESC\n```"
    ],
    "164": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to display the \"client\" who placed the order with the specific \"order id 32423\". \n#columns: order.account_id, account.account_id, disp.client_id, client.client_id\n#values: order_id = 32423 refers to order.order_id = 32423\n#SELECT: SELECT client.client_id refer to client.client_id \n#SQL-like: Show client.client_id WHERE order.order_id = 32423\n#SQL: SELECT T1.client_id FROM order AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id INNER JOIN client AS T3 ON T2.client_id = T3.client_id WHERE T1.order_id = 32423\n```"
    ],
    "1408": [
        "```\n#reason: The question wants to calculate the total cost spent for Parking, so the SQL SELECT will sum the cost where the expense description is 'Parking'.\n#columns: expense.cost, expense.expense_description\n#values: 'Parking' refers to expense.expense_description = 'Parking'\n#SELECT: SELECT SUM(cost) refer to expense.cost\n#SQL-like: Show SUM(cost) WHERE expense.expense_description = 'Parking'\n#SQL: SELECT SUM(cost) FROM expense WHERE expense_description = 'Parking'\n```"
    ],
    "930": [
        "```\n#reason: The question wants to identify the Formula 1 race in which Lewis Hamilton ranked the highest, so the SQL SELECT will find the race with the minimum rank for Lewis Hamilton.\n#columns: races.name, results.rank\n#values: Lewis Hamilton refers to drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton', rank the highest refers to results.rank = (SELECT MIN(rank) FROM results INNER JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton')\n#SELECT: SELECT races.name, results.rank\n#SQL-like: Show races.name, WHERE results.rank = (SELECT MIN(rank) FROM results INNER JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton')\n#SQL: SELECT T1.name, T2.rank FROM races AS T1 INNER JOIN results AS T2 ON T1.raceId = T2.raceId INNER JOIN drivers AS T3 ON T2.driverId = T3.driverId WHERE T3.forename = 'Lewis' AND T3.surname = 'Hamilton' AND T2.rank = (SELECT MIN(rank) FROM results AS T4 INNER JOIN drivers AS T5 ON T4.driverId = T5.driverId WHERE T5.forename = 'Lewis' AND T5.surname = 'Hamilton')\n```"
    ],
    "1301": [
        "```\n#reason: The question wants to list the \"IDs of the patients\" with the conditions \"no thrombosis\" and \"an abnormal level of creatinine phosphokinase\". \"No thrombosis\" refers to Thrombosis = 0, and \"abnormal level of creatinine phosphokinase\" refers to CPK < 250.\n#columns: Patient.ID, Laboratory.CPK, Examination.Thrombosis\n#values: no thrombosis refers to Examination.Thrombosis = 0, abnormal level of creatinine phosphokinase refers to Laboratory.CPK < 250\n#SELECT: IDs of the patients refer to Patient.ID\n#SQL-like: Show Patient.ID WHERE Examination.Thrombosis = 0 AND Laboratory.CPK < 250\n#SQL: SELECT T1.ID FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T1.ID = T3.ID WHERE T2.Thrombosis = 0 AND T3.CPK < 250\n```"
    ],
    "176": [
        "```\n#reason: The question wants to find out the amount of debt for a specific client and their payment status, so the SQL SELECT will retrieve the debt amount and the payment status for client number 992.\n#columns: loan.amount, loan.status\n#values: client number 992 refers to loan.account_id = (SELECT account_id FROM client WHERE client_id = 992)\n#SELECT: the amount of debt and payment status refer to loan.amount, loan.status\n#SQL-like: Show loan.amount, loan.status WHERE loan.account_id = (SELECT account_id FROM client WHERE client_id = 992)\n#SQL: SELECT loan.amount, loan.status FROM loan INNER JOIN client ON loan.account_id = client.account_id WHERE client.client_id = 992\n```"
    ],
    "473": [
        "```\n#reason: The question wants to determine if the card set \"Adarkar Valkyrie\" is only available outside the United States, so the SQL SELECT will check the name of the card and the availability condition.\n#columns: sets.name, sets.isForeignOnly\n#values: 'Adarkar Valkyrie' refers to sets.name = 'Adarkar Valkyrie', isForeignOnly = 1 means sets.isForeignOnly = 1\n#SELECT: SELECT name, isForeignOnly refer to sets.name, sets.isForeignOnly\n#SQL-like: Show sets.name, sets.isForeignOnly WHERE sets.name = 'Adarkar Valkyrie' AND sets.isForeignOnly = 1\n#SQL: SELECT name, isForeignOnly FROM sets WHERE name = 'Adarkar Valkyrie' AND isForeignOnly = 1\n```"
    ],
    "1247": [
        "```\n#reason: The question wants to determine the count of male patients with a normal level of white blood cells who also have an abnormal fibrinogen level. Therefore, the SQL SELECT will count distinct patients where the conditions for sex, WBC, and fibrinogen are met.\n#columns: Patient.SEX, Laboratory.WBC, Laboratory.FG\n#values: male patients refer to Patient.SEX = 'M', normal level of white blood cells refer to Laboratory.WBC > 3.5 AND Laboratory.WBC < 9.0, abnormal fibrinogen level refer to Laboratory.FG <= 150 OR Laboratory.FG >= 450\n#SELECT: how many male patients with an abnormal fibrinogen level refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.SEX = 'M' AND Laboratory.WBC > 3.5 AND Laboratory.WBC < 9.0 AND (Laboratory.FG <= 150 OR Laboratory.FG >= 450)\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.SEX = 'M' AND T2.WBC > 3.5 AND T2.WBC < 9.0 AND (T2.FG <= 150 OR T2.FG >= 450)\n```"
    ],
    "859": [
        "```\n#reason: The question wants to display \"Bruno Senna's Q1 result\" in the qualifying race No. 354, so the SQL SELECT will include the Q1 result from the qualifying table filtered by the race ID and the driver's full name.\n#columns: qualifying.q1, drivers.forename, drivers.surname\n#values: race number 354 refers to qualifying.raceId = 354; Bruno Senna refers to drivers.forename = 'Bruno' AND drivers.surname = 'Senna'\n#SELECT: Q1 result refers to qualifying.q1\n#SQL-like: Show qualifying.q1, WHERE qualifying.raceId = 354 AND drivers.forename = 'Bruno' AND drivers.surname = 'Senna'\n#SQL: SELECT T1.q1 FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T1.driverId = T2.driverId WHERE T1.raceId = 354 AND T2.forename = 'Bruno' AND T2.surname = 'Senna'\n```"
    ],
    "1339": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the total average cost that Elijah Allen spent in the events on September and October. \"total average cost\" refers to the average of all expenses, and \"events in September and October\" means we need to filter based on the month of the expense date being either 9 or 10. Additionally, \"Elijah Allen\" refers to filtering by the member's first and last name.\n#columns: expense.cost, member.first_name, member.last_name, expense.expense_date\n#values: \"events in September and October\" refer to strftime('%m', expense.expense_date) = '09' OR strftime('%m', expense.expense_date) = '10' and \"Elijah Allen\" refers to member.first_name = 'Elijah' AND member.last_name = 'Allen'\n#SELECT: SELECT total average cost refer to AVG(expense.cost)\n#SQL-like: Show AVG(expense.cost), WHERE strftime('%m', expense.expense_date) = '09' OR strftime('%m', expense.expense_date) = '10' AND member.first_name = 'Elijah' AND member.last_name = 'Allen'\n#SQL: SELECT CAST(SUM(T1.cost) AS REAL) / COUNT(T1.expense_id) FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE strftime('%m', T1.expense_date) IN ('09', '10') AND T2.first_name = 'Elijah' AND T2.last_name = 'Allen'\n```"
    ],
    "119": [
        "```\n#reason: The question wants to list the account ID, district name, and district region for accounts in 1993 with statement issued after transaction, so the SQL SELECT will include account.account_id, district.A2, and district.A3, and the filtering conditions will be based on the year 1993 and the frequency 'POPLATEK PO OBRATU'.\n#columns: account.account_id, district.A2, district.A3\n#values: accounts in 1993 refer to STRFTIME('%Y', account.date) = '1993'; statement issued after transaction refers to account.frequency = 'POPLATEK PO OBRATU'\n#SELECT: account ID refers to account.account_id, district name refers to district.A2, district region refers to district.A3\n#SQL-like: Show account.account_id, district.A2, district.A3 WHERE STRFTIME('%Y', account.date) = '1993' AND account.frequency = 'POPLATEK PO OBRATU'\n#SQL: SELECT account.account_id, district.A2, district.A3 FROM account INNER JOIN district ON account.district_id = district.district_id WHERE STRFTIME('%Y', account.date) = '1993' AND account.frequency = 'POPLATEK PO OBRATU'\n```"
    ],
    "1115": [
        "```\n#reason: The question wants to calculate the percentage by which Landon Donovan's overall rating is higher than Jordan Bowery's. This requires finding the overall ratings for both players and comparing them. \n#columns: Player.player_name, Player_Attributes.overall_rating\n#values: 'Landon Donovan' refers to Player.player_name = 'Landon Donovan', 'Jordan Bowery' refers to Player.player_name = 'Jordan Bowery'\n#SELECT: percentage refers to (DIVIDE(SUBTRACT(Player_Attributes.overall_rating WHERE Player.player_name = 'Landon Donovan', Player_Attributes.overall_rating WHERE Player.player_name = 'Jordan Bowery'), Player_Attributes.overall_rating WHERE Player.player_name = 'Landon Donovan')) * 100\n#SQL-like: Show (DIVIDE(SUBTRACT(Player_Attributes.overall_rating WHERE Player.player_name = 'Landon Donovan', Player_Attributes.overall_rating WHERE Player.player_name = 'Jordan Bowery'), Player_Attributes.overall_rating WHERE Player.player_name = 'Landon Donovan')) * 100\n#SQL: SELECT CAST((SELECT p2.overall_rating FROM Player AS p2 INNER JOIN Player_Attributes AS pa2 ON p2.player_api_id = pa2.player_api_id WHERE p2.player_name = 'Landon Donovan') - (SELECT p1.overall_rating FROM Player AS p1 INNER JOIN Player_Attributes AS pa1 ON p1.player_api_id = pa1.player_api_id WHERE p1.player_name = 'Jordan Bowery') AS REAL) * 100 / (SELECT p2.overall_rating FROM Player AS p2 INNER JOIN Player_Attributes AS pa2 ON p2.player_api_id = pa2.player_api_id WHERE p2.player_name = 'Landon Donovan')\n```"
    ],
    "1009": [
        "```\n#reason: The question wants to list the time each driver spent at the pit stop during the 2011 Australian Grand Prix, so the SQL SELECT will be focused on the duration from the pitStops table and filtered by the specific race in 2011.\n#columns: pitStops.duration\n#values: 2011 Australian Grand Prix refers to races.year = 2011 and races.name = 'Australian Grand Prix'\n#SELECT: SELECT pitStops.duration\n#SQL-like: Show pitStops.duration, WHERE races.year = 2011 AND races.name = 'Australian Grand Prix'\n#SQL: SELECT T1.duration FROM pitStops AS T1 INNER JOIN races AS T2 ON T1.raceId = T2.raceId WHERE T2.year = 2011 AND T2.name = 'Australian Grand Prix'\n```"
    ],
    "1516": [
        "```\n#reason: The question wants to count the number of transactions paid in CZK on a specific date and time range, so the SQL SELECT will count the transactions where the currency is CZK and the date is '2012-08-26' with time before '13:00:00'.\n#columns: transactions_1k.CustomerID, transactions_1k.Amount, transactions_1k.Date, transactions_1k.Time\n#values: 'paid in CZK' refers to customers.Currency = 'CZK', 'in the morning of 2012/8/26' refers to transactions_1k.Date = '2012-08-26' AND transactions_1k.Time < '13:00:00'\n#SELECT: SELECT COUNT(transactions_1k.TransactionID) refer to transactions_1k.TransactionID\n#SQL-like: Show COUNT(transactions_1k.TransactionID), WHERE customers.Currency = 'CZK' AND transactions_1k.Date = '2012-08-26' AND transactions_1k.Time < '13:00:00'\n#SQL: SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN customers AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Currency = 'CZK' AND T1.Date = '2012-08-26' AND T1.Time < '13:00:00'\n```"
    ],
    "412": [
        "```\n#reason: The question wants to display the foreign name of the card in French that is of type Creature, has a normal layout, and has a black border color, so the SQL SELECT foreign_data.name and filters on foreign_data.language, cards.type, cards.layout, and cards.borderColor.\n#columns: foreign_data.name, cards.type, cards.layout, cards.borderColor, cards.artist\n#values: 'in French' refers to foreign_data.language = 'French', 'of type Creature' refers to cards.type = 'Creature', 'normal layout' refers to cards.layout = 'normal', 'black border color' refers to cards.borderColor = 'black', 'by artist Matthew D. Wilson' refers to cards.artist = 'Matthew D. Wilson'\n#SELECT: SELECT foreign_data.name\n#SQL-like: Show foreign_data.name WHERE foreign_data.language = 'French' AND cards.type = 'Creature' AND cards.layout = 'normal' AND cards.borderColor = 'black' AND cards.artist = 'Matthew D. Wilson'\n#SQL: SELECT foreign_data.name FROM foreign_data INNER JOIN cards ON foreign_data.uuid = cards.uuid WHERE foreign_data.language = 'French' AND cards.type = 'Creature' AND cards.layout = 'normal' AND cards.borderColor = 'black' AND cards.artist = 'Matthew D. Wilson'\n```"
    ],
    "729": [
        "```\n#reason: The question wants to find the average height of the superheroes from Marvel Comics, so the SQL SELECT will compute AVG(height_cm) and filter by publisher_name = 'Marvel Comics'.\n#columns: superhero.height_cm, publisher.publisher_name\n#values: 'superheroes from Marvel Comics' refer to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT AVG(height_cm) refer to superhero.height_cm\n#SQL-like: Show AVG(superhero.height_cm) WHERE publisher.publisher_name = 'Marvel Comics'\n#SQL: SELECT AVG(T1.height_cm) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'\n```"
    ],
    "593": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the count of users from 'New York' who have both 'Supporter' and 'Teacher' badges, so the SQL SELECT will return the count of users with the specified location and badges.\n#columns: badges.UserId, users.Location\n#values: 'New York' refers to users.Location = 'New York', 'Supporter' refers to badges.Name = 'Supporter', 'Teacher' refers to badges.Name = 'Teacher'\n#SELECT: SELECT COUNT(DISTINCT badges.UserId) \n#SQL-like: Show COUNT(DISTINCT badges.UserId) WHERE users.Location = 'New York' AND badges.Name IN ('Supporter', 'Teacher')\n#SQL: SELECT COUNT(DISTINCT T1.UserId) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Location = 'New York' AND T1.Name IN ('Supporter', 'Teacher')\n```"
    ],
    "794": [
        "```\n#reason: The question wants to find \"which hero was the fastest\", so the SQL SELECT will retrieve the superhero_name with the maximum attribute_value where the attribute_name is 'Speed'.\n#columns: superhero.superhero_name, hero_attribute.attribute_value, attribute.attribute_name\n#values: fastest refers to MAX(hero_attribute.attribute_value) WHERE attribute.attribute_name = 'Speed' refer to hero_attribute.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Speed')\n#SELECT: SELECT superhero_name refer to superhero.superhero_name\n#SQL-like: Show superhero.superhero_name WHERE hero_attribute.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Speed')\n#SQL: SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id WHERE T2.attribute_value = (SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Speed')\n```"
    ],
    "129": [
        "```\n#reason: The question wants to identify the top ten withdrawals (non-credit card) by district names for January 1996, so the SQL SELECT will involve filtering for non-credit card withdrawals and the specified date range, grouping by district names, and ordering by the amount of withdrawals.\n#columns: district.A2, trans.amount\n#values: January 1996 refers to \"trans.date LIKE '1996-01%'\" and non-credit card withdrawals refer to \"trans.type = 'VYDAJ'\"\n#SELECT: SELECT top ten withdrawals by district names refer to district.A2, trans.amount\n#SQL-like: Show district.A2, trans.amount WHERE trans.date LIKE '1996-01%' AND trans.type = 'VYDAJ' ORDER BY trans.amount DESC LIMIT 10\n#SQL: SELECT district.A2, trans.amount FROM trans INNER JOIN account ON trans.account_id = account.account_id INNER JOIN district ON account.district_id = district.district_id WHERE trans.date LIKE '1996-01%' AND trans.type = 'VYDAJ' ORDER BY trans.amount DESC LIMIT 10\n```"
    ],
    "1407": [
        "```\n#reason: The question requires displaying \"top three budgets for Advertising\" which refers to having the highest budgeted amount. \"MAX(amount)\" is used to filter the category as 'Advertisement' and obtain the top three.\n#columns: budget.budget_id, budget.amount, budget.category\n#values: category is 'Advertisement' refers to budget.category = 'Advertisement'\n#SELECT: SELECT budget_id, amount refer to budget.budget_id, budget.amount\n#SQL-like: Show budget_id, amount WHERE category is 'Advertisement' ORDER BY amount DESC LIMIT 3\n#SQL: SELECT budget_id, amount FROM budget WHERE category = 'Advertisement' ORDER BY amount DESC LIMIT 3\n```"
    ],
    "620": [
        "```\n#reason: The question wants to count the number of views of users who obtained the badge on a specific date, so the SQL SELECT COUNT(users.Views) and JOIN with the badges table to filter by the specific date.\n#columns: users.Views, badges.Date\n#values: on 7/19/2010 7:39:08 PM refer to badges.Date = '2010-07-19 19:39:08.0'\n#SELECT: SELECT COUNT(users.Views) refer to users.Views\n#SQL-like: Show COUNT(users.Views), WHERE badges.Date = '2010-07-19 19:39:08.0'\n#SQL: SELECT COUNT(users.Views) FROM badges INNER JOIN users ON badges.UserId = users.Id WHERE badges.Date = '2010-07-19 19:39:08.0'\n```"
    ],
    "960": [
        "```\n#reason: The question wants to display the \"average of fastest lap speed\" in the \"2009 Spanish Grand Prix race\", so the SQL SELECT will calculate AVG(fastestLapSpeed) from the relevant tables filtered by race name and year.\n#columns: results.fastestLapSpeed, races.name, races.year\n#values: 'Spanish Grand Prix' refer to races.name = 'Spanish Grand Prix', 2009 refer to races.year = 2009\n#SELECT: AVG(results.fastestLapSpeed) refer to results.fastestLapSpeed\n#SQL-like: Show AVG(results.fastestLapSpeed), WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009\n#SQL: SELECT AVG(CAST(results.fastestLapSpeed AS REAL)) FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.name = 'Spanish Grand Prix' AND races.year = 2009\n```"
    ],
    "455": [
        "```\n#reason: The question wants to identify cards that are promotional paintings and have multiple faces, so the SQL SELECT will include the names of the cards that meet these criteria.\n#columns: cards.name, cards.isPromo, cards.side\n#values: 'are a promotional painting' refer to cards.isPromo = 1, 'have multiple faces on the same card' refer to cards.side IS NOT NULL\n#SELECT: SELECT cards.name\n#SQL-like: Show cards.name WHERE cards.isPromo = 1 AND cards.side IS NOT NULL\n#SQL: SELECT cards.name FROM cards WHERE cards.isPromo = 1 AND cards.side IS NOT NULL\n```"
    ],
    "1456": [
        "```\n#reason: The question wants to display the \"full name of the top five members\" who \"spend the most money\", so the SQL SELECT will include the first_name and last_name of members, and we will order by the total spending in descending order.\n#columns: member.first_name, member.last_name, expense.cost\n#values: 'spend the most money' refers to SUM(expense.cost) which will be ordered in descending order.\n#SELECT: SELECT content refers to member.first_name, member.last_name\n#SQL-like: Show member.first_name, member.last_name, ORDER BY SUM(expense.cost) DESC LIMIT 5\n#SQL: SELECT T1.first_name, T1.last_name FROM member AS T1 INNER JOIN expense AS T2 ON T1.member_id = T2.link_to_member GROUP BY T1.member_id ORDER BY SUM(T2.cost) DESC LIMIT 5\n```"
    ],
    "1138": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the country where the Poland Ekstraklasa league takes place, so the SQL SELECT will retrieve the country name associated with the league.\n#columns: country.name\n#values: 'Poland Ekstraklasa' refers to league.name = 'Poland Ekstraklasa'\n#SELECT: SELECT country.name refer to country.name\n#SQL-like: Show country.name WHERE league.name = 'Poland Ekstraklasa'\n#SQL: SELECT T1.name FROM country AS T1 INNER JOIN league AS T2 ON T1.id = T2.country_id WHERE T2.name = 'Poland Ekstraklasa'\n```"
    ],
    "818": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to calculate the percentage of female superheroes among the bad superheroes. This is done by dividing the count of female superheroes by the total count of bad superheroes, both filtered by alignment.id. \n#columns: superhero.gender_id, alignment.id\n#values: bad superheroes refers to 'alignment.id = 2'\n#SELECT: SELECT MULTIPLY(DIVIDE(SUM(gender.id = 2 AND alignment.id = 2), COUNT(alignment.id = 2)), 100.0) refer to superhero.gender_id and alignment.id\n#SQL-like: Show MULTIPLY(DIVIDE(SUM(gender.id = 2 AND alignment.id = 2), COUNT(alignment.id = 2)), 100.0) WHERE alignment.id = 2\n#SQL: SELECT CAST(SUM(CASE WHEN T1.gender_id = 2 AND T2.id = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / SUM(CASE WHEN T2.id = 2 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id\n```"
    ],
    "537": [
        "```\n#reason: The question wants to count the number of posts owned by the user with the display name \"csgillespie\", so the SQL SELECT will count the posts where the owner's display name matches \"csgillespie\".\n#columns: posts.OwnerUserId, users.DisplayName\n#values: 'csgillespie' refer to users.DisplayName = 'csgillespie'\n#SELECT: SELECT COUNT(posts.Id) refer to posts.Id\n#SQL-like: Show COUNT(posts.Id) WHERE users.DisplayName = 'csgillespie'\n#SQL: SELECT COUNT(posts.Id) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie'\n```"
    ],
    "1229": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count all patients with triglyceride (TG) levels beyond the normal range, and also requires filtering by age greater than 50 years. Therefore, the SQL SELECT will count distinct patient IDs where triglyceride levels exceed 200 and the age condition is met.\n#columns: Patient.ID, Patient.Birthday, Laboratory.TG\n#values: triglyceride (TG) level beyond the normal range refers to Laboratory.TG >= 200, more than 50 years of age refers to SUBTRACT(YEAR(CURRENT_TIMESTAMP), YEAR(Patient.Birthday)) > 50\n#SELECT: COUNT(DISTINCT Patient.ID) refer to Patient.ID\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.TG >= 200 AND SUBTRACT(YEAR(CURRENT_TIMESTAMP), YEAR(Patient.Birthday)) > 50\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.TG >= 200 AND (STRFTIME('%Y', CURRENT_TIMESTAMP) - STRFTIME('%Y', T1.Birthday)) > 50\n```"
    ],
    "110": [
        "```\n#reason: The question requires finding the disposition id of the client who made a transaction of 5100 USD on the date 1998-09-02. This involves filtering transactions by the amount and date, and then retrieving the corresponding disposition id for the client associated with that transaction.\n#columns: disp.disp_id, trans.amount, trans.date, disp.client_id\n#values: '5100 USD' refers to trans.amount = 5100, '1998/9/2' refers to trans.date = '1998-09-02'\n#SELECT: 'disposition id' refers to disp.disp_id\n#SQL-like: Show disp.disp_id, WHERE trans.amount = 5100 AND trans.date = '1998-09-02'\n#SQL: SELECT T2.disp_id FROM trans AS T1 INNER JOIN disp AS T2 ON T1.account_id = T2.account_id WHERE T1.amount = 5100 AND T1.date = '1998-09-02'\n```"
    ],
    "1059": [
        "```\n#reason: The question wants to display \"player names\" and filter by the condition \"height > 180\".\n#columns: Player.player_name, Player.height\n#values: height > 180 refers to Player.height > 180\n#SELECT: player names refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player.height > 180\n#SQL: SELECT player_name FROM Player WHERE height > 180\n```"
    ],
    "616": [
        "```\n#reason: The question wants to find the comment's rating score of a specific post based on its creation date. Therefore the SQL will select the rating score from the comments table where the post's creation date is equal to the specified date.\n#columns: comments.Score, comments.PostId, comments.CreationDate\n#values: 'created on 7/19/2010 7:19:56 PM' refer to comments.CreationDate = '2010-07-19 19:19:56.0'\n#SELECT: SELECT comments.Score\n#SQL-like: Show comments.Score WHERE comments.CreationDate = '2010-07-19 19:19:56.0'\n#SQL: SELECT T1.Score FROM comments AS T1 WHERE T1.CreationDate = '2010-07-19 19:19:56.0'\n```"
    ],
    "812": [
        "```\n#reason: The question wants to list down at least five full names of superheroes with blue eyes, so the SQL SELECT will gather full names from the superhero table where the eye colour matches 'Blue'.\n#columns: superhero.full_name\n#values: 'blue eyes' refer to colour.colour = 'Blue' WHERE superhero.eye_colour_id = colour.id\n#SELECT: SELECT superhero.full_name\n#SQL-like: Show superhero.full_name, WHERE colour.colour = 'Blue'\n#SQL: SELECT T1.full_name FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T2.colour = 'Blue'\n```"
    ],
    "1002": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the full name, nationality, and the race name of the youngest racer which refers to the maximum date of birth (dob). Therefore, the SQL SELECT will include these three fields.\n#columns: drivers.forename, drivers.surname, drivers.nationality, races.name\n#values: youngest racer refers to MAX(drivers.dob)\n#SELECT: 'the full name of the youngest racer' refers to CONCAT(drivers.forename, ' ', drivers.surname), 'her nationality' refers to drivers.nationality, 'the name of the race to which he/she first joined' refers to races.name\n#SQL-like: Show CONCAT(drivers.forename, ' ', drivers.surname), drivers.nationality, races.name ORDER BY drivers.dob DESC LIMIT 1\n#SQL: SELECT CONCAT(T1.forename, ' ', T1.surname), T1.nationality, T2.name FROM drivers AS T1 INNER JOIN results AS T3 ON T1.driverId = T3.driverId INNER JOIN races AS T2 ON T3.raceId = T2.raceId ORDER BY T1.dob DESC LIMIT 1\n```"
    ],
    "571": [
        "```\n#reason: The question wants to find the ratio of the number of posts to the number of votes for user No. 24, so the SQL SELECT will count the posts and votes for that user and divide them.\n#columns: posts.Id, votes.Id\n#values: user No. 24 refers to posts.OwnerUserId = 24 and votes.UserId = 24\n#SELECT: times of his/her posts than votes refer to Divide (Count(posts.Id), Count(votes.Id))\n#SQL-like: Show Divide (Count(posts.Id), Count(votes.Id)), WHERE posts.OwnerUserId = 24 AND votes.UserId = 24\n#SQL: SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(T2.Id) FROM posts AS T1 LEFT JOIN votes AS T2 ON T1.OwnerUserId = T2.UserId WHERE T1.OwnerUserId = 24 AND T2.UserId = 24\n```"
    ],
    "1476": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the difference in gas consumption between CZK-paying customers and EUR-paying customers in 2012, so the SQL SELECT will calculate the total consumption for each currency and then find the difference.\n#columns: yearmonth.Consumption, customers.Currency, yearmonth.CustomerID\n#values: 'in 2012' refers to yearmonth.Date BETWEEN '201201' AND '201212'\n#SELECT: difference in gas consumption refers to SUBTRACT(SUM(CASE WHEN customers.Currency = 'CZK' THEN yearmonth.Consumption ELSE 0 END), SUM(CASE WHEN customers.Currency = 'EUR' THEN yearmonth.Consumption ELSE 0 END))\n#SQL-like: Show SUBTRACT(SUM(CASE WHEN customers.Currency = 'CZK' THEN yearmonth.Consumption ELSE 0 END), SUM(CASE WHEN customers.Currency = 'EUR' THEN yearmonth.Consumption ELSE 0 END)), WHERE yearmonth.Date BETWEEN '201201' AND '201212'\n#SQL: SELECT SUM(CASE WHEN T1.Currency = 'CZK' THEN T2.Consumption ELSE 0 END) - SUM(CASE WHEN T1.Currency = 'EUR' THEN T2.Consumption ELSE 0 END) FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID WHERE T2.Date BETWEEN '201201' AND '201212'\n```"
    ],
    "1418": [
        "```\n#reason: The question wants to display the category of events, so the SQL SELECT will focus on the category column from the budget table where the event location is 'MU 215'.\n#columns: budget.category\n#values: held at MU 215 refers to event.location = 'MU 215'\n#SELECT: SELECT budget.category refer to budget.category\n#SQL-like: Show budget.category WHERE event.location = 'MU 215'\n#SQL: SELECT DISTINCT budget.category FROM budget INNER JOIN event ON budget.link_to_event = event.event_id WHERE event.location = 'MU 215'\n```"
    ],
    "725": [
        "```\n#reason: The question want to determine \"How many superheroes\" and focuses on those \"published by Marvel Comics.\" \n#columns: superhero.id, publisher.publisher_name\n#values: 'published by Marvel Comics' refer to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT COUNT(superhero.id) refer to superhero.id\n#SQL-like: Show COUNT(superhero.id), WHERE publisher.publisher_name = 'Marvel Comics'\n#SQL: SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'\n```"
    ],
    "1124": [
        "```\n#reason: The question wants to identify players who have a high attacking work rate, so the SQL SELECT will retrieve player names where attacking_work_rate is 'high'.\n#columns: Player.player_name, Player_Attributes.attacking_work_rate\n#values: attacking_work_rate = 'high' refer to Player_Attributes.attacking_work_rate = 'high'\n#SELECT: players refer to Player.player_name\n#SQL-like: Show Player.player_name, WHERE Player_Attributes.attacking_work_rate = 'high'\n#SQL: SELECT T1.player_name FROM Player AS T1 INNER JOIN Player_Attributes AS T2 ON T1.player_api_id = T2.player_api_id WHERE T2.attacking_work_rate = 'high'\n```"
    ],
    "255": [
        "```\n#reason: The question wants to calculate the proportion of single bonds that are carcinogenic, so the SQL SELECT will count the number of carcinogenic single bonds and divide it by the total number of single bonds, then multiply by 100 to get the percentage.\n#columns: bond.bond_type, molecule.label, bond.bond_id\n#values: single bond refers to bond.bond_type = '-', carcinogenic refers to molecule.label = '+'\n#SELECT: proportion of single bonds that are carcinogenic refer to DIVIDE(SUM(molecule.label = '+') * 100, COUNT(bond.bond_id)) where bond.bond_type = '-'\n#SQL-like: Show DIVIDE(SUM(molecule.label = '+') * 100, COUNT(bond.bond_id)) WHERE bond.bond_type = '-'\n#SQL: SELECT CAST(SUM(CASE WHEN T2.label = '+' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.bond_id) FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '-'\n```"
    ],
    "923": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of Formula_1 races held in Italy, so the SQL SELECT will count the races related to circuits in Italy.\n#columns: COUNT(races.raceId)\n#values: circuits.country = 'Italy' refer to circuits.country = 'Italy'\n#SELECT: SELECT COUNT(races.raceId) refer to COUNT(races.raceId)\n#SQL-like: Show COUNT(races.raceId), WHERE circuits.country = 'Italy'\n#SQL: SELECT COUNT(T1.raceId) FROM races AS T1 INNER JOIN circuits AS T2 ON T1.circuitId = T2.circuitId WHERE T2.country = 'Italy'\n```"
    ],
    "1078": [
        "```\n#reason: The question requires comparing the ages of two players, Aaron Lennon and Abdelaziz Barrada, where older refers to the earlier birthday. So the SQL SELECT statement will query for their birthdays and will use ordering to find which is older.\n#columns: Player.player_name, Player.birthday\n#values: 'Aaron Lennon' refers to Player.player_name = 'Aaron Lennon', 'Abdelaziz Barrada' refers to Player.player_name = 'Abdelaziz Barrada'\n#SELECT: SELECT Player.player_name FROM Player WHERE Player.player_name = 'Aaron Lennon' OR Player.player_name = 'Abdelaziz Barrada' ORDER BY Player.birthday LIMIT 1\n#SQL-like: Show Player.player_name, WHERE Player.player_name = 'Aaron Lennon' OR Player.player_name = 'Abdelaziz Barrada' ORDER BY Player.birthday LIMIT 1\n#SQL: SELECT player_name FROM Player WHERE player_name = 'Aaron Lennon' OR player_name = 'Abdelaziz Barrada' ORDER BY birthday LIMIT 1\n```"
    ],
    "182": [
        "```\n#reason: The question wants to count the number of male customers born between 1974 and 1976 who made a payment on their home in excess of $4000, so the SQL SELECT will count the customers based on the specified conditions.\n#columns: client.gender, client.birth_date, order.amount\n#values: male refers to client.gender = 'M', born between 1974 and 1976 refers to client.birth_date BETWEEN '1974-01-01' AND '1976-12-31', payment in excess of $4000 refers to order.amount > 4000, and 'SIPO' stands for order.k_symbol = 'SIPO'.\n#SELECT: How many male customers refer to COUNT(client.gender)\n#SQL-like: Show COUNT(client.gender), WHERE client.gender = 'M' AND client.birth_date BETWEEN '1974-01-01' AND '1976-12-31' AND order.amount > 4000 AND order.k_symbol = 'SIPO'\n#SQL: SELECT COUNT(T1.gender) FROM client AS T1 INNER JOIN order AS T2 ON T1.client_id = T2.client_id WHERE T1.gender = 'M' AND T1.birth_date BETWEEN '1974-01-01' AND '1976-12-31' AND T2.amount > 4000 AND T2.k_symbol = 'SIPO'\n```"
    ],
    "1248": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to find the count of distinct patients who were born after January 1, 1980, and have an abnormal fibrinogen level outside the normal range of 150 to 450. \n#columns: Patient.ID, Patient.Birthday, Laboratory.FG\n#values: born after 1980/1/1 refers to Patient.Birthday > '1980-01-01', abnormal fibrinogen level refers to Laboratory.FG < 150 OR Laboratory.FG > 450\n#SELECT: How many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Patient.Birthday > '1980-01-01' AND (Laboratory.FG < 150 OR Laboratory.FG > 450)\n#SQL: SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday > '1980-01-01' AND (T2.FG < 150 OR T2.FG > 450)\n```"
    ],
    "244": [
        "```\n#reason: The question wants to determine if the molecule with the most double bonds is carcinogenic, so the SQL SELECT will count double bonds and filter for carcinogenic molecules.\n#columns: bond.bond_type, molecule.label, molecule.molecule_id\n#values: double bond refers to bond.bond_type = '=', carcinogenic refers to molecule.label = '+'\n#SELECT: SELECT molecule.label, COUNT(bond.bond_id) \n#SQL-like: SELECT molecule.label, COUNT(bond.bond_id) WHERE bond.bond_type = '=' AND molecule.label = '+' GROUP BY molecule.molecule_id ORDER BY COUNT(bond.bond_id) DESC LIMIT 1\n#SQL: SELECT T2.label FROM bond AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.bond_type = '=' AND T2.label = '+' GROUP BY T2.molecule_id ORDER BY COUNT(T1.bond_id) DESC LIMIT 1\n```"
    ],
    "745": [
        "```\n#reason: The question want to get the publisher ID of 'Star Trek', so the SQL SELECT publisher.id and publisher.publisher_name = 'Star Trek' will filter for the specific publisher's name.\n#columns: publisher.id, publisher.publisher_name\n#values: 'Star Trek' refer to publisher.publisher_name = 'Star Trek'\n#SELECT: SELECT publisher.id refer to publisher.id\n#SQL-like: Show publisher.id WHERE publisher.publisher_name = 'Star Trek'\n#SQL: SELECT publisher.id FROM publisher WHERE publisher.publisher_name = 'Star Trek'\n```"
    ],
    "644": [
        "```\n#reason: The question requires displaying \"the last edit date and last edit user ID\" for the post with the specified title, which is a filtering condition.\n#columns: posts.LastEditDate, posts.LastEditorUserId\n#values: Title = 'Detecting a given face in a database of facial images' refer to posts.Title = 'Detecting a given face in a database of facial images'\n#SELECT: last edit date and last edit user ID refer to posts.LastEditDate, posts.LastEditorUserId\n#SQL-like: Show posts.LastEditDate, posts.LastEditorUserId WHERE posts.Title = 'Detecting a given face in a database of facial images'\n#SQL: SELECT T1.LastEditDate, T1.LastEditorUserId FROM posts AS T1 WHERE T1.Title = 'Detecting a given face in a database of facial images'\n```"
    ],
    "788": [
        "```\n#reason: The question wants to calculate the percentage of female heroes published by Marvel Comics, so the SQL SELECT will count the number of female heroes and divide it by the total number of heroes published by Marvel Comics, then multiply by 100.\n#columns: superhero.gender_id, publisher.publisher_name\n#values: 'female heroes' refer to superhero.gender_id = 2, 'Marvel Comics' refer to publisher.publisher_name = 'Marvel Comics'\n#SELECT: SELECT percent refer to (CAST(SUM(CASE WHEN T1.gender_id = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.publisher_id))\n#SQL-like: Show (CAST(SUM(CASE WHEN gender_id = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(publisher_id)), WHERE publisher_name = 'Marvel Comics'\n#SQL: SELECT CAST(SUM(CASE WHEN T1.gender_id = 2 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.publisher_id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T2.publisher_name = 'Marvel Comics'\n```"
    ],
    "1299": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to count the number of patients with a normal level of triglyceride and who have other symptoms observed, so the SQL SELECT will count the patient IDs where triglyceride is less than 200 and symptoms are not null.\n#columns: Patient.ID, Laboratory.TG, Examination.Symptoms\n#values: normal level of triglyceride refers to Laboratory.TG < 200; have other symptoms refers to Examination.Symptoms IS NOT NULL\n#SELECT: how many patients refer to COUNT(DISTINCT Patient.ID)\n#SQL-like: Show COUNT(DISTINCT Patient.ID), WHERE Laboratory.TG < 200 AND Examination.Symptoms IS NOT NULL\n#SQL: SELECT COUNT(DISTINCT P.ID) FROM Patient AS P INNER JOIN Laboratory AS L ON P.ID = L.ID INNER JOIN Examination AS E ON P.ID = E.ID WHERE L.TG < 200 AND E.Symptoms IS NOT NULL\n```"
    ],
    "1438": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to indicate the college of the person whose first name is Katy and who has a specific link to the major, so the SQL SELECT will retrieve the college from the major table where the corresponding member's first name is 'Katy'.\n#columns: major.college, member.first_name, member.link_to_major\n#values: 'Katy' refer to member.first_name = 'Katy', 'rec1N0upiVLy5esTO' refer to member.link_to_major = 'rec1N0upiVLy5esTO'\n#SELECT: SELECT major.college refer to major.college\n#SQL-like: Show major.college WHERE member.first_name = 'Katy' AND member.link_to_major = 'rec1N0upiVLy5esTO'\n#SQL: SELECT T1.college FROM major AS T1 INNER JOIN member AS T2 ON T2.link_to_major = T1.major_id WHERE T2.first_name = 'Katy' AND T2.link_to_major = 'rec1N0upiVLy5esTO'\n```"
    ],
    "1263": [
        "```\n#reason: The question wants to identify the patient with the highest anti-Cardiolipin antibody concentration among those whose level of Hematoclit isn't normal, so the SQL SELECT will focus on the patient's ID and the maximum value of `aCL IgA`.\n#columns: Patient.ID, Laboratory.HCT, Examination.`aCL IgA`\n#values: Hematoclit isn't normal refers to Laboratory.HCT < 29 OR Laboratory.HCT > 52\n#SELECT: SELECT Patient.ID\n#SQL-like: Show Patient.ID, WHERE Laboratory.HCT < 29 OR Laboratory.HCT > 52 ORDER BY Examination.`aCL IgA` DESC LIMIT 1\n#SQL: SELECT Patient.ID FROM Patient INNER JOIN Laboratory ON Patient.ID = Laboratory.ID INNER JOIN Examination ON Patient.ID = Examination.ID WHERE Laboratory.HCT < 29 OR Laboratory.HCT > 52 ORDER BY Examination.`aCL IgA` DESC LIMIT 1\n```"
    ],
    "1025": [
        "```\n#reason: Analyze how to generate SQL based on the question. The question wants to identify the league that had the most goals in the 2016 season, so the SQL SELECT will aggregate the total goals from both home and away teams, filter by the specified season, and then order by the total goals to find the league with the maximum.\n#columns: League.name, Match.home_team_goal, Match.away_team_goal, Match.season\n#values: 2016 season refers to Match.season = '2015/2016'\n#SELECT: SELECT League.name refer to League.name\n#SQL-like: Show League.name, WHERE Match.season = '2015/2016', GROUP BY League.name, ORDER BY SUM(Match.home_team_goal + Match.away_team_goal) DESC LIMIT 1\n#SQL: SELECT L.name FROM League AS L INNER JOIN Match AS M ON L.id = M.league_id WHERE M.season = '2015/2016' GROUP BY L.name ORDER BY SUM(M.home_team_goal + M.away_team_goal) DESC LIMIT 1\n```"
    ],
    "789": [
        "```\n#reason: The question wants to find the average weight of the heroes who are aliens, so the SQL SELECT will calculate AVG(weight_kg) and filter by race = 'Alien'.\n#columns: superhero.weight_kg, race.race\n#values: aliens refer to race = 'Alien'\n#SELECT: average weight refer to AVG(weight_kg)\n#SQL-like: Show AVG(superhero.weight_kg), WHERE race.race = 'Alien'\n#SQL: SELECT AVG(weight_kg) FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE race.race = 'Alien'\n```"
    ]
}